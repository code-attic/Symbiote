<?xml version="1.0"?>
<doc>
    <assembly>
        <name>jabber-net</name>
    </assembly>
    <members>
        <member name="T:xpnet.Position">
            Represents a position in an entity.
            A position can be modified by <code>Encoding.movePosition</code>.
            @see Encoding#movePosition
            @version $Revision: 724 $ $Date: 2008-08-06 13:09:25 -0500 (Wed, 06 Aug 2008) $
            <summary>
             Position of an entry in a table.
            </summary>
        </member>
        <member name="M:xpnet.Position.#ctor">
            Creates a position for the start of an entity: the line number is
            1 and the column number is 0.
        </member>
        <member name="M:xpnet.Position.Clone">
            Returns a copy of this position.
        </member>
        <member name="P:xpnet.Position.LineNumber">
            Returns the line number.
            The first line number is 1.
        </member>
        <member name="P:xpnet.Position.ColumnNumber">
            Returns the column number.
            The first column number is 0.
            A tab character is not treated specially.
        </member>
        <member name="T:stringprep.Plain">
            <summary>
            A relatively plain stringprep profile, that doesn't do case folding, or prevent unassigned characters.
            </summary>
        </member>
        <member name="T:stringprep.Profile">
            <summary>
            Summary description for Prep.
            </summary>
        </member>
        <member name="F:stringprep.Profile.B_1">
            <summary>
            RFC 3454, Appendix B.1
            </summary>
        </member>
        <member name="F:stringprep.Profile.B_2">
            <summary>
            RFC 3454, Appendix B.2
            </summary>
        </member>
        <member name="F:stringprep.Profile.B_3">
            <summary>
            RFC 3454, Appendix B.3
            </summary>
        </member>
        <member name="F:stringprep.Profile.C_1_1">
            <summary>
            RFC 3454, Appendix C.1.1
            </summary>
        </member>
        <member name="F:stringprep.Profile.C_1_2">
            <summary>
            RFC 3454, Appendix C.1.2
            </summary>
        </member>
        <member name="F:stringprep.Profile.C_2_1">
            <summary>
            RFC 3454, Appendix C.2.1
            </summary>
        </member>
        <member name="F:stringprep.Profile.C_2_2">
            <summary>
            RFC 3454, Appendix C.2.2
            </summary>
        </member>
        <member name="F:stringprep.Profile.C_3">
            <summary>
            RFC 3454, Appendix C.3
            </summary>
        </member>
        <member name="F:stringprep.Profile.C_4">
            <summary>
            RFC 3454, Appendix C.4
            </summary>
        </member>
        <member name="F:stringprep.Profile.C_5">
            <summary>
            RFC 3454, Appendix C.5
            </summary>
        </member>
        <member name="F:stringprep.Profile.C_6">
            <summary>
            RFC 3454, Appendix C.6
            </summary>
        </member>
        <member name="F:stringprep.Profile.C_7">
            <summary>
            RFC 3454, Appendix C.7
            </summary>
        </member>
        <member name="F:stringprep.Profile.C_8">
            <summary>
            RFC 3454, Appendix C.8
            </summary>
        </member>
        <member name="F:stringprep.Profile.C_9">
            <summary>
            RFC 3454, Appendix C.9
            </summary>
        </member>
        <member name="F:stringprep.Profile.NFKC">
            <summary>
            RFC 3454, Section 4
            </summary>
        </member>
        <member name="F:stringprep.Profile.BIDI">
            <summary>
            RFC 3454, Section 6
            </summary>
        </member>
        <member name="F:stringprep.Profile.UNASSIGNED">
            <summary>
            RFC 3454, Section 7
            </summary>
        </member>
        <member name="M:stringprep.Profile.#ctor(stringprep.steps.ProfileStep[])">
            <summary>
            Create a new profile, with the given steps.
            </summary>
            <param name="profile">The steps to perform</param>
        </member>
        <member name="M:stringprep.Profile.Prepare(System.String)">
            <summary>
            Prepare a string, according to the specified profile.
            </summary>
            <param name="input">The string to prepare</param>
            <returns>The prepared string</returns>
        </member>
        <member name="M:stringprep.Profile.Prepare(System.Text.StringBuilder)">
            <summary>
            Prepare a string, according to the specified profile, in place.
            Not thread safe; make sure the input is locked, if appropriate.
            (this is the canonical version, that should be overriden by
            subclasses if necessary)
            </summary>
            <param name="result">The string to prepare in place</param>
        </member>
        <member name="M:stringprep.Plain.#ctor">
            <summary>
            Create a Plain instance.
            </summary>
        </member>
        <member name="T:jabber.protocol.client.BadProtocolException">
            <summary>
            Invalid protocol received.
            </summary>
        </member>
        <member name="M:jabber.protocol.client.BadProtocolException.#ctor(System.Xml.XmlElement,System.String)">
            <summary>
            Create a protocol exception
            </summary>
            <param name="badProtocol">The protocol that was bad.  Typically the top-most (stanza) element.</param>
            <param name="message">An optional message.  May be null.</param>
        </member>
        <member name="P:jabber.protocol.client.BadProtocolException.Message">
            <summary>
            Gets a message that describes the current exception.
            </summary>
        </member>
        <member name="T:jabber.protocol.client.IQException">
            <summary>
            A jabber error, in an IQ.
            </summary>
        </member>
        <member name="M:jabber.protocol.client.IQException.#ctor(jabber.protocol.client.IQ)">
            <summary>
            An authorization exception from an IQ.
            TODO: Add constructor for code/message
            TODO: understand v1 errors
            </summary>
            <param name="iq"></param>
        </member>
        <member name="M:jabber.protocol.client.IQException.ToString">
            <summary>
            Return the error code and message.
            </summary>
            <returns></returns>
        </member>
        <member name="P:jabber.protocol.client.IQException.Code">
            <summary>
            The Jabber error number
            </summary>
        </member>
        <member name="P:jabber.protocol.client.IQException.Description">
            <summary>
            The text description of the message
            </summary>
        </member>
        <member name="T:jabber.protocol.AsynchElementStream">
            <summary>
            Summary description for AsynchElementStream.
            TODO: combine with ElementStream, since there's only one impl now.
            </summary>
        </member>
        <member name="T:jabber.protocol.ElementStream">
             <summary>
             Async XML parsing, according to jabber protocol rules of "interesting".
             The root node fires IElementStreamListener.OnDocumentStart(), and each
             direct child of the root fires IElementStreamListener.OnTag().
            
             TODO: Combine with AsyncElementStream, since there's only one impl.
             </summary>
        </member>
        <member name="F:jabber.protocol.ElementStream.m_doc">
            <summary>
            The document to create elements in
            </summary>
        </member>
        <member name="F:jabber.protocol.ElementStream.m_factory">
            <summary>
            The element factory.
            </summary>
        </member>
        <member name="M:jabber.protocol.ElementStream.#ctor">
            <summary>
            Create a parser that will report events to the listener.
            </summary>
        </member>
        <member name="M:jabber.protocol.ElementStream.AddFactory(jabber.protocol.IPacketTypes)">
            <summary>
            Add PacketFactories to get XmlElements with type-safe accessors, for
            all of the namespaces you care about.
            </summary>
            <param name="pf"></param>
        </member>
        <member name="M:jabber.protocol.ElementStream.AddType(System.String,System.String,System.Type)">
            <summary>
            Add a type to the packet factory.
            </summary>
            <param name="localName">Local Name (e.g. query)</param>
            <param name="ns">Namespace URI (e.g. jabber:iq:roster)</param>
            <param name="t">Type to create</param>
        </member>
        <member name="M:jabber.protocol.ElementStream.FireOnDocumentStart(System.Xml.XmlElement)">
            <summary>
            Fire the OnDocumentStart event
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:jabber.protocol.ElementStream.FireOnElement(System.Xml.XmlElement)">
            <summary>
            Fire the OnElement event
            </summary>
            <param name="elem"></param>
        </member>
        <member name="M:jabber.protocol.ElementStream.FireOnDocumentEnd">
            <summary>
            Fire the OnDocumentEnd event
            </summary>
        </member>
        <member name="M:jabber.protocol.ElementStream.FireOnError(System.Exception)">
            <summary>
            Fire the OnError event
            </summary>
            <param name="ex">The exception that was thrown</param>
        </member>
        <member name="M:jabber.protocol.ElementStream.GetElement(System.String,System.String)">
            <summary>
            Get an element by name using the current factory.
            </summary>
            <param name="name">The element name to use</param>
            <param name="ns">The namespace URI of the element to get</param>
            <returns></returns>
        </member>
        <member name="E:jabber.protocol.ElementStream.OnDocumentStart">
            <summary>
            The document started.  This will have a full element, even
            though only the start tag has been received.
            </summary>
        </member>
        <member name="E:jabber.protocol.ElementStream.OnDocumentEnd">
            <summary>
            The document has completed.
            TODO: This isn't fired as often as it needs to be, yet.
            </summary>
        </member>
        <member name="E:jabber.protocol.ElementStream.OnElement">
            <summary>
            A protocol element (child of the doc root) has been received.
            </summary>
        </member>
        <member name="E:jabber.protocol.ElementStream.OnError">
            <summary>
            An XML parsing error occurred.
            </summary>
        </member>
        <member name="P:jabber.protocol.ElementStream.Document">
            <summary>
            The document being read into.  This document is used for creating nodes,
            but does not actually contain the nodes.
            </summary>
        </member>
        <member name="M:jabber.protocol.AsynchElementStream.#ctor">
            <summary>
            Create an instance.
            </summary>
        </member>
        <member name="M:jabber.protocol.AsynchElementStream.Push(System.Byte[])">
            <summary>
            Put bytes into parser.  Used by test routines, only, for convenience.
            </summary>
            <param name="buf"></param>
        </member>
        <member name="M:jabber.protocol.AsynchElementStream.Push(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Put bytes into the parser.
            </summary>
            <param name="buf">The bytes to put into the parse stream</param>
            <param name="offset">Offset into buf to start at</param>
            <param name="length">Number of bytes to write</param>
        </member>
        <member name="T:jabber.protocol.AsynchElementStream.XMLParseException">
            <summary>
            There was an error parsing XML.  What was the context?
            </summary>
        </member>
        <member name="M:jabber.protocol.AsynchElementStream.XMLParseException.#ctor(System.Exception,jabber.protocol.AsynchElementStream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Some XML parsing error occurred.  Wrap it, and generate a little more context, so that we can try
            to figure out where the actual error happened.
            </summary>
            <param name="innerException"></param>
            <param name="stream"></param>
            <param name="buf"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="M:jabber.protocol.AsynchElementStream.XMLParseException.ToString">
            <summary>
            String representation.
            </summary>
            <returns></returns>
        </member>
        <member name="P:jabber.protocol.AsynchElementStream.XMLParseException.Context">
            <summary>
            More context of where the error ocurred
            </summary>
        </member>
        <member name="T:jabber.connection.sasl.KerbProcessor">
            <summary>
             Uses Kerberos authentication ot log into XMPP server.
            </summary>
        </member>
        <member name="T:jabber.connection.sasl.SASLProcessor">
            <summary>
            Summary description for SASLProcessor.
            </summary>
        </member>
        <member name="F:jabber.connection.sasl.SASLProcessor.USERNAME">
            <summary>
            SASL username
            </summary>
        </member>
        <member name="F:jabber.connection.sasl.SASLProcessor.PASSWORD">
            <summary>
            SASL password
            </summary>
        </member>
        <member name="F:jabber.connection.sasl.SASLProcessor.m_directives">
             <summary>
            
             </summary>
        </member>
        <member name="M:jabber.connection.sasl.SASLProcessor.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="M:jabber.connection.sasl.SASLProcessor.createProcessor(jabber.protocol.stream.MechanismType,System.Boolean,jabber.protocol.stream.Mechanisms)">
            <summary>
            Create a new SASLProcessor, of the best type possible
            </summary>
            <param name="mt">The types the server implements</param>
            <param name="plaintextOK">Is it ok to select insecure types?</param>
            <param name="mechs">The mechanisms supported by the server</param>
            <returns></returns>
        </member>
        <member name="M:jabber.connection.sasl.SASLProcessor.step(jabber.protocol.stream.Step,System.Xml.XmlDocument)">
            <summary>
            Perform the next step
            </summary>
            <param name="s">Null if it's the initial response</param>
            <param name="doc">Document to create Steps in</param>
            <returns></returns>
        </member>
        <member name="M:jabber.connection.sasl.SASLProcessor.HexString(System.Byte[])">
            <summary>
            byte array as a hex string, two chars per byte.
            </summary>
            <param name="buf">Byte array</param>
            <returns></returns>
        </member>
        <member name="P:jabber.connection.sasl.SASLProcessor.Item(System.String)">
            <summary>
            Data for performing SASL challenges and responses.
            </summary>
        </member>
        <member name="F:jabber.connection.sasl.KerbProcessor.USE_WINDOWS_CREDS">
            <summary>
            Should we use the existing Windows (kerberos) credentials?
            </summary>
        </member>
        <member name="M:jabber.connection.sasl.KerbProcessor.#ctor(System.String)">
            <summary>
             Creates a new KerbProcessor
            </summary>
            <param name="remotePrincipal">Remote principal that represents the XMPP server.</param>
        </member>
        <member name="M:jabber.connection.sasl.KerbProcessor.step(jabber.protocol.stream.Step,System.Xml.XmlDocument)">
            <summary>
            Perform the next step
            </summary>
            <param name="s">Null if it's the initial response</param>
            <param name="doc">Document to create Steps in</param>
            <returns>XML to send to the XMPP server.</returns>
        </member>
        <member name="T:bedrock.net.XEP124Exception">
            <summary>
            XEP-0124 Error conditions
            </summary>
        </member>
        <member name="M:bedrock.net.XEP124Exception.#ctor(System.String)">
             <summary>
            
             </summary>
             <param name="reason"></param>
        </member>
        <member name="T:bedrock.net.XEP124Socket">
            <summary>
            Make a XEP-124 (http://www.xmpp.org/extensions/xep-0124.html) polling "connection" look like a socket.
            TODO: get rid of the PipeStream, if possible.
            </summary>
        </member>
        <member name="T:bedrock.net.BaseSocket">
            <summary>
            Base class for AsyncSocket and proxies for AsyncSocket
            </summary>
        </member>
        <member name="F:bedrock.net.BaseSocket.m_hostid">
            <summary>
            Identity of the host we're connecting to.  Used for SSL
            validation, this is the name of the SRV we looked up, for
            example.
            </summary>
        </member>
        <member name="F:bedrock.net.BaseSocket.m_listener">
            <summary>
            Call through this interface when events happen.  WARNING:
            AsyncSocket assumes this is not NULL.
            </summary>
        </member>
        <member name="M:bedrock.net.BaseSocket.#ctor">
            <summary>
            Only to be called by things that immediately set m_listener!
            </summary>
        </member>
        <member name="M:bedrock.net.BaseSocket.#ctor(bedrock.net.ISocketEventListener)">
            <summary>
            Construct a BaseSocket.
            </summary>
            <param name="listener"></param>
        </member>
        <member name="M:bedrock.net.BaseSocket.Accept(bedrock.net.Address)">
            <summary>
            Prepare to start accepting inbound requests.  Call
            RequestAccept() to start the async process.
            Default the listen queue size to 5.
            </summary>
            <param name="addr">Address to listen on</param>
        </member>
        <member name="M:bedrock.net.BaseSocket.Accept(bedrock.net.Address,System.Int32)">
            <summary>
            Prepare to start accepting inbound requests.  Call
            RequestAccept() to start the async process.
            </summary>
            <param name="addr">Address to listen on</param>
            <param name="backlog">The Maximum length of the queue of
            pending connections</param>
        </member>
        <member name="M:bedrock.net.BaseSocket.RequestAccept">
            <summary>
            Start the flow of async accepts.  Flow will continue while
            Listener.OnAccept() returns true.  Otherwise, call RequestAccept() again
            to continue.
            </summary>
        </member>
        <member name="M:bedrock.net.BaseSocket.Connect(bedrock.net.Address,System.String)">
            <summary>
            Outbound connection.  Eventually calls Listener.OnConnect() when
            the connection comes up.  Don't forget to call RequestRead() in
            OnConnect()!
            </summary>
            <param name="addr">Address/hostname to connect to</param>
            <param name="hostIdentity">Identity of the host we're
            connecting to.  Used for SSL validation, this is the name
            of the SRV we looked up, for example.</param>
        </member>
        <member name="M:bedrock.net.BaseSocket.Connect(bedrock.net.Address)">
            <summary>
            Outbound connection.  Eventually calls Listener.OnConnect() when
            the connection comes up.  Don't forget to call RequestRead() in
            OnConnect()!
            </summary>
            <param name="addr"></param>
        </member>
        <member name="M:bedrock.net.BaseSocket.StartTLS">
            <summary>
            Start TLS processing on an open socket.
            </summary>
        </member>
        <member name="M:bedrock.net.BaseSocket.StartCompression">
            <summary>
            Start XEP-138 compression on this socket.
            </summary>
        </member>
        <member name="M:bedrock.net.BaseSocket.RequestRead">
            <summary>
            Start an async read from the socket.  Listener.OnRead() is
            eventually called when data arrives.
            </summary>
        </member>
        <member name="M:bedrock.net.BaseSocket.Write(System.Byte[])">
            <summary>
            Async write to the socket.  Listener.OnWrite will be
            called eventually when the data has been written.  A copy
            is made of the data, internally.
            </summary>
            <param name="buf">Data to write</param>
        </member>
        <member name="M:bedrock.net.BaseSocket.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Async write to the socket.  Listener.OnWrite will be
            called eventually when the data has been written.  A
            trimmed copy is made of the data, internally.
            </summary>
            <param name="buf">Buffer to output</param>
            <param name="offset">Offset into buffer</param>
            <param name="len">Number of bytes to output</param>
        </member>
        <member name="M:bedrock.net.BaseSocket.Close">
            <summary>
            Close the socket.  This is NOT async.  .Net doesn't have
            async closes.  But, it can be *called* async, particularly
            from GotData.  Attempts to do a shutdown() first.
            </summary>
        </member>
        <member name="P:bedrock.net.BaseSocket.Listener">
            <summary>
            Where to send notifications of interesting things.
            WARNING!  Only assign to this if you are Tom Waters.
            </summary>
        </member>
        <member name="P:bedrock.net.BaseSocket.Connected">
            <summary>
             Returns true if the socket is connected.
            </summary>
        </member>
        <member name="T:bedrock.net.IElementSocket">
            <summary>
            This socket has special support for writing XML elements.
            </summary>
        </member>
        <member name="M:bedrock.net.IElementSocket.Write(System.Xml.XmlElement)">
            <summary>
            Write an XML element to the socket.
            </summary>
            <param name="elem"></param>
        </member>
        <member name="T:bedrock.net.ISocketEventListener">
            <summary>
            Interface class for Socket events. Any object which
            implements these interfaces is eligible to recieve Socket
            events.  This is an interface instead of events in order
            to preserve symmetry with libbedrock.
            </summary>
        </member>
        <member name="M:bedrock.net.ISocketEventListener.OnInit(bedrock.net.BaseSocket)">
            <summary>
            An accept socket is about to be bound, or a connect socket is about to connect,
            or an incoming socket just came in.  Use this as an opportunity to
            </summary>
            <param name="newSock">The new socket that is about to be connected.</param>
        </member>
        <member name="M:bedrock.net.ISocketEventListener.GetListener(bedrock.net.BaseSocket)">
            <summary>
            We accepted a socket, and need to get a listener.
            If the return value is null, then the socket will be closed,
            and RequestAccept will ALWAYS be called.
            </summary>
            <param name="newSock">The new socket.</param>
            <returns>The listener for the *new* socket, as compared to
            the listener for the *listen* socket</returns>
        </member>
        <member name="M:bedrock.net.ISocketEventListener.OnAccept(bedrock.net.BaseSocket)">
            <summary>
            A new incoming connection was accepted.
            </summary>
            <param name="newsocket">Socket for new connection.</param>
            <returns>true if RequestAccept() should be called automatically again</returns>
        </member>
        <member name="M:bedrock.net.ISocketEventListener.OnConnect(bedrock.net.BaseSocket)">
            <summary>
            Outbound connection was connected.
            </summary>
            <param name="sock">Connected socket.</param>
        </member>
        <member name="M:bedrock.net.ISocketEventListener.OnClose(bedrock.net.BaseSocket)">
            <summary>
            Connection was closed.
            </summary>
            <param name="sock">Closed socket.  Already closed!</param>
        </member>
        <member name="M:bedrock.net.ISocketEventListener.OnError(bedrock.net.BaseSocket,System.Exception)">
            <summary>
            An error happened in processing.  The socket is no longer open.
            </summary>
            <param name="sock">Socket in error</param>
            <param name="ex">Exception that caused the error</param>
        </member>
        <member name="M:bedrock.net.ISocketEventListener.OnRead(bedrock.net.BaseSocket,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Bytes were read from the socket.
            </summary>
            <param name="sock">The socket that was read from.</param>
            <param name="buf">The bytes that were read.</param>
            <param name="offset">Offset into the buffer to start at</param>
            <param name="length">Number of bytes to use out of the buffer</param>
            <returns>true if RequestRead() should be called automatically again</returns>
        </member>
        <member name="M:bedrock.net.ISocketEventListener.OnWrite(bedrock.net.BaseSocket,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Bytes were written to the socket.
            </summary>
            <param name="sock">The socket that was written to.</param>
            <param name="buf">The bytes that were written.</param>
            <param name="offset">Offset into the buffer to start at</param>
            <param name="length">Number of bytes to use out of the buffer</param>
        </member>
        <member name="M:bedrock.net.ISocketEventListener.OnInvalidCertificate(bedrock.net.BaseSocket,System.Security.Cryptography.X509Certificates.X509Certificate,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors)">
            <summary>
            An invalid peer certificate was sent during SSL/TLS neogtiation.
            </summary>
            <param name="sock">The socket that experienced the error</param>
            <param name="certificate">The bad certificate</param>
            <param name="chain">The chain of CAs for the cert</param>
            <param name="sslPolicyErrors">A bitfield for the erorrs in the certificate.</param>
            <returns>True if the cert should be accepted anyway.</returns>
        </member>
        <member name="F:bedrock.net.XEP124Socket.ENC">
            <summary>
            Text encoding.  Always UTF-8 for XMPP.
            </summary>
        </member>
        <member name="M:bedrock.net.XEP124Socket.#ctor(bedrock.net.ISocketEventListener)">
            <summary>
            Create an instance
            </summary>
            <param name="listener"></param>
        </member>
        <member name="M:bedrock.net.XEP124Socket.Accept(bedrock.net.Address,System.Int32)">
            <summary>
            Accept a socket.  Not implemented.
            </summary>
            <param name="addr"></param>
            <param name="backlog"></param>
        </member>
        <member name="M:bedrock.net.XEP124Socket.Close">
            <summary>
            Stop polling.
            </summary>
        </member>
        <member name="M:bedrock.net.XEP124Socket.Connect(bedrock.net.Address)">
            <summary>
            Start polling
            </summary>
            <param name="addr">Ignored in this case.  Set URL.</param>
        </member>
        <member name="M:bedrock.net.XEP124Socket.RequestAccept">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="M:bedrock.net.XEP124Socket.RequestRead">
            <summary>
            Start reading.
            </summary>
        </member>
        <member name="M:bedrock.net.XEP124Socket.StartTLS">
            <summary>
            Start TLS over this connection.  Not implemented.
            </summary>
        </member>
        <member name="M:bedrock.net.XEP124Socket.StartCompression">
            <summary>
            Start compression over this connection.  Not implemented.
            </summary>
        </member>
        <member name="M:bedrock.net.XEP124Socket.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Send bytes to the jabber server
            </summary>
            <param name="buf"></param>
            <param name="offset"></param>
            <param name="len"></param>
        </member>
        <member name="M:bedrock.net.XEP124Socket.Write(System.Xml.XmlElement)">
            <summary>
            Write an XML element to the socket.
            In this case, the element is queued, so that the write
            thread can pick it up.
            </summary>
            <param name="elem"></param>
        </member>
        <member name="M:bedrock.net.XEP124Socket.ToString">
            <summary>
            Descripton, including URL.
            </summary>
            <returns></returns>
        </member>
        <member name="P:bedrock.net.XEP124Socket.Lang">
            <summary>
            The xml:lang for all requests.  Defaults to the current culture's language tag.
            </summary>
        </member>
        <member name="P:bedrock.net.XEP124Socket.StartStream">
            <summary>
             Informs the socket that we are dealing with the start tag.
            </summary>
        </member>
        <member name="P:bedrock.net.XEP124Socket.NS">
            <summary>
             Gets or sets the NS used by the stream:stream tag.
            </summary>
        </member>
        <member name="P:bedrock.net.XEP124Socket.MaxPoll">
            <summary>
            Maximum time between polls, in seconds
            </summary>
        </member>
        <member name="P:bedrock.net.XEP124Socket.MinPoll">
            <summary>
            Minimum time between polls, in seconds
            </summary>
        </member>
        <member name="P:bedrock.net.XEP124Socket.URL">
            <summary>
            The URL to poll
            </summary>
        </member>
        <member name="P:bedrock.net.XEP124Socket.ProxyURI">
            <summary>
            The URI of the HTTP proxy.  Note: HTTPS connections through a proxy are not yet supported.
            </summary>
        </member>
        <member name="P:bedrock.net.XEP124Socket.ProxyCredentials">
            <summary>
            Username/password for the proxy.
            </summary>
        </member>
        <member name="P:bedrock.net.XEP124Socket.Connected">
            <summary>
            Are we connected?
            </summary>
        </member>
        <member name="P:bedrock.net.XEP124Socket.RemoteCertificate">
            <summary>
            The certificate from the server.
            </summary>
        </member>
        <member name="T:bedrock.net.Socks5Proxy">
            <summary>
            Proxy object for sockets that want to do SOCKS proxying.
            </summary>
        </member>
        <member name="T:bedrock.net.ProxySocket">
            <summary>
            Proxy object for sockets.
            </summary>
        </member>
        <member name="M:bedrock.net.ProxySocket.#ctor(bedrock.net.ISocketEventListener)">
            <summary>
            Wrap an existing socket event listener with a proxy.  Make SURE to set Socket after this.
            </summary>
            <param name="chain">Event listener to pass events through to.</param>
        </member>
        <member name="M:bedrock.net.ProxySocket.Accept(bedrock.net.Address,System.Int32)">
            <summary>
            Prepare to start accepting inbound requests.  Call RequestAccept() to start the async process.
            </summary>
            <param name="addr">Address to listen on</param>
            <param name="backlog">The Maximum length of the queue of pending connections</param>
        </member>
        <member name="M:bedrock.net.ProxySocket.Close">
            <summary>
            Close the socket.  This is NOT async.  .Net doesn't have async closes.
            But, it can be *called* async, particularly from GotData.
            Attempts to do a shutdown() first.
            </summary>
        </member>
        <member name="M:bedrock.net.ProxySocket.Connect(bedrock.net.Address)">
            <summary>
            Saves the address passed in, and really connects to m_host:m_port.
            </summary>
            <param name="addr"></param>
        </member>
        <member name="M:bedrock.net.ProxySocket.StartTLS">
            <summary>
            Start TLS processing on an open socket.
            </summary>
        </member>
        <member name="M:bedrock.net.ProxySocket.StartCompression">
            <summary>
            Start compression processing on an open socket.
            </summary>
        </member>
        <member name="M:bedrock.net.ProxySocket.RequestAccept">
            <summary>
            Start the flow of async accepts.  Flow will continue while
            Listener.OnAccept() returns true.  Otherwise, call RequestAccept() again
            to continue.
            </summary>
        </member>
        <member name="M:bedrock.net.ProxySocket.RequestRead">
            <summary>
            Start an async read from the socket.  Listener.OnRead() is eventually called
            when data arrives.
            </summary>
        </member>
        <member name="M:bedrock.net.ProxySocket.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Async write to the socket.  Listener.OnWrite will be called eventually
            when the data has been written.  A trimmed copy is made of the data, internally.
            </summary>
            <param name="buf">Buffer to output</param>
            <param name="offset">Offset into buffer</param>
            <param name="len">Number of bytes to output</param>
        </member>
        <member name="M:bedrock.net.ProxySocket.OnInit(bedrock.net.BaseSocket)">
             <summary>
            
             </summary>
             <param name="newSock"></param>
        </member>
        <member name="M:bedrock.net.ProxySocket.GetListener(bedrock.net.BaseSocket)">
             <summary>
            
             </summary>
             <param name="newSock"></param>
             <returns></returns>
        </member>
        <member name="M:bedrock.net.ProxySocket.OnAccept(bedrock.net.BaseSocket)">
             <summary>
            
             </summary>
             <param name="newsocket"></param>
             <returns></returns>
        </member>
        <member name="M:bedrock.net.ProxySocket.OnConnect(bedrock.net.BaseSocket)">
             <summary>
            
             </summary>
             <param name="sock"></param>
        </member>
        <member name="M:bedrock.net.ProxySocket.OnClose(bedrock.net.BaseSocket)">
             <summary>
            
             </summary>
             <param name="sock"></param>
        </member>
        <member name="M:bedrock.net.ProxySocket.OnError(bedrock.net.BaseSocket,System.Exception)">
             <summary>
            
             </summary>
             <param name="sock"></param>
             <param name="ex"></param>
        </member>
        <member name="M:bedrock.net.ProxySocket.OnRead(bedrock.net.BaseSocket,System.Byte[],System.Int32,System.Int32)">
             <summary>
            
             </summary>
             <param name="sock"></param>
             <param name="buf"></param>
             <param name="offset"></param>
             <param name="length"></param>
             <returns></returns>
        </member>
        <member name="M:bedrock.net.ProxySocket.OnWrite(bedrock.net.BaseSocket,System.Byte[],System.Int32,System.Int32)">
             <summary>
            
             </summary>
             <param name="sock"></param>
             <param name="buf"></param>
             <param name="offset"></param>
             <param name="length"></param>
        </member>
        <member name="M:bedrock.net.ProxySocket.OnInvalidCertificate(bedrock.net.BaseSocket,System.Security.Cryptography.X509Certificates.X509Certificate,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors)">
            <summary>
            An invalid peer certificate was sent during SSL/TLS neogtiation.
            </summary>
            <param name="sock">The socket that experienced the error</param>
            <param name="certificate">The bad certificate</param>
            <param name="chain">The chain of CAs for the cert</param>
            <param name="sslPolicyErrors">A bitfield for the erorrs in the certificate.</param>
            <returns>True if the cert should be accepted anyway.</returns>
        </member>
        <member name="M:bedrock.net.ProxySocket.ToString">
            <summary>
            String representation of the proxy socket.
            </summary>
            <returns></returns>
        </member>
        <member name="P:bedrock.net.ProxySocket.RemoteAddress">
            <summary>
            The address that the proxy should connect to.
            </summary>
        </member>
        <member name="P:bedrock.net.ProxySocket.Socket">
            <summary>
            The lower level socket
            </summary>
        </member>
        <member name="P:bedrock.net.ProxySocket.Host">
            <summary>
            the host running the proxy
            </summary>
        </member>
        <member name="P:bedrock.net.ProxySocket.Port">
            <summary>
            the port to talk to the proxy host on
            </summary>
        </member>
        <member name="P:bedrock.net.ProxySocket.SSL">
            <summary>
            Do SSL **after** connected through the proxy.
            </summary>
        </member>
        <member name="P:bedrock.net.ProxySocket.Username">
            <summary>
            the auth username for the proxy
            </summary>
        </member>
        <member name="P:bedrock.net.ProxySocket.Password">
            <summary>
            the auth password for the proxy
            </summary>
        </member>
        <member name="P:bedrock.net.ProxySocket.Connected">
            <summary>
            Are we currently connected?
            </summary>
        </member>
        <member name="M:bedrock.net.Socks5Proxy.#ctor(bedrock.net.ISocketEventListener)">
            <summary>
            Wrap an existing socket event listener with a Socks5 proxy.  Make SURE to set Socket after this.
            </summary>
            <param name="chain">Event listener to pass events through to.</param>
        </member>
        <member name="M:bedrock.net.Socks5Proxy.Connect(bedrock.net.Address)">
            <summary>
            Saves the address passed in, and really connects to ProxyHost:ProxyPort to begin SOCKS5 handshake.
            </summary>
            <param name="addr"></param>
        </member>
        <member name="M:bedrock.net.Socks5Proxy.OnConnect(bedrock.net.BaseSocket)">
            <summary>
            overridden OnConnect to start off Socks5 protocol.
            </summary>
            <param name="sock"></param>
        </member>
        <member name="M:bedrock.net.Socks5Proxy.OnRead(bedrock.net.BaseSocket,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Overridden OnRead to handle 4 Socks5 states...
            </summary>
            <param name="sock"></param>
            <param name="buf"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:bedrock.net.Socks5Proxy.OnWrite(bedrock.net.BaseSocket,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Overridden OnWrite to ensure that the base only gets called when in running state.
            </summary>
            <param name="sock"></param>
            <param name="buf"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="T:bedrock.net.ShttpProxy">
            <summary>
            Proxy object for sockets that want to do SHTTP proxying.
            </summary>
        </member>
        <member name="M:bedrock.net.ShttpProxy.#ctor(bedrock.net.ISocketEventListener)">
            <summary>
            Wrap an existing socket event listener with a ShttpProxy proxy.  Make SURE to set Socket after this.
            </summary>
            <param name="chain">Event listener to pass events through to.</param>
        </member>
        <member name="M:bedrock.net.ShttpProxy.Connect(bedrock.net.Address)">
            <summary>
            Remember that we're in the connecting state, let base connect to proxy, resumes in OnConnect.
            </summary>
            <param name="addr"></param>
        </member>
        <member name="M:bedrock.net.ShttpProxy.OnConnect(bedrock.net.BaseSocket)">
            <summary>
            overridden OnConnect to start off SHTTP protocol.
            </summary>
            <param name="sock"></param>
        </member>
        <member name="M:bedrock.net.ShttpProxy.OnRead(bedrock.net.BaseSocket,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Overridden OnRead to handle 4 Socks5 states...
            </summary>
            <param name="sock"></param>
            <param name="buf"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:bedrock.net.ShttpProxy.OnWrite(bedrock.net.BaseSocket,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Overridden OnWrite to ensure that the base only gets called when in running state.
            </summary>
            <param name="sock"></param>
            <param name="buf"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="T:stringprep.XmppNode">
            <summary>
            A stringprep profile for draft-ietf-xmpp-nodeprep-02, for Jabber nodes (the "user" part).
            </summary>
        </member>
        <member name="M:stringprep.XmppNode.#ctor">
            <summary>
            Create a new XmppNode profile instance.
            </summary>
        </member>
        <member name="T:stringprep.unicode.DecomposeData">
            <summary>
            Decomposition data for NFKC.
            </summary>
        </member>
        <member name="F:stringprep.unicode.DecomposeData.Offsets">
            <summary>
            Offset into the Expansion string for each decomposable character.
            One way to make this faster might be to have this not be sparse, so that the lookup
            could be direct rather than a binary search.  That would add several hundred K to the
            library size, though, or time at startup to initialize an array from this.
            </summary>
        </member>
        <member name="F:stringprep.unicode.DecomposeData.Expansion">
            <summary>
            How to expand characters.  Since multiple input characters
            output the same string, this table is compressed to only
            have one copy of each, and the Offsets table
            gives offsets into this for each input.
            </summary>
        </member>
        <member name="T:jabber.protocol.x.XDataType">
            <summary>
            XData types.
            </summary>
        </member>
        <member name="F:jabber.protocol.x.XDataType.form">
            <summary>
            This packet contains a form to fill out. Display it to the user (if your program can).
            </summary>
        </member>
        <member name="F:jabber.protocol.x.XDataType.submit">
            <summary>
            The form is filled out, and this is the data that is being returned from the form.
            </summary>
        </member>
        <member name="F:jabber.protocol.x.XDataType.result">
            <summary>
            Data results being returned from a search, or some other query.
            </summary>
        </member>
        <member name="F:jabber.protocol.x.XDataType.cancel">
            <summary>
            A form was cancelled.
            </summary>
        </member>
        <member name="T:jabber.protocol.x.FormTypeComparer">
            <summary>
            Compare two x:data forms by form type.
            </summary>
        </member>
        <member name="M:jabber.protocol.x.FormTypeComparer.Compare(jabber.protocol.x.Data,jabber.protocol.x.Data)">
            <summary>
            Compare two x:data forms by form type
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="T:jabber.protocol.x.Data">
            <summary>
            jabber:x:data support, as in http://www.xmpp.org/extensions/xep-0004.html.
            </summary>
        </member>
        <member name="T:jabber.protocol.Element">
            <summary>
            An XmlElement with type-safe accessors.  This class is not much use by itself,
            but provides a number of utility functions for its descendants.
            </summary>
        </member>
        <member name="F:jabber.protocol.Element.ENCODING">
            <summary>
            UTF-8 encoding used throughout.
            </summary>
        </member>
        <member name="F:jabber.protocol.Element.s_RemoveNS">
            <summary>
            Fix up bad namespaces that don't need to be sent on XML streams.
            jabber:client and jabber:component:accept are removed from the root element,
            and empty namespace declarations are removed throughout.
            </summary>
        </member>
        <member name="M:jabber.protocol.Element.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.Element.#ctor(System.String,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="localName"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.Element.#ctor(System.String,System.String,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="localName"></param>
             <param name="namespaceURI"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.Element.GetChildElement``1">
            <summary>
            Returns the first child element with the given type.
            
            You might expect this to be slower than this["name", "uri"], but it's 
            probably actually faster, since that code has to check several different
            things, and this code can just do a type comparison.
            </summary>
            <typeparam name="T">The type of child to search for</typeparam>
            <returns>The first child with the given type, or null if none found</returns>
        </member>
        <member name="M:jabber.protocol.Element.AddChild(System.Xml.XmlElement)">
            <summary>
            Add a child element.  The element can be from a different document.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:jabber.protocol.Element.GetElementsByTagName(System.String,System.String)">
            <summary>
            Returns an XmlNodeList containing a list of child elements that match the specified localname and namespace URI.
            </summary>
            <param name="localName"></param>
            <param name="namespaceURI"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.Element.GetElementsByTagName(System.String)">
            <summary>
            Returns an XmlNodeList containing a list of child elements that match the specified localname.
            </summary>
            <param name="localName"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.Element.GetElements``1">
            <summary>
            Get a list of child elements that have the specified type.
            </summary>
            <typeparam name="T">The type of element to search for</typeparam>
            <returns>A typed element list</returns>
        </member>
        <member name="M:jabber.protocol.Element.GetElem``1">
            <summary>
            Gett he text contents of the first sub-element with the specified type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.Element.GetElem(System.String)">
            <summary>
            Get the text contents of a sub-element.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.Element.SetElem``1(System.String)">
            <summary>
            Sets the text contents of a sub-element with a specified type.
            Creates the element if it doesn't exist.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.Element.SetElem(System.String,System.String)">
            <summary>
            Sets the text contents of a sub-element.
            Note: Do not use this if you want the sub-element to have a type that is not XmlElement.
            Instead use <see cref="M:jabber.protocol.Element.SetElem(System.String,System.String,System.Type)"/>
            </summary>
            <param name="name">The element tag.</param>
            <param name="value">The inner text of the element.</param>
        </member>
        <member name="M:jabber.protocol.Element.SetElem(System.String,System.String,System.Type)">
            <summary>
            Sets the text contents of a sub-element.
            </summary>
            <param name="name">The element tag.</param>
            <param name="value">The inner text of the element.</param>
            <param name="typeToCreate">If the element doesn't exist, create it with this type.  If null, then just use an XmlElement.</param>
        </member>
        <member name="M:jabber.protocol.Element.CreateChildElement``1">
            <summary>
            Create an element that is a child of this element, of the specified type.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.Element.GetOrCreateElement``1">
            <summary>
            If a child element exists with the given type, return it.  Otherwise,
            gin up a new instance of the given type, add it as a child, 
            and return the result.
            
            This should not have the performance impact of GetOrCreateElement.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.Element.GetOrCreateElement(System.String,System.String,System.Type)">
            <summary>
            If the named element exists as a child, return it.  Otherwise, gin up
            a new instance of the given class (which must be a subclass of XmlElement)
            add it as a child, and return the result.  Will often be paired with
            ReplaceChild as the setter.
            </summary>
            <remarks>
            This seems kind of around-the-barn.  Wish there was an easier way to do this,
            rather than having to get the constructor, and whatnot.  Hopefully it won't
            be called all that often, so the speed issue won't be too bad.
            </remarks>
            <param name="name"></param>
            <param name="xmlns">Namespace URI.  Null to use parent's.</param>
            <param name="typeToCreate">If the element doesn't exist, create it with this type.  If null, then just use an XmlElement.</param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.Element.ReplaceChild``1(``0)">
            <summary>
            Replaces the first element that has the specified type.
            </summary>
            <typeparam name="T">The type of sub-element to find</typeparam>
            <param name="elem">The element to replace; if this is null, the old element is just deleted</param>
            <returns>The replaced element</returns>
        </member>
        <member name="M:jabber.protocol.Element.ReplaceChild(System.Xml.XmlElement)">
            <summary>
            Replaces the first element that has the same name
            with the passed in element.
            </summary>
            <param name="elem">The new element</param>
            <returns>The replaced element</returns>
        </member>
        <member name="M:jabber.protocol.Element.RemoveElem``1">
            <summary>
            Remove a child element of the specified type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.Element.RemoveElem(System.String)">
            <summary>
            Remove a child element
            </summary>
            <param name="name"></param>
            <returns>The old element, or null if it didn't exist.</returns>
        </member>
        <member name="M:jabber.protocol.Element.RemoveElems``1">
            <summary>
            Remove each of the child elements with the specified type.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:jabber.protocol.Element.RemoveElems(System.String)">
            <summary>
            Removes all of the matching elements from this element.
            </summary>
            <param name="name">Element local name</param>
        </member>
        <member name="M:jabber.protocol.Element.RemoveElems(System.String,System.String)">
            <summary>
            Removes all of the matching elements from this element.
            </summary>
            <param name="name">Element local name</param>
            <param name="namespaceURI">Element namespace URI.</param>
        </member>
        <member name="M:jabber.protocol.Element.GetAttr(System.String)">
            <summary>
            I think GetAttribute should return null if the attribute is not found.
            Use carefully, when translating to external semantics.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:jabber.protocol.Element.SetAttr(System.String,System.String)">
            <summary>
            I think calling SetAttr with null or "" should remove the attribute.
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:jabber.protocol.Element.GetEnumAttr``1(System.String)">
            <summary>
            Get the value of an attribute, as a value in the given Enum type.
            The specified enum should have a member with value -1, which will
            be returned if the attribute doesn't exist or is in the wrong format.
            </summary>
            <typeparam name="T">The enum type</typeparam>
            <param name="name">The attribute name</param>
            <returns>The enum value</returns>
        </member>
        <member name="M:jabber.protocol.Element.GetEnumAttr(System.String,System.Type)">
            <summary>
            Get the value of an attribute, as a value in the given Enum type.
            </summary>
            <param name="name"></param>
            <param name="enumType"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.Element.SetEnumAttr(System.String,System.Object)">
            <summary>
            Set the value of an attribute, with the value being a enum instance.
            The enum in question should have an entry with int value -1, which
            corresponds to no attribute.
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:jabber.protocol.Element.GetIntAttr(System.String)">
            <summary>
            Get the value of a given attribute, as an integer.  Returns -1 for
            most errors.   TODO: should this throw exceptions?
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.Element.SetIntAttr(System.String,System.Int32)">
            <summary>
            Set the value of a given attribute, as an integer.  Use -1
            to remove the attribute.
            </summary>
            <param name="name">The attribute name</param>
            <param name="val">The integer to set</param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.Element.GetLongAttr(System.String)">
            <summary>
            Get the value of a given attribute, as an unsigned long.  Returns -1L for
            most errors.   TODO: should this throw exceptions?
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.Element.SetLongAttr(System.String,System.Int64)">
            <summary>
            Set the value of a given attribute, as a long  Use -1L
            to remove the attribute.
            </summary>
            <param name="name">The attribute name</param>
            <param name="val">The integer to set</param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.Element.GetDateTimeAttr(System.String)">
            <summary>
            Get an attribute cast to DateTime, using the DateTime profile
            of XEP-82.
            </summary>
            <param name="name"></param>
            <returns>DateTime.MinValue if attribute not found.</returns>
            <exception cref="T:System.FormatException">Invalid format</exception>
        </member>
        <member name="M:jabber.protocol.Element.SetDateTimeAttr(System.String,System.DateTime)">
            <summary>
            Set with DateTime.MinValue to remove the attribute
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:jabber.protocol.Element.HexString(System.Byte[])">
            <summary>
            Convert the given array of bytes into a string, having two characters
            for each byte, corresponding to the hex representation of that byte.
            </summary>
            <param name="buf"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.Element.HexString(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Convert the given array of bytes into a string, having two characters
            for each byte, corresponding to the hex representation of that byte.
            </summary>
            <param name="buf">The byte buffer</param>
            <param name="offset">The offset into the buffer for the start</param>
            <param name="length">The number of bytes to read, starting at the offset.</param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.Element.ShaHash(System.String,System.String)">
            <summary>
            Compute the SHA1 hash of the id and secret concatenated together.
            </summary>
            <param name="id">UTF8-encoded id</param>
            <param name="secret">UTF8-encoded secret</param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.Element.ZeroK(System.String,System.String,System.Int32)">
            <summary>
            Compute a 0K hash
            </summary>
            <param name="password">The secret to hash in</param>
            <param name="token">The token to permute the hash</param>
            <param name="sequence">Number of times to hash</param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.Element.JabberDate(System.String)">
            <summary>
            Return a DateTime version of the given Jabber date.  Example date: 20020504T20:39:42
            </summary>
            <param name="dt">The pseudo-ISO-8601 formatted date (no milliseconds)</param>
            <returns>A (usually UTC) DateTime</returns>
        </member>
        <member name="M:jabber.protocol.Element.JabberDate(System.DateTime)">
            <summary>
            Get a jabber-formated date for the DateTime.   Example date: 20020504T20:39:42
            </summary>
            <param name="dt">The (usually UTC) DateTime to format</param>
            <returns>The pseudo-ISO-8601 formatted date (no milliseconds)</returns>
        </member>
        <member name="M:jabber.protocol.Element.DateTimeProfile(System.String)">
            <summary>
            XEP-82 Date/Time profile: http://www.xmpp.org/extensions/xep-0082.html#sect-id2601974
            CCYY-MM-DDThh:mm:ss[.sss]TZD
            1969-07-21T02:56:15Z
            </summary>
            <param name="dt"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.Element.DateTimeProfile(System.DateTime)">
            <summary>
            XEP-82 Date/Time profile: http://www.xmpp.org/extensions/xep-0082.html#sect-id2601974
            CCYY-MM-DDThh:mm:ss[.sss]TZD
            1969-07-21T02:56:15Z
            </summary>
            <param name="dt"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.Element.ToString">
            <summary>
            The XML for the packet.
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.Element.StartTag">
            <summary>
            Return just the start tag for the element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.Element.GetFirstChildElement">
            <summary>
            Get the first child element of this element.
            </summary>
            <returns>null if none found.</returns>
        </member>
        <member name="M:jabber.protocol.Element.CloneNode(System.Boolean)">
            <summary>
            Clone this node, preserving type information.
            </summary>
            <param name="deep">Clone child nodes too?</param>
            <returns>Cloned node, with type info intact</returns>
        </member>
        <member name="M:jabber.protocol.Element.CloneNode(System.Boolean,System.Xml.XmlDocument)">
            <summary>
            Clone this node into the target document, preserving type information.
            </summary>
            <param name="deep"></param>
            <param name="doc"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.Element.AddTypes(System.Xml.XmlElement,jabber.protocol.ElementFactory)">
            <summary>
            Convert the given source element to typed subclasses of Element, according
            to the given ElementFactory.
            </summary>
            <param name="source"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="F:jabber.protocol.Element.s_counter">
            <summary>
            System-wide one-up counter, for numbering packets.
            </summary>
        </member>
        <member name="M:jabber.protocol.Element.ResetID">
            <summary>
            Reset the packet ID counter.  This is ONLY to be used for test cases!   No locking!
            </summary>
        </member>
        <member name="M:jabber.protocol.Element.NextID">
            <summary>
            Increment the ID counter, and get the new value.
            </summary>
            <returns>The new ID.</returns>
        </member>
        <member name="P:jabber.protocol.Element.Lang">
            <summary>
            The xml:lang of this element.
            </summary>
        </member>
        <member name="P:jabber.protocol.Element.OuterXml">
            <summary>
            Get a string representation of this element and its children, with the default
            namespace stripped off if and only if it is jabber:client or jabber:component:accept.
            </summary>
        </member>
        <member name="P:jabber.protocol.Element.OriginalOuterXml">
            <summary>
            The implementation of OuterXml from XmlElement, without removing the jabber:client
            namespace.  Needed for Stream.
            </summary>
        </member>
        <member name="F:jabber.protocol.x.Data.FORM_TYPE">
            <summary>
            XEP-68 field that describes the type of the form.
            </summary>
        </member>
        <member name="M:jabber.protocol.x.Data.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.x.Data.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.x.Data.GetFields">
            <summary>
            List of form fields
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.x.Data.AddField">
            <summary>
            Add a form field
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.x.Data.AddField(System.String)">
            <summary>
            Add a form field, with just the field name.
            </summary>
            <param name="var">Variable name</param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.x.Data.AddField(System.String,jabber.protocol.x.FieldType,System.String,System.String,System.String)">
            <summary>
            Add a form field
            </summary>
            <param name="var">Variable name</param>
            <param name="typ">Field Type</param>
            <param name="label">Field label</param>
            <param name="val">Field value</param>
            <param name="desc">Description</param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.x.Data.GetField(System.String)">
            <summary>
            Get a field with the specified variable name.
            </summary>
            <param name="var"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.x.Data.RemoveField(System.String)">
            <summary>
            Remove the first field with the var specified
            </summary>
            <param name="var"></param>
            <returns></returns>
        </member>
        <member name="P:jabber.protocol.x.Data.Instructions">
            <summary>
            Form instructions.
            </summary>
        </member>
        <member name="P:jabber.protocol.x.Data.Title">
            <summary>
            The form title, for display at the top of a window.
            </summary>
        </member>
        <member name="P:jabber.protocol.x.Data.Type">
            <summary>
            Type of this XData.
            </summary>
        </member>
        <member name="P:jabber.protocol.x.Data.FormType">
            <summary>
            The XEP-68 type of this form.
            </summary>
        </member>
        <member name="T:jabber.protocol.x.FieldType">
            <summary>
            Types of fields.  This enum doesn't exactly match the XEP,
            since most of the field types aren't valid identifiers in C#.
            </summary>
        </member>
        <member name="F:jabber.protocol.x.FieldType.text_single">
            <summary>
            Single-line text, and default.
            </summary>
        </member>
        <member name="F:jabber.protocol.x.FieldType.text_private">
            <summary>
            Password-style single line text.  Text obscured by *'s.
            </summary>
        </member>
        <member name="F:jabber.protocol.x.FieldType.text_multi">
            <summary>
            Multi-line text
            </summary>
        </member>
        <member name="F:jabber.protocol.x.FieldType.list_multi">
            <summary>
            Multi-select list
            </summary>
        </member>
        <member name="F:jabber.protocol.x.FieldType.list_single">
            <summary>
            Single-select list
            </summary>
        </member>
        <member name="F:jabber.protocol.x.FieldType.boolean">
            <summary>
            Checkbox
            </summary>
        </member>
        <member name="F:jabber.protocol.x.FieldType.Fixed">
            <summary>
            Fixed text.
            </summary>
        </member>
        <member name="F:jabber.protocol.x.FieldType.hidden">
            <summary>
            Hidden field.  Value is returned to sender as sent.
            </summary>
        </member>
        <member name="F:jabber.protocol.x.FieldType.jid_single">
            <summary>
            Jabber ID.
            </summary>
        </member>
        <member name="F:jabber.protocol.x.FieldType.jid_multi">
            <summary>
            A list of jabber ID's.
            </summary>
        </member>
        <member name="T:jabber.protocol.x.Field">
            <summary>
            Form field.
            </summary>
        </member>
        <member name="M:jabber.protocol.x.Field.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.x.Field.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.x.Field.IsValSet(System.String)">
            <summary>
            Is the given value in Vals?
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.x.Field.AddValue(System.String)">
            <summary>
            Add a value to a multi-value field.
            </summary>
            <param name="newvalue"></param>
        </member>
        <member name="M:jabber.protocol.x.Field.GetOptions">
            <summary>
            List of field options
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.x.Field.AddOption">
            <summary>
            Add a field option
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.x.Field.AddOption(System.String)">
            <summary>
            Add a field option, with a value
            </summary>
            <param name="val">Value of the option</param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.x.Field.AddOption(System.String,System.String)">
            <summary>
            Add a field option, with a value
            </summary>
            <param name="label">Label for the option</param>
            <param name="val">Value of the option</param>
            <returns></returns>
        </member>
        <member name="P:jabber.protocol.x.Field.Type">
            <summary>
            Field type.
            </summary>
        </member>
        <member name="P:jabber.protocol.x.Field.Label">
            <summary>
            Field label.  Will return Var if no label is found.
            </summary>
        </member>
        <member name="P:jabber.protocol.x.Field.Var">
            <summary>
            Field variable name.
            </summary>
        </member>
        <member name="P:jabber.protocol.x.Field.IsRequired">
            <summary>
            Is this a required field?
            </summary>
        </member>
        <member name="P:jabber.protocol.x.Field.Val">
            <summary>
            The field value.
            </summary>
        </member>
        <member name="P:jabber.protocol.x.Field.BoolVal">
            <summary>
            Value for type='boolean' fields
            </summary>
        </member>
        <member name="P:jabber.protocol.x.Field.Vals">
            <summary>
            Values for type='list-multi' fields
            </summary>
        </member>
        <member name="P:jabber.protocol.x.Field.Desc">
            <summary>
            The field description
            </summary>
        </member>
        <member name="T:jabber.protocol.x.Option">
            <summary>
            Field options, for list-single and list-multi type fields.
            </summary>
        </member>
        <member name="M:jabber.protocol.x.Option.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.x.Option.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.x.Option.ToString">
            <summary>
            Return the label for this option, so that a ComboBox.ObjectCollection can manage these directly.
            </summary>
            <returns></returns>
        </member>
        <member name="P:jabber.protocol.x.Option.Label">
            <summary>
            Option label
            </summary>
        </member>
        <member name="P:jabber.protocol.x.Option.Val">
            <summary>
            The option value.
            </summary>
        </member>
        <member name="T:jabber.protocol.accept.Handshake">
            <summary>
            The handshake tag, including digest calculation.  Call SetAuth() to calculate
            the SHA1 hash.
            </summary>
        </member>
        <member name="M:jabber.protocol.accept.Handshake.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.accept.Handshake.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.accept.Handshake.SetAuth(System.String,System.String)">
            <summary>
            Set the auth information for this handshake tag,
            performing the digest operation.
            </summary>
            <param name="secret"></param>
            <param name="streamID"></param>
        </member>
        <member name="P:jabber.protocol.accept.Handshake.Digest">
            <summary>
            The digest.
            </summary>
        </member>
        <member name="T:jabber.connection.StreamComponent">
            <summary>
            Manages the XmppStream as a component.
            </summary>
        </member>
        <member name="M:jabber.connection.StreamComponent.GetStreamFromHost(System.ComponentModel.Design.IDesignerHost)">
            <summary>
            Finds the first component that subclasses XmppStream in Visual Studio
            during runtime.
            </summary>
            <param name="host">
            Calls GetService(typeof(IDesignerHost)) on your control to get this.
            </param>
            <returns>Null if none found</returns>
        </member>
        <member name="M:jabber.connection.StreamComponent.GetComponentFromHost(System.ComponentModel.Design.IDesignerHost,System.Type)">
            <summary>
            Finds the first component that subclasses the given type at runtime.
            </summary>
            <param name="host">Call GetService(typeof(IDesignerHost)) on your control to get this.</param>
            <param name="type">The type to search for.</param>
            <returns>Null if none found</returns>
        </member>
        <member name="F:jabber.connection.StreamComponent.m_stream">
            <summary>
            Retrieves the XmppStream for this control.
            Set at design time when a subclass control is dragged onto a form.
            </summary>
        </member>
        <member name="M:jabber.connection.StreamComponent.Write(System.Xml.XmlElement)">
            <summary>
            Write the specified stanza to the stream.
            If the from address hasn't been set, and an OverrideFrom has been set,
            the from address will be set to the value of OverrideFrom.
            </summary>
            <param name="elem"></param>
        </member>
        <member name="M:jabber.connection.StreamComponent.BeginIQ(jabber.protocol.client.IQ,jabber.connection.IqCB,System.Object)">
            <summary>
             Does an asynchronous IQ call.
             If the from address hasn't been set, and an OverrideFrom has been set,
             the from address will be set to the value of OverrideFrom.
            </summary>
            <param name="iq">IQ packet to send.</param>
            <param name="cb">Callback to execute when the result comes back.</param>
            <param name="cbArg">Arguments to pass to the callback.</param>
        </member>
        <member name="E:jabber.connection.StreamComponent.OnStreamChanged">
            <summary>
            Informs the client that the XmppStream was changed.
            Often at design time, the object will be this StreamComponent.
            </summary>
        </member>
        <member name="P:jabber.connection.StreamComponent.Stream">
            <summary>
            Gets and sets the JabberClient or JabberService XMPP stream value.
            </summary>
        </member>
        <member name="P:jabber.connection.StreamComponent.OverrideFrom">
            <summary>
            Override the from address that will be stamped on outbound packets.
            Unless your server implemets XEP-193, you shouldn't use this for 
            client connections.
            </summary>
        </member>
        <member name="T:jabber.connection.PubSubManager">
            <summary>
            Manages a set of publish-subscribe (<a href="http://www.xmpp.org/extensions/xep-0060.html">XEP-60</a>) subscriptions.
            The goal is to have a list of jid/node combinations, each of which is a singleton.
            <example>
            PubSubNode node = ps.GetNode("infobroker.corp.jabber.com", "test/foo", 10);
            node.AddItemAddCallback(new ItemCB(node_OnItemAdd));
            node.OnItemRemove += new ItemCB(node_OnItemRemove);
            node.OnError += new bedrock.ExceptionHandler(node_OnError);
            node.AutomatedSubscribe();
            </example>
            </summary>
        </member>
        <member name="F:jabber.connection.PubSubManager.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:jabber.connection.PubSubManager.#ctor">
            <summary>
            Creates a manager.
            </summary>
        </member>
        <member name="M:jabber.connection.PubSubManager.#ctor(System.ComponentModel.IContainer)">
            <summary>
            Creates a manager in a container.
            </summary>
            <param name="container">Parent container.</param>
        </member>
        <member name="M:jabber.connection.PubSubManager.Dispose(System.Boolean)">
            <summary>
            Performs tasks associated with freeing, releasing, or resetting resources.
            </summary>
            <param name="disposing">True if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:jabber.connection.PubSubManager.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="M:jabber.connection.PubSubManager.AddNodeHandler(System.String,jabber.connection.ItemCB,jabber.connection.ItemCB,System.Int32)">
            <summary>
            Add a handler for all inbound notifications with the given node name.
            This is handy for PEP implicit subscriptions.
            </summary>
            <param name="node">PEP node URI</param>
            <param name="addCB">Callback when items added</param>
            <param name="removeCB">Callbacks when items removed</param>
            <param name="maxNumber">Maximum number of items to store per node in this namespace</param>
        </member>
        <member name="M:jabber.connection.PubSubManager.RemoveNodeHandler(System.String,jabber.connection.ItemCB)">
            <summary>
            Remove an existing callback.
            </summary>
            <param name="node"></param>
            <param name="cb"></param>
        </member>
        <member name="M:jabber.connection.PubSubManager.GetNode(jabber.JID,System.String,System.Int32)">
            <summary>
            Subscribes to a publish-subscribe node.
            </summary>
            <param name="service">Component that handles PubSub requests.</param>
            <param name="node">The node on the component that the client wants to interact with.</param>
            <param name="maxItems">Maximum number of items to retain.  First one to call Subscribe gets their value, for now.</param>
            <returns>
            The existing node will be returned if there is already a subscription.
            If the node does not exist, the PubSubNode object will be returned
            in a subscribing state.
            </returns>
        </member>
        <member name="M:jabber.connection.PubSubManager.RemoveNode(jabber.JID,System.String,bedrock.ExceptionHandler)">
            <summary>
             Removes the publish-subscribe node from the manager and sends a delete
             node to the XMPP server.
            </summary>
             <param name="service">
             Component that handles PubSub requests.
             </param>
             <param name="node">
             The node on the component that the client wants to interact with.
             </param>
             <param name="errorHandler">
             Callback for any errors with the publish-subscribe node deletion.
             </param>
        </member>
        <member name="M:jabber.connection.PubSubManager.GetDefaults(jabber.JID,jabber.connection.IqCB,System.Object)">
            <summary>
            Get the default configuration of the node.
            </summary>
            <param name="service">JID of the pub/sub service</param>
            <param name="callback">Callback.  Must not be null.  Will not be called back 
            if there is an error, but instead OnError will be called.</param>
            <param name="state">State information to be passed back to callback</param>
        </member>
        <member name="E:jabber.connection.PubSubManager.OnError">
            <summary>
            Notifies the client that an error occurred.  If this is set, it will be copied to
            each node that is created by the manager.
            </summary>
        </member>
        <member name="T:jabber.connection.ItemCB">
            <summary>
            Notifies the client about a publish-subscribe item.
            </summary>
        </member>
        <member name="T:jabber.connection.ItemList">
            <summary>
            Manages a list of items with a maximum size.  Only one item with a given ID will be in the
            list at a given time.
            </summary>
        </member>
        <member name="M:jabber.connection.ItemList.#ctor(jabber.connection.PubSubNode,System.Int32)">
            <summary>
            Creates an item list, which will have at most some number of items.
            </summary>
            <param name="node">The node to which this item list applies.</param>
            <param name="maxItems">Maximum size of the list.  Delete notifications will be sent if this size is exceeded.</param>
        </member>
        <member name="M:jabber.connection.ItemList.RemoveAt(System.Int32)">
            <summary>
            Makes sure that the underlying ID index is in sync
            when an item is removed.
            </summary>
            <param name="index">Index of PubSubItem to remove.</param>
        </member>
        <member name="M:jabber.connection.ItemList.Add(System.Object)">
            <summary>
            Adds to the end of the list, replacing any item with the same ID,
            or bumping the oldest item if the list is full.
            </summary>
            <param name="value">PubSubItem to add to the list.</param>
            <returns>Index where the PubSubItem was inserted.</returns>
        </member>
        <member name="M:jabber.connection.ItemList.RemoveId(System.String)">
            <summary>
            Removes the item with the given ID.
            No exception is thrown if no item is found with that ID.
            </summary>
            <param name="id">ID of the item to remove</param>
        </member>
        <member name="P:jabber.connection.ItemList.Item(System.String)">
            <summary>
            Gets or sets the contents of the specified item.
            </summary>
            <param name="id">Id of the PubSubItem.</param>
            <returns>XmlElement representing the contents of the PubSubItem.</returns>
        </member>
        <member name="T:jabber.connection.Op">
            <summary>
            Contains the different possible operations on a publish-subscribe node.
            </summary>
        </member>
        <member name="F:jabber.connection.Op.CREATE">
            <summary>
            Creates a node
            </summary>
        </member>
        <member name="F:jabber.connection.Op.SUBSCRIBE">
            <summary>
            Subscribes to a node
            </summary>
        </member>
        <member name="F:jabber.connection.Op.ITEMS">
            <summary>
            Gets the current items in the node
            </summary>
        </member>
        <member name="F:jabber.connection.Op.DELETE">
            <summary>
            Deletes a node
            </summary>
        </member>
        <member name="F:jabber.connection.Op.DELETE_ITEM">
            <summary>
            Deletes an item from the node
            </summary>
        </member>
        <member name="F:jabber.connection.Op.PUBLISH_ITEM">
            <summary>
            Publishes an item to a node
            </summary>
        </member>
        <member name="F:jabber.connection.Op.CONFIGURE">
            <summary>
            Configure a node
            </summary>
        </member>
        <member name="F:jabber.connection.Op.PURGE">
            <summary>
            Purge all items from a node.
            </summary>
        </member>
        <member name="F:jabber.connection.Op.DEFAULTS">
            <summary>
            Configuration defaults
            </summary>
        </member>
        <member name="T:jabber.connection.PubSubException">
            <summary>
            Informs the client that a publish-subscribe error occurred.
            </summary>
        </member>
        <member name="F:jabber.connection.PubSubException.Protocol">
            <summary>
            Contains the stanza that caused the error.
            </summary>
        </member>
        <member name="F:jabber.connection.PubSubException.Operation">
            <summary>
            Contains the operation that failed.
            </summary>
        </member>
        <member name="M:jabber.connection.PubSubException.#ctor(jabber.connection.Op,System.String,System.Xml.XmlElement)">
            <summary>
            Creates a new publish-subscribe exception.
            </summary>
            <param name="op">The operation that failed.</param>
            <param name="error">A description of the error.</param>
            <param name="elem">The stanza that caused the error.</param>
        </member>
        <member name="P:jabber.connection.PubSubException.Message">
            <summary>
            Gets the error string.
            </summary>
        </member>
        <member name="T:jabber.connection.NodeHandler">
            <summary>
            Some event has occurred on a PubSub node.
            </summary>
            <param name="node"></param>
        </member>
        <member name="T:jabber.connection.PubSubNode">
            <summary>
            Manages a node to be subscribed to.  Will keep a maximum number of items.
            </summary>
        </member>
        <member name="M:jabber.connection.PubSubNode.#ctor(jabber.connection.XmppStream,jabber.JID,System.String,System.Int32)">
            <summary>
            Create a Node.  Next, call Create and/or Subscribe.
            </summary>
            <param name="stream"></param>
            <param name="jid"></param>
            <param name="node"></param>
            <param name="maxItems"></param>
        </member>
        <member name="M:jabber.connection.PubSubNode.AddItemAddCallback(jabber.connection.ItemCB)">
            <summary>
            Adds a handler for the OnItemAdd event, and calls the handler for any existing
            items.  To prevent races, use this rather than .OnItemAdd +=.
            </summary>
            <param name="callback">Callback to call with every item.</param>
        </member>
        <member name="M:jabber.connection.PubSubNode.AutomatedSubscribe">
             <summary>
             Creates the node then subscribes. If the creation succeeded, or if the node
             already exists, retrieve the items for the node.
            
             This is the typical starting point.  Please make sure to register callbacks before calling
             this function.
             </summary>
        </member>
        <member name="M:jabber.connection.PubSubNode.Create">
            <summary>
            Creates the node with default configuration.
            </summary>
        </member>
        <member name="M:jabber.connection.PubSubNode.Create(jabber.protocol.x.Data)">
            <summary>
            Creates the node using the specified configuration form.
            </summary>
            <param name="config">Null for the default configuration</param>
        </member>
        <member name="M:jabber.connection.PubSubNode.Subscribe">
            <summary>
            Sends a subscription request.
            Items request will be sent automatically on successful subscribe.
            </summary>
        </member>
        <member name="M:jabber.connection.PubSubNode.GetItems">
            <summary>
            Gets the items from the node on the XMPP server.
            </summary>
        </member>
        <member name="M:jabber.connection.PubSubNode.ItemAdded(jabber.protocol.iq.PubSubItem)">
            <summary>
            Notifies the client that an item has been add to this PubSubNode.
            </summary>
            <param name="item">Item that was added.</param>
        </member>
        <member name="M:jabber.connection.PubSubNode.ItemRemoved(jabber.protocol.iq.PubSubItem)">
            <summary>
            Notifies the client that an item has been removed from this PubSubNode.
            </summary>
            <param name="item">Item that was removed.</param>
        </member>
        <member name="M:jabber.connection.PubSubNode.Unsubscribe">
            <summary>
            Unsubscribes from the node.
            </summary>
        </member>
        <member name="M:jabber.connection.PubSubNode.Delete">
            <summary>
            Deletes the node from the XMPP server.
            </summary>
        </member>
        <member name="M:jabber.connection.PubSubNode.DeleteItem(System.String)">
            <summary>
            Deletes a single item from the XMPP server.
            </summary>
            <param name="id">Id of item.</param>
        </member>
        <member name="M:jabber.connection.PubSubNode.Purge">
            <summary>
            Delete all items from a node at once.
            </summary>
        </member>
        <member name="M:jabber.connection.PubSubNode.PublishItem(System.String,System.Xml.XmlElement)">
            <summary>
            Publishes an item to the node.
            </summary>
            <param name="id">If null, the server will assign an item ID.</param>
            <param name="contents">The XML inside the item.  Should be in a new namespace.</param>
        </member>
        <member name="M:jabber.connection.PubSubNode.Configure(jabber.connection.IqCB,System.Object)">
            <summary>
            Request configuration form as the owner
            </summary>
            <param name="callback">Callback.  Must not be null.  Will not be called back 
            if there is an error, but instead OnError will be called.</param>
            <param name="state">State information to be passed back to callback</param>
        </member>
        <member name="P:jabber.connection.PubSubNode.Jid">
            <summary>
             Retrieves the component that handles publish-subscribe requests.
            </summary>
        </member>
        <member name="P:jabber.connection.PubSubNode.Node">
            <summary>
             Retrieves the node to interact with as defined by XEP-60.
            </summary>
        </member>
        <member name="P:jabber.connection.PubSubNode.Document">
            <summary>
            The document associated with the stream we're attached to.
            </summary>
        </member>
        <member name="P:jabber.connection.PubSubNode.IsInitialized">
            <summary>
            Determines whether or not this node is fully initialized.
            </summary>
        </member>
        <member name="P:jabber.connection.PubSubNode.IsCreated">
            <summary>
            Has the creation request succeeded?
            </summary>
        </member>
        <member name="E:jabber.connection.PubSubNode.OnItemAdd">
            <summary>
            Informs the client that an item has been added to the node,
            either on initial get or by notification.
            NOTE: This may fire for the same item more than once.
            </summary>
        </member>
        <member name="E:jabber.connection.PubSubNode.OnItemRemove">
            <summary>
            Informs the client that an item has been deleted from the node,
            either by notification or the list being full.
            </summary>
        </member>
        <member name="E:jabber.connection.PubSubNode.OnItemPublished">
            <summary>
            Informs the publisher that an item has been published 
            successfully.
            </summary>
        </member>
        <member name="E:jabber.connection.PubSubNode.OnError">
            <summary>
            Notifies the client that an error occurred.
            </summary>
        </member>
        <member name="E:jabber.connection.PubSubNode.OnCreate">
            <summary>
            Node has finished being created, successfully.
            </summary>
        </member>
        <member name="P:jabber.connection.PubSubNode.Item(System.String)">
            <summary>
            Returns the contents of the specified item
            </summary>
            <param name="id">Index of the element to retrieve.</param>
            <returns>XmlElement contents.</returns>
        </member>
        <member name="T:stringprep.unicode.Combining">
            <summary>
            Combining classes for Unicode characters.
            </summary>
        </member>
        <member name="M:stringprep.unicode.Combining.Class(System.Char)">
            <summary>
            What is the combining class for the given character?
            </summary>
            <param name="c">Character to look up</param>
            <returns>Combining class for this character</returns>
        </member>
        <member name="T:jabber.server.XdbCB">
            <summary>
            Received a response to an XDB request.
            </summary>
        </member>
        <member name="T:jabber.server.XdbTracker">
            <summary>
            Track outstanding XDB requests.
            </summary>
        </member>
        <member name="M:jabber.server.XdbTracker.#ctor(jabber.server.JabberService)">
            <summary>
            Create a new XDB tracker
            </summary>
            <param name="comp">The component to send/receive on</param>
        </member>
        <member name="M:jabber.server.XdbTracker.OnXdb(System.Object,jabber.protocol.accept.Xdb)">
            <summary>
            Received an XDB element on Component.
            Is this a response to a tracked request?
            </summary>
            <param name="sender"></param>
            <param name="xdb"></param>
        </member>
        <member name="M:jabber.server.XdbTracker.BeginXdbGet(System.String,System.String,jabber.server.XdbCB,System.Object)">
            <summary>
            Start an XDB request.
            </summary>
            <param name="owner"></param>
            <param name="ns"></param>
            <param name="cb"></param>
            <param name="cbArg"></param>
        </member>
        <member name="M:jabber.server.XdbTracker.BeginXdbSet(System.Xml.XmlElement,System.String,System.String,jabber.server.XdbCB,System.Object)">
            <summary>
            Start an XDB request.
            </summary>
            <param name="root"></param>
            <param name="owner"></param>
            <param name="ns"></param>
            <param name="cb"></param>
            <param name="cbArg"></param>
        </member>
        <member name="M:jabber.server.XdbTracker.BeginXdb(System.Xml.XmlElement,jabber.protocol.accept.XdbType,System.String,System.String,jabber.server.XdbCB,System.Object)">
            <summary>
            Start an XDB request.
            </summary>
            <param name="root"></param>
            <param name="xtype"></param>
            <param name="owner"></param>
            <param name="ns"></param>
            <param name="cb"></param>
            <param name="cbArg"></param>
        </member>
        <member name="M:jabber.server.XdbTracker.BeginXdb(System.Xml.XmlElement,jabber.protocol.accept.XdbType,System.String,System.String,jabber.protocol.accept.XdbAction,jabber.server.XdbCB,System.Object)">
            <summary>
            Start an XDB request.
            </summary>
            <param name="root"></param>
            <param name="xtype"></param>
            <param name="owner"></param>
            <param name="ns"></param>
            <param name="action"></param>
            <param name="cb"></param>
            <param name="cbArg"></param>
        </member>
        <member name="T:jabber.server.ComponentType">
            <summary>
            Type of connection to the server, with respect to jabberd.
            This list will grow over time to include
            queued connections, direct (in-proc) connections, etc.
            </summary>
        </member>
        <member name="F:jabber.server.ComponentType.Accept">
            <summary>
            Jabberd will accept the connetion; the component will
            initiate the connection.  </summary>
        </member>
        <member name="F:jabber.server.ComponentType.Connect">
            <summary>
            Jabberd will connect to the component; jabberd will
            initiate the connection.  </summary>
        </member>
        <member name="T:jabber.server.RouteHandler">
            <summary>
            Received a route element
            </summary>
        </member>
        <member name="T:jabber.server.XdbHandler">
            <summary>
            Received an XDB element.
            </summary>
        </member>
        <member name="T:jabber.server.LogHandler">
            <summary>
            Received a Log element.
            </summary>
        </member>
        <member name="T:jabber.server.JabberService">
            <summary>
            Summary description for ServerComponent.
            </summary>
        </member>
        <member name="T:jabber.connection.XmppStream">
            <summary>
            Manages the XMPP stream of the connection.
            </summary>
        </member>
        <member name="T:jabber.connection.IStanzaEventListener">
            <summary>
            Listens for stanza and connection events
            </summary>
        </member>
        <member name="M:jabber.connection.IStanzaEventListener.Connected">
            <summary>
            Informs the client that the connection to the XMPP server has finished.
            Time to send the stream:stream packet.
            </summary>
        </member>
        <member name="M:jabber.connection.IStanzaEventListener.Accepted">
            <summary>
            Informs the client that a new connection from the server has been accepted.
            Wait for a stream:stream.
            </summary>
        </member>
        <member name="M:jabber.connection.IStanzaEventListener.BytesRead(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Informs the client that text was read from the XMPP server.
            Use for debugging only.
            Will NOT be complete nodes at a time.
            </summary>
            <param name="buf">Buffer containing the data read.</param>
            <param name="offset">Where in the buffer the read data begins.</param>
            <param name="len">Length of the data read.</param>
        </member>
        <member name="M:jabber.connection.IStanzaEventListener.BytesWritten(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Informs the client that text was written to the server.
            Use for debugging only. Will NOT be complete nodes at a time.
            </summary>
            <param name="buf">Bytes to write out.</param>
            <param name="offset">The index in the buffer to start getting bytes.</param>
            <param name="len">The amount of bytes to write out.</param>
        </member>
        <member name="M:jabber.connection.IStanzaEventListener.StreamInit(jabber.protocol.ElementStream)">
            <summary>
            Informs the client that a new stream was initialized.
            You can add your packet factories to it.
            </summary>
            <param name="stream">The stream that was initialized.</param>
        </member>
        <member name="M:jabber.connection.IStanzaEventListener.Errored(System.Exception)">
            <summary>
            Notifies the client that an error has occurred.
            </summary>
            <param name="e">The exception that caused the error.</param>
        </member>
        <member name="M:jabber.connection.IStanzaEventListener.Closed">
            <summary>
            Notifies the client that the session has been closed.
            </summary>
        </member>
        <member name="M:jabber.connection.IStanzaEventListener.DocumentStarted(System.Xml.XmlElement)">
            <summary>
            Informs the client that a doc start tag has been received.
            This may be "synthetic" for some backends.
            </summary>
            <param name="elem">XML element containing the start tag.</param>
        </member>
        <member name="M:jabber.connection.IStanzaEventListener.DocumentEnded">
            <summary>
            Receives the closing stream:stream.  Probably mostly equivalent to Closed(),
            except if the stream is still open, you should close it at this point.
            May not be called for some backends.
            </summary>
        </member>
        <member name="M:jabber.connection.IStanzaEventListener.StanzaReceived(System.Xml.XmlElement)">
            <summary>
            Receives an XML element such as stream:features and so on.
            </summary>
            <param name="elem">The XML Element received.</param>
        </member>
        <member name="M:jabber.connection.IStanzaEventListener.OnInvalidCertificate(bedrock.net.BaseSocket,System.Security.Cryptography.X509Certificates.X509Certificate,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors)">
            <summary>
            An invalid peer certificate was sent during SSL/TLS neogtiation.
            </summary>
            <param name="sock">The socket that experienced the error</param>
            <param name="certificate">The bad certificate</param>
            <param name="chain">The chain of CAs for the cert</param>
            <param name="sslPolicyErrors">A bitfield for the erorrs in the certificate.</param>
            <returns>True if the cert should be accepted anyway.</returns>
        </member>
        <member name="P:jabber.connection.IStanzaEventListener.Item(System.String)">
            <summary>
            Gets or sets properties on the listener.
            </summary>
            <param name="prop">Property name.  Look at the Options class for some ideas.</param>
            <returns></returns>
        </member>
        <member name="E:jabber.connection.IStanzaEventListener.PropertyChanged">
            <summary>
            Notifies the user that one of the properties has changed.
            </summary>
        </member>
        <member name="F:jabber.connection.XmppStream.ENC">
            <summary>
            Contains the character encoding for the XMPP stream.
            Currently, it is set to UTF-8.
            </summary>
        </member>
        <member name="F:jabber.connection.XmppStream.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:jabber.connection.XmppStream.#ctor(System.ComponentModel.IContainer)">
            <summary>
            Creates a new XMPP stream and associates it with the parent control.
            </summary>
            <param name="container">Parent control.</param>
        </member>
        <member name="M:jabber.connection.XmppStream.SetDefaults(System.Object[][])">
            <summary>
            Sets defaults in bulk.
            </summary>
            <param name="defaults">Array of objects to replace to defaults with.</param>
        </member>
        <member name="M:jabber.connection.XmppStream.#ctor">
            <summary>
            Creates a new SocketElementStream.
            </summary>
        </member>
        <member name="M:jabber.connection.XmppStream.SetCertificateFile(System.String,System.String)">
            <summary>
            Sets the certificate to be used for accept sockets.  To
            generate a test .pfx file using OpenSSL, add this to
            openssl.conf:
              <blockquote>
              [ serverex ]
              extendedKeyUsage=1.3.6.1.5.5.7.3.1
              </blockquote>
            and run the following commands:
              <blockquote>
              openssl req -new -x509 -newkey rsa:1024 -keyout
                privkey.pem -out key.pem -extensions serverex
              openssl pkcs12 -export -in key.pem -inkey privkey.pem
                -name localhost -out localhost.pfx
              </blockquote>
            If you leave the certificate null, and you are doing
            Accept, the SSL class will try to find a default server
            certificate on your box.
            </summary>
            <param name="filename">A .pfx or .cer file.</param>
            <param name="password">The password, if this is a .pfx
            file, null if .cer file.</param>
        </member>
        <member name="M:jabber.connection.XmppStream.WriteStartTag(jabber.protocol.stream.Stream)">
            <summary>
            Writes just the start tag of the given XML element.
            Typically only used for &lt;stream:stream&gt;.
            </summary>
            <param name="elem">&lt;stream:stream%gt; XML element.</param>
        </member>
        <member name="M:jabber.connection.XmppStream.Write(System.Xml.XmlElement)">
            <summary>
            Sends the given packet to the server.
            </summary>
            <param name="elem">The XML element to send.</param>
        </member>
        <member name="M:jabber.connection.XmppStream.Write(System.String)">
            <summary>
            Sends a raw string.
            </summary>
            <param name="str">The string to send.</param>
        </member>
        <member name="M:jabber.connection.XmppStream.Connect">
            <summary>
            Starts connecting to the XMPP server.  This is done asyncronously.
            </summary>
        </member>
        <member name="M:jabber.connection.XmppStream.Accept">
            <summary>
            Listens for connections from the XMPP server and is used for components only.
            </summary>
        </member>
        <member name="M:jabber.connection.XmppStream.TryReconnect">
            <summary>
            If autoReconnect is on, start the timer for reconnect now.
            </summary>
        </member>
        <member name="M:jabber.connection.XmppStream.Close">
            <summary>
            Closes down the connection with the XMPP server with a clean shutdown.
            </summary>
        </member>
        <member name="M:jabber.connection.XmppStream.Close(System.Boolean)">
            <summary>
            Closes down the connection.
            </summary>
            <param name="clean">True for graceful shutdown</param>
        </member>
        <member name="M:jabber.connection.XmppStream.CheckedInvoke(System.MulticastDelegate,System.Object[])">
            <summary>
            Invokes the given method on the Invoker, and does some exception handling.
            </summary>
            <param name="method">Method to call on the invoker thread.</param>
            <param name="args">Arguments to pass to the method.</param>
        </member>
        <member name="M:jabber.connection.XmppStream.OnDocumentStart(System.Object,System.Xml.XmlElement)">
            <summary>
            Informs the client that the first tag of the XML document has been received.
            </summary>
            <param name="sender">Caller of this function.</param>
            <param name="elem">The XML element that was received.</param>
        </member>
        <member name="M:jabber.connection.XmppStream.ProcessFeatures">
            <summary>
            Handle the last set of stream:features we have received, 
            based on the current state.
            </summary>
        </member>
        <member name="M:jabber.connection.XmppStream.OnElement(System.Object,System.Xml.XmlElement)">
            <summary>
            Informs the client that an XML element was received and
            invokes the OnProtocol event.
            </summary>
            <param name="sender">The object that called this method.</param>
            <param name="tag">XML element that contains the new tag.</param>
        </member>
        <member name="M:jabber.connection.XmppStream.StartTLS">
            <summary>
            Begins the TLS handshake, either client-side or server-side.
            </summary>
            <returns>True if StartTLS worked.</returns>
        </member>
        <member name="M:jabber.connection.XmppStream.StartCompression">
            <summary>
            Begins compressing the XMPP stream.
            </summary>
            <returns>If True, compression was successful, otherwise False.</returns>
        </member>
        <member name="M:jabber.connection.XmppStream.InitializeStream">
            <summary>
            Gets ready for a new stream:stream by starting a new XML document.
            Needed after Start-TLS or compression, for example.
            </summary>
        </member>
        <member name="M:jabber.connection.XmppStream.SendNewStreamHeader">
            <summary>
            Sends a new XMPP stream header.
            </summary>
        </member>
        <member name="M:jabber.connection.XmppStream.FireOnError(System.Exception)">
            <summary>
            Informs the client of XMPP stream errors through the OnError event.
            </summary>
            <param name="e">Error that occurred.</param>
        </member>
        <member name="M:jabber.connection.XmppStream.AddCallback(System.String,jabber.protocol.ProtocolHandler)">
            <summary>
            Registers a callback, so that if a packet arrives that matches the given xpath expression,
            the callback fires.  Use <see cref="M:jabber.connection.XmppStream.AddNamespace(System.String,System.String)"/> to add namespace prefixes.
            </summary>
            <example>jc.AddCallback("self::iq[@type='result']/roster:query", new ProtocolHandler(GotRoster));</example>
            <param name="xpath">The xpath expression to search for</param>
            <param name="cb">The callback to call when the xpath matches</param>
            <returns>A guid that can be used to unregister the callback</returns>
        </member>
        <member name="M:jabber.connection.XmppStream.RemoveCallback(System.Guid)">
            <summary>
            Removes a callback added with <see cref="M:jabber.connection.XmppStream.AddCallback(System.String,jabber.protocol.ProtocolHandler)"/>.
            </summary>
            <param name="guid">GUID representing the callback to remove.</param>
        </member>
        <member name="M:jabber.connection.XmppStream.AddNamespace(System.String,System.String)">
            <summary>
            Adds a namespace prefix, for use with callback xpath expressions added
            with <see cref="M:jabber.connection.XmppStream.AddCallback(System.String,jabber.protocol.ProtocolHandler)"/>.
            </summary>
            <param name="prefix">The prefix to use.</param>
            <param name="uri">The URI associated with the prefix.</param>
        </member>
        <member name="P:jabber.connection.XmppStream.Item(System.String)">
            <summary>
            Sets or retrieves a connection property.
            You have to know the type of the property based on the name.
            For example, PORT is an integer.
            </summary>
            <param name="prop">The property to get or set.</param>
            <returns></returns>
        </member>
        <member name="E:jabber.connection.XmppStream.PropertyChanged">
            <summary>
            Informs the client that a property changed on the instance.
            </summary>
        </member>
        <member name="E:jabber.connection.XmppStream.OnWriteText">
            <summary>
            Informs the client when text has been written to the XMPP server.
            Use for debugging only.
            Will NOT be complete nodes at a time.
            </summary>
        </member>
        <member name="E:jabber.connection.XmppStream.OnReadText">
            <summary>
            Informs the client that text was read from the server.
            Use for debugging only. Will NOT be complete nodes at a time.
            </summary>
        </member>
        <member name="E:jabber.connection.XmppStream.OnStreamInit">
            <summary>
            Informs the client that a new stream has been inialized.
            You can add your packet factories to the new stream.
            NOTE: You may NOT make calls to the GUI in this callback, unless you
            call Invoke.  Make sure you add your packet factories before
            calling Invoke, however.
            </summary>
        </member>
        <member name="E:jabber.connection.XmppStream.OnError">
            <summary>
            Informs the client that an error occurred when processing.
            The connection has been closed.
            </summary>
        </member>
        <member name="E:jabber.connection.XmppStream.OnProtocol">
            <summary>
            Notifies the client about every jabber packet.
            This is a union of the OnPresence, OnMessage, and OnIQ methods.
            Use this *or* the other 3 methods, but not both, as a matter of style.
            </summary>
        </member>
        <member name="E:jabber.connection.XmppStream.OnStreamHeader">
            <summary>
            Notifies the client that the stream header, as a packet,
            has been received.  Can be called multiple  times for
            a single session, with XMPP.
            </summary>
        </member>
        <member name="E:jabber.connection.XmppStream.OnSASLStart">
            <summary>
            Notifies the client that the SASL handshake has started.
            </summary>
        </member>
        <member name="E:jabber.connection.XmppStream.OnSASLEnd">
            <summary>
            Gets notified of the end of a SASL handshake.
            </summary>
        </member>
        <member name="E:jabber.connection.XmppStream.OnSASLError">
            <summary>
            Gets notified when SASL login fails.
            </summary>
        </member>
        <member name="E:jabber.connection.XmppStream.OnStreamError">
            <summary>
            Informs the client that it received a stream:error packet.
            </summary>
        </member>
        <member name="E:jabber.connection.XmppStream.OnAuthenticate">
            <summary>
            Informs the client that the connection is complete and the user is authenticated.
            </summary>
        </member>
        <member name="E:jabber.connection.XmppStream.OnConnect">
            <summary>
            Informs the client that the connection is connected,
            but no stream:stream has been sent yet.
            </summary>
        </member>
        <member name="E:jabber.connection.XmppStream.OnDisconnect">
            <summary>
            Informs the client that the connection is disconnected.
            </summary>
        </member>
        <member name="E:jabber.connection.XmppStream.OnInvalidCertificate">
            <summary>
            An invalid cert was received from the other side.  Set this event and return true to
            use the cert anyway.  If the event is not set, an ugly user interface will be displayed.
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.Tracker">
            <summary>
            Gets the tracker for sending IQ packets.
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.Server">
            <summary>
            Gets or sets the name of the XMPP server to connect to.
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.NetworkHost">
            <summary>
            Gets or sets the network host address to use on the "to" attribute
            of the stream:stream. You can put the network hostname or IP address
            of the XMPP server to connect to. If none is specified, the Server will
            be used. Eventually, when SRV is supported, this will be deprecated.
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.Port">
            <summary>
            Specifies the TCP port to connect to.
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.PlaintextAuth">
            <summary>
            Specifies whether plaintext authentication is used for connecting
            to the XMPP server.
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.SSLon">
            <summary>
            Determines whether or not the current connection is secured with SSL/TLS.
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.JID">
            <summary>
            Gets the JID from the connection.
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.CompressionOn">
            <summary>
            Determines whether or not the current connection uses
            XMPP stream compression (XEP-138).
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.SSL">
            <summary>
            Determines whether SSL3/TLS1 authentication is used when a user
            connects to the XMPP server.
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.AutoStartTLS">
            <summary>
            Allows Start-TLS on connection if the server supports it and if set to true.
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.AutoStartCompression">
            <summary>
            Allows start compression on connection if the server supports it and
            is set to true.
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.LocalCertificate">
            <summary>
            Gets or sets the certificate to be used for the local
            side of sockets when SSL is enabled.
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.InvokeControl">
            <summary>
            Calls Invoke() for all callbacks on this control.
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.KeepAlive">
            <summary>
            Gets or sets the keep-alive interval in seconds.
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.AutoReconnect">
            <summary>
            Gets or sets the number of seconds before automatically
            reconnecting if the connection drops.
            -1 to disable, 0 for immediate.
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.Proxy">
            <summary>
            Gets or sets the proxy type, such as none, SOCKS5 and so on.
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.Connection">
            <summary>
            Gets or sets the connection type, such as Socket, HTTP polling and so on.
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.ProxyHost">
            <summary>
            Gets or sets the hostname running the proxy.
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.ProxyPort">
            <summary>
            Gets or sets the port number of the proxy host.
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.ProxyUsername">
            <summary>
            Gets or sets the authentication username for the SOCKS5 proxy.
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.ProxyPassword">
            <summary>
            Gets or sets the authentication password for the SOCKS5 proxy.
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.StreamID">
            <summary>
            Gets or sets the ID attribute from the
            stream:stream element sent by the XMPP server.
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.Document">
            <summary>
            Retrieves the outbound document.
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.State">
            <summary>
            Gets or sets the current state of the connection.
            Lock on StateLock before accessing.
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.StateLock">
            <summary>
            Gets the lock for the state information.
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.IsAuthenticated">
            <summary>
            Gets or sets the state to authenticated.  Locks on StateLock
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.NS">
            <summary>
            Returns the namespace for this connection.
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.RequiresSASL">
            <summary>
            Determines whether or not SASL is required for connecting to the XMPP server.
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.ServerVersion">
            <summary>
            Gets the version number of the XMPP server.
            </summary>
        </member>
        <member name="P:jabber.connection.XmppStream.InvokeRequired">
            <summary>
            Determines whether or not a callback needs to be on the GUI thread.
            </summary>
            <returns>
            True if the invoke control is set and the current thread
            is not the GUI thread.
            </returns>
        </member>
        <member name="M:jabber.server.JabberService.#ctor">
            <summary>
            Create a a connect component.
            </summary>
        </member>
        <member name="M:jabber.server.JabberService.#ctor(System.String,System.Int32,System.String,System.String)">
            <summary>
            Create an accept component.  (Component connects to server)
            </summary>
            <param name="host">Jabberd host to connect to</param>
            <param name="port">Jabberd port to connect to</param>
            <param name="name">Component name</param>
            <param name="secret">Component secret</param>
        </member>
        <member name="M:jabber.server.JabberService.#ctor(System.Int32,System.String,System.String)">
            <summary>
            Create a connect component. (Server connects to component)
            </summary>
            <param name="port">Port jabberd will connect to</param>
            <param name="name">Component name</param>
            <param name="secret">Component secret</param>
        </member>
        <member name="M:jabber.server.JabberService.Connect(bedrock.net.Address)">
            <summary>
            Connect to the jabberd, or wait for it to connect to us.
            Either way, this call returns immediately.
            </summary>
            <param name="address">The address to connect to.</param>
        </member>
        <member name="M:jabber.server.JabberService.Connect">
            <summary>
            Connect to the jabberd, or wait for it to connect to us.
            Either way, this call returns immediately.
            </summary>
        </member>
        <member name="M:jabber.server.JabberService.Write(System.Xml.XmlElement)">
            <summary>
            Make sure there's a from address, then write the stanza.
            </summary>
            <param name="elem">The stanza to write</param>
        </member>
        <member name="M:jabber.server.JabberService.OnDocumentStart(System.Object,System.Xml.XmlElement)">
            <summary>
            Got the stream:stream.  Start the handshake.
            </summary>
            <param name="sender"></param>
            <param name="tag"></param>
        </member>
        <member name="M:jabber.server.JabberService.OnElement(System.Object,System.Xml.XmlElement)">
            <summary>
            Received an element.
            </summary>
            <param name="sender"></param>
            <param name="tag"></param>
        </member>
        <member name="E:jabber.server.JabberService.OnRoute">
            <summary>
            We received a route packet.
            </summary>
        </member>
        <member name="E:jabber.server.JabberService.OnXdb">
            <summary>
            We received an XDB packet.
            </summary>
        </member>
        <member name="E:jabber.server.JabberService.OnLog">
            <summary>
            We received a Log packet.
            </summary>
        </member>
        <member name="P:jabber.server.JabberService.ComponentID">
            <summary>
            The service name.  Needs to be in the id attribute in the
            jabber.xml file.  </summary>
        </member>
        <member name="P:jabber.server.JabberService.Server">
            <summary>
            Should not be used for components.  Set NetworkHost instead.
            </summary>
        </member>
        <member name="P:jabber.server.JabberService.Secret">
            <summary>
            Component secret.
            </summary>
        </member>
        <member name="P:jabber.server.JabberService.Type">
            <summary>
            Is this an outgoing connection (base_accept), or an incoming
            connection (base_connect).
            </summary>
        </member>
        <member name="P:jabber.server.JabberService.NS">
            <summary>
            The stream namespace for this connection.
            </summary>
        </member>
        <member name="P:jabber.server.JabberService.OverrideFrom">
            <summary>
            Override the from address that is stamped on all outbound stanzas that 
            have no from address.
            </summary>
        </member>
        <member name="T:jabber.server.HandshakingState">
            <summary>
            Waiting for handshake result.
            </summary>
        </member>
        <member name="T:jabber.connection.BaseState">
            <summary>
            Represents the base class for all states.
            </summary>
        </member>
        <member name="F:jabber.server.HandshakingState.Instance">
            <summary>
            The instance that is always used.
            </summary>
        </member>
        <member name="T:jabber.server.AcceptingState">
            <summary>
            Waiting for socket connection.
            </summary>
        </member>
        <member name="F:jabber.server.AcceptingState.Instance">
            <summary>
            The instance that is always used.
            </summary>
        </member>
        <member name="T:jabber.protocol.stream.FeaturesHandler">
            <summary>
            Stream Features handler
            </summary>
        </member>
        <member name="T:jabber.protocol.stream.Features">
            <summary>
            Stream features.  Will only be set by a version="1.0" or higher XMPP server.
            </summary>
        </member>
        <member name="M:jabber.protocol.stream.Features.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.stream.Features.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.stream.Features.StartTLS">
            <summary>
            The starttls element, or null if none found.
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Features.Mechanisms">
            <summary>
            The SASL mechanisms, or null if none found.
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Features.Compression">
            <summary>
            The compression element, or null if none found.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.OobIQ">
            <summary>
            IQ packet with an oob query element inside.
            </summary>
        </member>
        <member name="T:jabber.protocol.client.TypedIQ`1">
            <summary>
            An IQ subclass that allows typed access to its first child,
            through the Instruction property.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:jabber.protocol.client.IQ">
            <summary>
            All IQ packets start here.  The Query property holds the interesting part.
            There should usually be a convenience class next to the Query type, which
            creates an IQ with the appropriate type of query inside.
            </summary>
        </member>
        <member name="T:jabber.protocol.Packet">
            <summary>
            Packets that have to/from information.
            </summary>
        </member>
        <member name="M:jabber.protocol.Packet.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.Packet.#ctor(System.String,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="localName"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.Packet.Swap">
            <summary>
            Swap the To and the From addresses.
            </summary>
        </member>
        <member name="P:jabber.protocol.Packet.To">
            <summary>
            The TO address
            </summary>
        </member>
        <member name="P:jabber.protocol.Packet.From">
            <summary>
             The FROM address
            </summary>
        </member>
        <member name="P:jabber.protocol.Packet.ID">
            <summary>
            The packet ID.
            </summary>
        </member>
        <member name="M:jabber.protocol.client.IQ.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.client.IQ.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.client.IQ.Swap">
            <summary>
            Swap the To and the From addresses.
            Obsolete: Use GetResponse or GetErrorResponse, now, for IQs.
            </summary>
        </member>
        <member name="M:jabber.protocol.client.IQ.GetResponse(System.Xml.XmlDocument)">
            <summary>
            Swap the to and from, set the type to result.
            </summary>
            <param name="doc"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.client.IQ.GetErrorResponse(System.Xml.XmlDocument,System.String)">
            <summary>
            Respond to this IQ with an error.
            </summary>
            <param name="doc"></param>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="P:jabber.protocol.client.IQ.Handled">
            <summary>
            Has this IQ been handled?  Set automatically by GetResponse and GetErrorResponse.  If this is not
            set to true, Jabber-Net will respond automatically with a 501 error.
            </summary>
        </member>
        <member name="P:jabber.protocol.client.IQ.Type">
             <summary>
            
             </summary>
        </member>
        <member name="P:jabber.protocol.client.IQ.Error">
            <summary>
            IQ error.
            </summary>
        </member>
        <member name="P:jabber.protocol.client.IQ.Query">
            <summary>
            The query tag inside, regardless of namespace.
            If the iq contains something other than query,
            use normal XmlElement routines.
            </summary>
        </member>
        <member name="M:jabber.protocol.client.TypedIQ`1.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create an IQ to send out, with an instance of the specified
            type as a child.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.client.TypedIQ`1.Instruction">
            <summary>
            The child element (often "query") with the command for this IQ.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.OobIQ.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create an OOB IQ.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.OOB">
            <summary>
            An oob query element for file transfer.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.OOB.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.OOB.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.OOB.Url">
            <summary>
            URL to send/receive from
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.OOB.Desc">
            <summary>
            File description
            </summary>
        </member>
        <member name="T:jabber.protocol.DashAttribute">
            <summary>
            An enum that should translate "_" into "-" for use externally.
            </summary>
        </member>
        <member name="M:jabber.protocol.DashAttribute.#ctor">
            <summary>
            This is just a flag attribute.
            </summary>
        </member>
        <member name="T:jabber.connection.sasl.ExternalProcessor">
            <summary>
            SASL Mechanism EXTERNAL as specified in XEP-0178.
            </summary>
        </member>
        <member name="M:jabber.connection.sasl.ExternalProcessor.step(jabber.protocol.stream.Step,System.Xml.XmlDocument)">
            <summary>
            Perform the next step
            </summary>
            <param name="s">Null if it's the initial response</param>
            <param name="doc">Document to create Steps in</param>
            <returns></returns>
        </member>
        <member name="T:bedrock.util.SourceVersionAttribute">
            <summary>
            Make source code versions available at runtime.  Use the appropriate
            subclass for your CM system.
            </summary>
            <see cref="T:bedrock.util.StarTeamAttribute"/>
            <see cref="T:bedrock.util.SourceSafeAttribute"/>
            <see cref="T:bedrock.util.RCSAttribute"/>
        </member>
        <member name="F:bedrock.util.SourceVersionAttribute.m_header">
            <summary>
            The entire header
            </summary>
        </member>
        <member name="F:bedrock.util.SourceVersionAttribute.m_archive">
            <summary>
            The directory it's stored in
            </summary>
        </member>
        <member name="F:bedrock.util.SourceVersionAttribute.m_author">
            <summary>
            Last check-in author
            </summary>
        </member>
        <member name="F:bedrock.util.SourceVersionAttribute.m_version">
            <summary>
            Last check-in version
            </summary>
        </member>
        <member name="F:bedrock.util.SourceVersionAttribute.m_date">
            <summary>
            Last check-in date
            </summary>
        </member>
        <member name="F:bedrock.util.SourceVersionAttribute.m_parsed">
            <summary>
            Have we parsed the header, yet?
            </summary>
        </member>
        <member name="M:bedrock.util.SourceVersionAttribute.#ctor(System.String)">
            <summary>
            Construct the attribute.  Parsing is delayed until needed.
            </summary>
            <param name="header">the Header keyword for your CM system.
            Usually &#36;Header&#36;</param>
        </member>
        <member name="M:bedrock.util.SourceVersionAttribute.#ctor">
            <summary>
            You could use this one, and pass the keywords in individually.
            </summary>
        </member>
        <member name="M:bedrock.util.SourceVersionAttribute.ToString">
            <summary>
            Give back the header string.
            </summary>
        </member>
        <member name="M:bedrock.util.SourceVersionAttribute.CheckParse">
            <summary>
            Have we parsed yet?
            </summary>
        </member>
        <member name="M:bedrock.util.SourceVersionAttribute.SetParse">
            <summary>
            We have done a parse, now
            </summary>
        </member>
        <member name="M:bedrock.util.SourceVersionAttribute.Parse">
            <summary>
            Parse data into internal fields
            </summary>
        </member>
        <member name="M:bedrock.util.SourceVersionAttribute.GetField(System.String)">
            <summary>
            Do a regex match on src
            </summary>
            <param name="src"></param>
            <returns></returns>
        </member>
        <member name="M:bedrock.util.SourceVersionAttribute.GetVersion(System.Type)">
            <summary>
            Get the version information for the given type.
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:bedrock.util.SourceVersionAttribute.GetVersion(System.Object)">
            <summary>
            Get the version information for the class of the given object.
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:bedrock.util.SourceVersionAttribute.GetVersion">
            <summary>
            Get all of the versioned classes currently in the working set.
            </summary>
            <returns></returns>
        </member>
        <member name="P:bedrock.util.SourceVersionAttribute.Revision">
            <summary>
            The last checked-in version
            </summary>
        </member>
        <member name="P:bedrock.util.SourceVersionAttribute.Version">
            <summary>
            The last checked-in version, in perhaps more useful format
            </summary>
        </member>
        <member name="P:bedrock.util.SourceVersionAttribute.Date">
            <summary>
            Retrive the binary date/time of last check-in
            </summary>
        </member>
        <member name="P:bedrock.util.SourceVersionAttribute.DateString">
            <summary>
            Retrieve the string representation of the date of last check-in.
            </summary>
        </member>
        <member name="P:bedrock.util.SourceVersionAttribute.Author">
            <summary>
            Retrive the name of the last person to check in
            </summary>
        </member>
        <member name="P:bedrock.util.SourceVersionAttribute.Archive">
            <summary>
            Retrieve the archive name from the header
            </summary>
        </member>
        <member name="T:bedrock.util.StarTeamAttribute">
             <summary>
             Make StarTeam versoning available at run-time.
            
             </summary>
             <example>
             [StarTeam(@"&#36;Header&#36;")]
             public class foo {}
            
             SourceVersionAttribute sta = SourceVersionAttribute.GetVersion(typeof(foo));
             </example>
        </member>
        <member name="M:bedrock.util.StarTeamAttribute.#ctor(System.String)">
            <summary>
            Normal usage
            </summary>
            <param name="header"></param>
        </member>
        <member name="M:bedrock.util.StarTeamAttribute.#ctor">
            <summary>
            Not useful
            </summary>
        </member>
        <member name="M:bedrock.util.StarTeamAttribute.ToString">
            <summary>
            Return normalized header
            </summary>
            <returns></returns>
        </member>
        <member name="M:bedrock.util.StarTeamAttribute.Parse">
            <summary>
            Parse the header
            </summary>
        </member>
        <member name="T:bedrock.util.RCSAttribute">
            <summary>
            Version control attribute for RCS and CVS.
            </summary>
        </member>
        <member name="M:bedrock.util.RCSAttribute.#ctor(System.String)">
            <summary>
            The most common.  Pass in @"$ Header $" (without the spaces).
            </summary>
            <param name="header"></param>
        </member>
        <member name="M:bedrock.util.RCSAttribute.#ctor">
            <summary>
            Null constructor.  This is rarely right.
            </summary>
        </member>
        <member name="M:bedrock.util.RCSAttribute.Parse">
            <summary>
            Parse the header string.
            </summary>
        </member>
        <member name="P:bedrock.util.RCSAttribute.State">
            <summary>
            Hm.  Wish I remembered what this was for.  :)
            </summary>
        </member>
        <member name="T:bedrock.util.SourceSafeAttribute">
            <summary>
            Version control attribute for SourceSafe.
            I don't use this any more, so someone tell me if it breaks with
            some new release.
            </summary>
        </member>
        <member name="M:bedrock.util.SourceSafeAttribute.#ctor(System.String)">
            <summary>
            The normal use.  Pass in @"$ Header $" (without the spaces).
            </summary>
            <param name="header"></param>
        </member>
        <member name="M:bedrock.util.SourceSafeAttribute.#ctor">
            <summary>
            Not usually useful.
            </summary>
        </member>
        <member name="M:bedrock.util.SourceSafeAttribute.Parse">
            <summary>
            Parse the header.
            </summary>
        </member>
        <member name="T:bedrock.util.SourceVersionCollection">
            <summary>
            A collection of SourceVersionAttributes, so that we can
            return a list of all of the versioned classes in the
            current working set.
            </summary>
        </member>
        <member name="M:bedrock.util.SourceVersionCollection.Add(System.String,bedrock.util.SourceVersionAttribute)">
            <summary>
            Add an attribute to the list
            </summary>
            <param name="type"></param>
            <param name="value"></param>
        </member>
        <member name="M:bedrock.util.SourceVersionCollection.Clear">
            <summary>
            Remove all of the attributes from the list
            </summary>
        </member>
        <member name="M:bedrock.util.SourceVersionCollection.Get(System.Int32)">
            <summary>
            Get the index'th attribute
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:bedrock.util.SourceVersionCollection.Get(System.String)">
            <summary>
            Get the attribute associated with a give type name
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:bedrock.util.SourceVersionCollection.Set(System.String,bedrock.util.SourceVersionAttribute)">
            <summary>
            Set the attribute associated with a given type name
            </summary>
            <param name="type"></param>
            <param name="value"></param>
        </member>
        <member name="M:bedrock.util.SourceVersionCollection.Set(System.Int32,bedrock.util.SourceVersionAttribute)">
            <summary>
            Set the index'th attribute
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:bedrock.util.SourceVersionCollection.Remove(System.Int32)">
            <summary>
            Remove the index'th attribute
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:bedrock.util.SourceVersionCollection.Remove(System.String)">
            <summary>
            Remove the attribute associated with the given type name
            </summary>
            <param name="type"></param>
        </member>
        <member name="P:bedrock.util.SourceVersionCollection.Item(System.Int32)">
            <summary>
            Retrieve the index'th attribute
            </summary>
        </member>
        <member name="P:bedrock.util.SourceVersionCollection.Item(System.String)">
            <summary>
            Retrieve/set the attriubute associated with the given type name.
            </summary>
        </member>
        <member name="P:bedrock.util.SourceVersionCollection.Item(System.Type)">
            <summary>
            Retrieve/set the attribute associated with the given type.
            </summary>
        </member>
        <member name="T:bedrock.util.SVNAttribute">
            <summary>
            Version control attribute for Subversion.
            </summary>
        </member>
        <member name="M:bedrock.util.SVNAttribute.#ctor(System.String)">
            <summary>
            The most common.  Pass in @"$ Id $" (without the spaces).
            </summary>
            <param name="header"></param>
        </member>
        <member name="M:bedrock.util.SVNAttribute.#ctor">
            <summary>
            Null constructor.  This is rarely right.
            </summary>
        </member>
        <member name="M:bedrock.util.SVNAttribute.Parse">
            <summary>
            Parse the header string.
            </summary>
        </member>
        <member name="T:bedrock.collections.StringSet">
            <summary>
            A set of strings, backed into a BitArray.  Any given string that is inserted
            into any instance of a StringSet increases the size of all StringSets over time.
            </summary>
        </member>
        <member name="M:bedrock.collections.StringSet.#ctor">
            <summary>
            Create a new StringSet, which is empty, but sized for all strings seen so far.
            </summary>
        </member>
        <member name="M:bedrock.collections.StringSet.#ctor(bedrock.collections.StringSet)">
            <summary>
            Create a new set with the contents of another set.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:bedrock.collections.StringSet.#ctor(System.String)">
            <summary>
            Create a set with one string in it.
            </summary>
            <param name="str"></param>
        </member>
        <member name="M:bedrock.collections.StringSet.#ctor(System.String[])">
            <summary>
            Create a set containing all of the strings from the specified array.
            </summary>
            <param name="arr"></param>
        </member>
        <member name="M:bedrock.collections.StringSet.Add(System.String)">
            <summary>
            Add a string to this set.  If it is already in the set, this is a no-op.
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:bedrock.collections.StringSet.Add(bedrock.collections.StringSet)">
            <summary>
            Add all of the strings from the given set to this set.
            </summary>
            <param name="set"></param>
        </member>
        <member name="M:bedrock.collections.StringSet.Add(System.String[])">
            <summary>
            Add all of the strings from the given array to this set.
            </summary>
            <param name="arr"></param>
        </member>
        <member name="M:bedrock.collections.StringSet.Remove(System.String)">
            <summary>
            Remove the given string from this set.
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:bedrock.collections.StringSet.Remove(bedrock.collections.StringSet)">
            <summary>
            Remove all of the strings from the given set from this set.
            </summary>
            <param name="set"></param>
        </member>
        <member name="M:bedrock.collections.StringSet.Clear">
            <summary>
            Clear all of the strings from this set.
            </summary>
        </member>
        <member name="M:bedrock.collections.StringSet.Contains(System.String)">
            <summary>
            Is this string in the set?
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:bedrock.collections.StringSet.op_Addition(bedrock.collections.StringSet,bedrock.collections.StringSet)">
            <summary>
            Add two StringSets together, returning a new set.
            </summary>
            <param name="one"></param>
            <param name="two"></param>
            <returns></returns>
        </member>
        <member name="M:bedrock.collections.StringSet.op_Addition(bedrock.collections.StringSet,System.String)">
            <summary>
            Returns a new set containing the contents of the first set as well as the
            other string.
            </summary>
            <param name="set"></param>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:bedrock.collections.StringSet.op_Subtraction(bedrock.collections.StringSet,bedrock.collections.StringSet)">
            <summary>
            Returns a new set containing everything from the first set that isn't in
            the second set.
            </summary>
            <param name="one"></param>
            <param name="two"></param>
            <returns></returns>
        </member>
        <member name="M:bedrock.collections.StringSet.op_Subtraction(bedrock.collections.StringSet,System.String)">
            <summary>
            Returns a new set containing everything from the first except the specified
            string.
            </summary>
            <param name="set"></param>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:bedrock.collections.StringSet.Equals(System.Object)">
            <summary>
            Is this set equal to another one?
            Warning: this is about 32x slower than it should be.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:bedrock.collections.StringSet.GetHashCode">
            <summary>
            Hashcode for the current contents of the list.
            SLOW!
            </summary>
            <returns></returns>
        </member>
        <member name="M:bedrock.collections.StringSet.GetStrings">
            <summary>
            Get all of the strings that are currently in the set.
            No guarantee of order.
            </summary>
            <returns></returns>
        </member>
        <member name="M:bedrock.collections.StringSet.ToString">
            <summary>
            All of the strings from the set, newline-separated.
            </summary>
            <returns></returns>
        </member>
        <member name="M:bedrock.collections.StringSet.GetEnumerator">
            <summary>
            Enumerate over the strings in the set.
            </summary>
            <returns></returns>
        </member>
        <member name="M:bedrock.collections.StringSet.System#Collections#Generic#IEnumerable{System#String}#GetEnumerator">
            <summary>
            Enumerate over the strings in the set.
            </summary>
            <returns></returns>
        </member>
        <member name="M:bedrock.collections.StringSet.Clone">
            <summary>
            Return a copy of this set.
            </summary>
            <returns></returns>
        </member>
        <member name="P:bedrock.collections.StringSet.Item(System.String)">
            <summary>
            Gets or sets whether this string is in the set.
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="P:bedrock.collections.StringSet.Count">
            <summary>
            How many strings are in the set?
            May be slower than you expect, at the moment.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.GeoLocIQ">
            <summary>
            A GeoLoc IQ.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.GeoLocIQ.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create a GeoLoc IQ.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.GeoLoc">
            <summary>
            Geographic location.  See http://www.xmpp.org/extensions/xep-0080.html.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.GeoLoc.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.GeoLoc.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.GeoLoc.Altitude">
            <summary>
             Altitude above/below sea level, in meters.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.GeoLoc.Bearing">
            <summary>
            Assuming decimal degrees to true north.
            Note: this is being further specified in the XEP.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.GeoLoc.Datum">
            <summary>
            GPS datum, defaults to WGS84.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.GeoLoc.Description">
            <summary>
            A natural-language description of the location.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.GeoLoc.Error">
            <summary>
            Horizontal GPS error in arc minutes.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.GeoLoc.Latitude">
            <summary>
            Latitude in decimal degrees North.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.GeoLoc.Longitude">
            <summary>
            Longitude in decimal degrees East.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.GeoLoc.Timestamp">
            <summary>
            UTC timestamp specifying the moment when the reading was taken.
            </summary>
        </member>
        <member name="T:jabber.connection.StreamHandler">
            <summary>
            Informs the client about events that happen on an ElementStream.
            </summary>
        </member>
        <member name="T:jabber.connection.Options">
            <summary>
            Manages option names.  These must be well-formed XML element names.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.NAMESPACE">
            <summary>
            Contains the default namespace for this connection.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.NETWORK_HOST">
            <summary>
            Contains the network hostname or IP address of the XMPP server to connect to.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.TO">
            <summary>
            Contains the identity of the item that the client is connecting to.
            For components, the component ID.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.SERVER_ID">
            <summary>
            Contains the server identity that is expected on the X.509 certificate
            from the XMPP server.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.KEEP_ALIVE">
            <summary>
            Determines the keep-alive interval in seconds.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.CURRENT_KEEP_ALIVE">
            <summary>
            Don't start keep-alives until we're fully authenticated.  This is what the SocketStanzaStream actually checks.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.PORT">
            <summary>
            Contains the port number to connect to or to listen on.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.SSL">
            <summary>
            Uses SSL on connection if set to true.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.AUTO_TLS">
            <summary>
            Uses Start-TLS on connection if set to true and
            the server supports it.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.AUTO_COMPRESS">
            <summary>
            Starts the XMPP stream compression (XEP-138) on connection
            if set to true.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.PLAINTEXT">
            <summary>
            Allows plaintext authentication for connecting to the XMPP server.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.SASL">
            <summary>
            Attempts a SASL connection if set to true and the feature is available
            from the XMPP server. If the server doesn't support SASL, the connection
            will move to a fallback mechanism.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.REQUIRE_SASL">
            <summary>
            Requires SASL authentication on this connection if set to true.
            There is no fallback mechanism. If the server doesn't support SASL,
            the connection attempt will fail.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.SASL_MECHANISMS">
            <summary>
            Contains the list of SASL Mechanisms such as Digest-MD5, Plain and so on.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.USER">
            <summary>
            Contains the username to connect as.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.PASSWORD">
            <summary>
            Contains the password for the user, or secret for the component.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.RESOURCE">
            <summary>
            Contains the connecting resource which is used to identify a unique connection.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.PRIORITY">
            <summary>
            Contains the presence default priority for this connection.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.SRV_PREFIX">
            <summary>
            Contains the DNS Service/Protocol to prepend to domain.
            Example: _xmpp-client._tcp.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.AUTO_LOGIN">
            <summary>
            Allows auto-login to be used for the connection to the XMPP server
            if set to true.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.AUTO_LOGIN_THISPASS">
            <summary>
            This pass through the login process, can we login?
            This option is set/reset by the framework.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.AUTO_ROSTER">
            <summary>
            Retrieves the roster items from the XMPP server on
            connection if set to true.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.AUTO_IQ_ERRORS">
            <summary>
            Sends back 501/feature-not-implemented to the XMPP server if
            there are IQs that have not been handled if set to true.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.AUTO_PRESENCE">
            <summary>
            Sends the presence on connection if set to true.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.LOCAL_CERTIFICATE">
            <summary>
            Contains the certificate for our side of the SSL/TLS negotiation.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.REMOTE_CERTIFICATE">
            <summary>
            Contains the remote certificate that the XMPP server sent to the client.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.CERTIFICATE_GUI">
            <summary>
            Uses x509 selection dialog box when a certificate is requested
            if set to true.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.RECONNECT_TIMEOUT">
            <summary>
            Contains the number of seconds to wait before attempting a reconnect.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.CONNECTION_TYPE">
            <summary>
            Determines the connection type (sockets, HTTP polling, or HTTP binding).
            </summary>
        </member>
        <member name="F:jabber.connection.Options.POLL_URL">
            <summary>
            Contains the URL to poll on, or bind to.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.COMPONENT_DIRECTION">
            <summary>
            Connects to the XMPP server or listen for connections.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.JID">
            <summary>
            Contains the logical JID associated with this connection.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.PROXY_TYPE">
            <summary>
            Contains the proxy type, such as none, SOCKS5 and so on.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.PROXY_HOST">
            <summary>
            Contains the hostname or IP address of the proxy.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.PROXY_PORT">
            <summary>
            Contains the port number for the proxy.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.PROXY_USER">
            <summary>
            Contains the username for the proxy server.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.PROXY_PW">
            <summary>
            Contains the password for the proxy server.
            </summary>
        </member>
        <member name="F:jabber.connection.Options.OVERRIDE_FROM">
            <summary>
            Override the from address, in a component/service connection.
            </summary>
        </member>
        <member name="T:bedrock.collections.TrieKeyWalker">
            <summary>
            The method signature used by <see cref="M:bedrock.collections.Trie.Traverse(bedrock.collections.TrieKeyWalker,System.Object,bedrock.collections.TrieNode,bedrock.collections.ByteStack)"/> when it encounters a key.
            </summary>
        </member>
        <member name="T:bedrock.collections.TrieWalker">
            <summary>
            The method signature used by <see cref="M:bedrock.collections.Trie.Traverse(bedrock.collections.TrieWalker,System.Object,bedrock.collections.TrieNode)"/> when it encounters a node.
            </summary>
        </member>
        <member name="T:bedrock.collections.Trie">
            <summary>
            A trie is a tree structure that implements a radix search.  Each node of the tree has a
            sub-node for each possible next byte.
            </summary>
        </member>
        <member name="F:bedrock.collections.Trie.m_root">
            <summary>
            The root node of the trie.
            </summary>
        </member>
        <member name="F:bedrock.collections.Trie.m_count">
            <summary>
            The number of nodes are in the trie
            </summary>
        </member>
        <member name="M:bedrock.collections.Trie.#ctor">
            <summary>
            Creates an empty trie.
            </summary>
        </member>
        <member name="M:bedrock.collections.Trie.FindNode(System.Byte[],System.Boolean)">
            <summary>
            Find a node for a given key, somewhere under the root.
            </summary>
            <param name="key">The bytes to search for, where key[0] corresponds to a child
            node of the root.</param>
            <param name="create">Create nodes that don't exist, while searching.</param>
            <returns>The node if found. If the node doesn't exist and create is true, the node created; otherwise null.</returns>
        </member>
        <member name="M:bedrock.collections.Trie.FindNode(System.Byte[],bedrock.collections.TrieNode,System.Boolean)">
            <summary>
            Finds a node in the given sub-tree.
            </summary>
            <param name="key">The key to search on, where key[0] corresponds to a child of startAt.</param>
            <param name="startAt">The node to search under</param>
            <param name="create">Create nodes that don't exist, while searching.</param>
            <returns>The node if found. If the node doesn't exist and create is true, the node created; otherwise null.</returns>
        </member>
        <member name="M:bedrock.collections.Trie.KeyBytes(System.Object)">
            <summary>
            Compute the byte array corresping to the given object.
            This is likely to cause problems for non 7-bit ASCII text.
            </summary>
            <param name="key"> </param>
        </member>
        <member name="M:bedrock.collections.Trie.Increment(System.Object)">
            <summary>
            Extra functionality for trie's whose values are integers.
            Increment the value corresponding to the key.  If
            the key doesn't exist, put in a value of '1'.
            </summary>
            <param name="key"> </param>
        </member>
        <member name="M:bedrock.collections.Trie.Traverse(bedrock.collections.TrieKeyWalker,System.Object)">
            <summary>
            Performs the given function on every element of the trie. This is equivalent to Perl's map() operator.
            </summary>
            <param name="w">The function to call</param>
            <param name="data">Extra data to pass along to the function.</param>
        </member>
        <member name="M:bedrock.collections.Trie.Traverse(bedrock.collections.TrieKeyWalker,System.Object,bedrock.collections.TrieNode,bedrock.collections.ByteStack)">
            <summary>
            Perform the given function on every element of the trie.  Perl's map() operator.
            </summary>
            <param name="w">The function to call</param>
            <param name="data">Extra data to pass along to the function.</param>
            <param name="current">What node are we currently on?</param>
            <param name="key">A stack holding the current key value</param>
        </member>
        <member name="M:bedrock.collections.Trie.Traverse(bedrock.collections.TrieWalker,System.Object)">
            <summary>
            Perform the given function on every element of the trie.  Perl's map() operator.
            Don't keep track of the keys (slightly faster than the other Traverse() method).
            </summary>
            <param name="w">The function to call</param>
            <param name="data">Extra data to pass along to the function.</param>
        </member>
        <member name="M:bedrock.collections.Trie.Traverse(bedrock.collections.TrieWalker,System.Object,bedrock.collections.TrieNode)">
            <summary>
            Perform the given function on every element of the trie.  Perl's map() operator.
            </summary>
            <param name="w">The function to call</param>
            <param name="data">Extra data to pass along to the function.</param>
            <param name="current">What node are we currently on?</param>
        </member>
        <member name="M:bedrock.collections.Trie.KeyWalker(bedrock.collections.TrieNode,System.Object,bedrock.collections.ByteStack)">
            <summary>
            Find all of the keys.
            </summary>
            <param name="n"> </param>
            <param name="data"> </param>
            <param name="key"> </param>
        </member>
        <member name="M:bedrock.collections.Trie.Remove(System.Object)">
            <summary>
            Removes the node associated with the given key, along with all newly empty ancestors.
            </summary>
            <param name="key">Key to remove.</param>
        </member>
        <member name="M:bedrock.collections.Trie.System#Collections#IDictionary#GetEnumerator">
            <summary>
            Iterate the dictionary way.
            </summary>
        </member>
        <member name="M:bedrock.collections.Trie.Clear">
            <summary>
            Deletes all nodes.
            </summary>
        </member>
        <member name="M:bedrock.collections.Trie.Add(System.Object,System.Object)">
            <summary>
            Add a new key/value pair.
            </summary>
            <param name="key"> </param>
            <param name="value"> </param>
        </member>
        <member name="M:bedrock.collections.Trie.Contains(System.Object)">
            <summary>
            Is the given key in the trie?
            </summary>
            <param name="key"> </param>
        </member>
        <member name="M:bedrock.collections.Trie.CopyTo(System.Array,System.Int32)">
            <summary>
            Copy into an array.
            </summary>
            <param name="array"> </param>
            <param name="index"> </param>
        </member>
        <member name="M:bedrock.collections.Trie.GetEnumerator">
            <summary>
            Iterate over the keys.  Each key will be a byte[].
            </summary>
        </member>
        <member name="P:bedrock.collections.Trie.Item(System.Object)">
            <summary>
            Retrieve the value associated with the given key.
            </summary>
        </member>
        <member name="P:bedrock.collections.Trie.IsFixedSize">
            <summary>
            Always "false" for now.
            </summary>
        </member>
        <member name="P:bedrock.collections.Trie.Keys">
            <summary>
            Get a list of all of the keys.  Hope this doesn't get called often, since it has to make copies
            of all of the possible keys.
            </summary>
        </member>
        <member name="P:bedrock.collections.Trie.Values">
            <summary>
            Returns a collection containing all of the values.
            </summary>
        </member>
        <member name="P:bedrock.collections.Trie.Count">
            <summary>
            How many values are stored?  Note: NOT how many nodes.
            </summary>
        </member>
        <member name="P:bedrock.collections.Trie.SyncRoot">
            <summary>
            Object to synchronize on, if in thread-safe mode.
            TODO: implement settable SyncRoot
            </summary>
        </member>
        <member name="P:bedrock.collections.Trie.IsReadOnly">
            <summary>
            Always "false" for now
            </summary>
        </member>
        <member name="P:bedrock.collections.Trie.IsSynchronized">
            <summary>
            Gets a value indicating whether access to the trie is synchronized in thread-safe mode.
            Only returns false now.
            </summary>
        </member>
        <member name="T:bedrock.collections.GraphNode">
            <summary>
            A node in a Graph, such as a Tree
            </summary>
        </member>
        <member name="M:bedrock.collections.GraphNode.#ctor(System.Object,System.Object)">
            <summary>
            Creates a new node, with key and data.
            </summary>
            <param name="key">The key used to retrieve the data</param>
            <param name="data">The data in the node</param>
        </member>
        <member name="M:bedrock.collections.GraphNode.#ctor(System.Object,System.Object,System.Boolean)">
            <summary>
            Creates a new node, with key and data, possibly having
            sorted children. 
            </summary>
            <param name="key">The key used to retrieve the data</param>
            <param name="data">The data in the node</param>
            <param name="sorted">Should the children be sorted?</param>
        </member>
        <member name="M:bedrock.collections.GraphNode.Add(System.Object,System.Object)">
            <summary>
            Adds a new child node
            </summary>
            <param name="key">The key for the child</param>
            <param name="data">The data for the child</param>
            <returns>The child node added to the graph.</returns>
        </member>
        <member name="M:bedrock.collections.GraphNode.GetEnumerator">
            <summary>
            Iterate over the child nodes
            </summary>
            <returns></returns>
        </member>
        <member name="P:bedrock.collections.GraphNode.Key">
            <summary>
            The key for this node.
            </summary>
        </member>
        <member name="P:bedrock.collections.GraphNode.Data">
            <summary>
            The data associated with this node.
            </summary>
        </member>
        <member name="P:bedrock.collections.GraphNode.Item(System.Object)">
            <summary>
            Retrieves a child node, based on the key.
            </summary>
        </member>
        <member name="P:bedrock.collections.GraphNode.IsRoot">
            <summary>
            Determines whether this is a root node.
            </summary>
        </member>
        <member name="T:xpnet.ContentToken">
            <summary>
            Represents information returned by <code>Encoding.tokenizeContent</code>.
            @see Encoding#tokenizeContent
            </summary>
        </member>
        <member name="T:xpnet.Token">
            <summary>
            A token that was parsed.
            </summary>
        </member>
        <member name="P:xpnet.Token.TokenEnd">
            <summary>
            The end of the current token, in relation to the beginning of the buffer.
            </summary>
        </member>
        <member name="P:xpnet.Token.NameEnd">
            <summary>
            The end of the current token's name, in relation to the beginning of the buffer.
            </summary>
        </member>
        <member name="P:xpnet.Token.RefChar1">
            <summary>
            The parsed-out character. &amp; for &amp;amp;
            </summary>
        </member>
        <member name="P:xpnet.Token.RefChar2">
            <summary>
            The second of two parsed-out characters.  TODO: find example.
            </summary>
        </member>
        <member name="M:xpnet.ContentToken.getAttributeSpecifiedCount">
            <summary>
            Returns the number of attributes specified in the start-tag or empty element tag.
            </summary>
            <returns></returns>
        </member>
        <member name="M:xpnet.ContentToken.getAttributeNameStart(System.Int32)">
            <summary>
            Returns the index of the first character of the name of the
            attribute index.
            </summary>
            <param name="i">Attribute index</param>
            <returns>Index of the first character</returns>
        </member>
        <member name="M:xpnet.ContentToken.getAttributeNameEnd(System.Int32)">
            Returns the index following the last character of the name of the
            attribute index <code>i</code>.
        </member>
        <member name="M:xpnet.ContentToken.getAttributeValueStart(System.Int32)">
            Returns the index of the character following the opening quote of
            attribute index <code>i</code>.
        </member>
        <member name="M:xpnet.ContentToken.getAttributeValueEnd(System.Int32)">
            Returns the index of the closing quote attribute index <code>i</code>.
        </member>
        <member name="M:xpnet.ContentToken.isAttributeNormalized(System.Int32)">
            Returns true if attribute index <code>i</code> does not need to
            be normalized.  This is an optimization that allows further processing
            of the attribute to be avoided when it is known that normalization
            cannot change the value of the attribute.
        </member>
        <member name="M:xpnet.ContentToken.clearAttributes">
            <summary>
            Clear out all of the current attributes
            </summary>
        </member>
        <member name="M:xpnet.ContentToken.appendAttribute(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Add a new attribute
            </summary>
            <param name="nameStart"></param>
            <param name="nameEnd"></param>
            <param name="valueStart"></param>
            <param name="valueEnd"></param>
            <param name="normalized"></param>
        </member>
        <member name="M:xpnet.ContentToken.checkAttributeUniqueness(System.Byte[])">
            <summary>
            Is the current attribute unique?
            </summary>
            <param name="buf"></param>
        </member>
        <member name="T:jabber.protocol.stream.Factory">
            <summary>
            ElementFactory for http://etherx.jabber.org/streams
            </summary>
        </member>
        <member name="T:jabber.protocol.IPacketTypes">
            <summary>
            Interface for packet factories to implement.
            </summary>
        </member>
        <member name="P:jabber.protocol.IPacketTypes.Types">
            <summary>
            QName to type mappings.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.TelephoneType">
            <summary>
            Type of telephone number.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.TelephoneType.unknown">
            <summary>
            None specified
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.TelephoneType.voice">
            <summary>
            voice
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.TelephoneType.fax">
            <summary>
            fax
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.TelephoneType.pager">
            <summary>
            pager
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.TelephoneType.msg">
            <summary>
            voice mail
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.TelephoneType.cell">
            <summary>
            mobile
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.TelephoneType.video">
            <summary>
            video phone
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.TelephoneType.bbs">
            <summary>
            Bulletin Board System
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.TelephoneType.modem">
            <summary>
            Modem
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.TelephoneType.isdn">
            <summary>
            ISDN
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.TelephoneType.pcs">
            <summary>
            dunno.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.TelephoneLocation">
            <summary>
            Telephone location
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.TelephoneLocation.home">
            <summary>
            Home
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.TelephoneLocation.work">
            <summary>
            Work
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.TelephoneLocation.unknown">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.AddressLocation">
            <summary>
            Address location
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.AddressLocation.home">
            <summary>
            Home
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.AddressLocation.work">
            <summary>
            Work
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.AddressLocation.unknown">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.EmailType">
            <summary>
            Email type attribute
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.EmailType.NONE">
            <summary>
            None specified
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.EmailType.home">
            <summary>
            Home
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.EmailType.work">
            <summary>
            Work
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.EmailType.internet">
            <summary>
            Internet
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.EmailType.x400">
            <summary>
            x400
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.VCardIQ">
            <summary>
            IQ packet with a version query element inside.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.VCardIQ.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create a vCard IQ
            </summary>
            <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.VCardIQ.VCard">
            <summary>
            returns the vCard element for this iq.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.VCard">
            <summary>
            A vCard element.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.VCard.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.VCard.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.VCard.GetTelephoneList">
            <summary>
            List of telephone numbers
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.VCard.GetTelephone(jabber.protocol.iq.TelephoneType,jabber.protocol.iq.TelephoneLocation)">
             <summary>
            
             </summary>
             <param name="type"></param>
             <param name="location"></param>
             <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.VCard.GetAddressList">
            <summary>
            List of addresses
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.VCard.GetAddress(jabber.protocol.iq.AddressLocation)">
            <summary>
            Get the address for the given location.
            </summary>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.VCard.GetEmailList">
            <summary>
            List of Email addresses
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.VCard.GetEmail(jabber.protocol.iq.EmailType)">
            <summary>
            Get the email address for the given type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.VCard.SetEmail(jabber.protocol.iq.VCard.VEmail)">
            <summary>
             Sets the email address for the given type.
            </summary>
            <param name="email"></param>
        </member>
        <member name="P:jabber.protocol.iq.VCard.FullName">
            <summary>
            Full name of the individual, as a single string
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.VCard.ComplexName">
            <summary>
            Pieces of the name, split apart
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.VCard.Nickname">
            <summary>
            Person's nick name.  This might be a good choice for a default roster nick,
            for instance.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.VCard.Photo">
            <summary>
            User's photograph
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.VCard.Birthday">
            <summary>
            Date of birth
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.VCard.Url">
            <summary>
            Associated URL
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.VCard.Organization">
             <summary>
            
             </summary>
        </member>
        <member name="P:jabber.protocol.iq.VCard.Title">
             <summary>
            
             </summary>
        </member>
        <member name="P:jabber.protocol.iq.VCard.Role">
             <summary>
            
             </summary>
        </member>
        <member name="P:jabber.protocol.iq.VCard.JabberId">
            <summary>
            Jabber ID
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.VCard.Description">
             <summary>
            
             </summary>
        </member>
        <member name="P:jabber.protocol.iq.VCard.Email">
            <summary>
            Get the internet email address (default)
            </summary>
            <returns></returns>
        </member>
        <member name="T:jabber.protocol.iq.VCard.VName">
             <summary>
            
             </summary>
        </member>
        <member name="M:jabber.protocol.iq.VCard.VName.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.VCard.VName.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.VCard.VName.Given">
            <summary>
            Given (first) name
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.VCard.VName.Family">
            <summary>
            Family (last) name
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.VCard.VName.Middle">
            <summary>
            Middle name
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.VCard.VOrganization">
            <summary>
            vCard Org Element
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.VCard.VOrganization.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.VCard.VOrganization.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.VCard.VOrganization.OrgName">
            <summary>
            Orginization Name
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.VCard.VOrganization.Unit">
             <summary>
            
             </summary>
        </member>
        <member name="T:jabber.protocol.iq.VCard.VTelephone">
            <summary>
            vCard Telephone Element
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.VCard.VTelephone.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.VCard.VTelephone.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.VCard.VTelephone.Number">
            <summary>
            Phone number
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.VCard.VTelephone.Type">
             <summary>
            
             </summary>
        </member>
        <member name="P:jabber.protocol.iq.VCard.VTelephone.Location">
             <summary>
            
             </summary>
        </member>
        <member name="T:jabber.protocol.iq.VCard.VAddress">
            <summary>
            vCard Address Element
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.VCard.VAddress.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.VCard.VAddress.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.VCard.VAddress.Street">
             <summary>
            
             </summary>
        </member>
        <member name="P:jabber.protocol.iq.VCard.VAddress.Locality">
             <summary>
            
             </summary>
        </member>
        <member name="P:jabber.protocol.iq.VCard.VAddress.Region">
             <summary>
            
             </summary>
        </member>
        <member name="P:jabber.protocol.iq.VCard.VAddress.PostalCode">
             <summary>
            
             </summary>
        </member>
        <member name="P:jabber.protocol.iq.VCard.VAddress.Country">
             <summary>
            
             </summary>
        </member>
        <member name="P:jabber.protocol.iq.VCard.VAddress.Extra">
             <summary>
            
             </summary>
        </member>
        <member name="P:jabber.protocol.iq.VCard.VAddress.Location">
             <summary>
            
             </summary>
        </member>
        <member name="T:jabber.protocol.iq.VCard.VEmail">
            <summary>
            vCard Email Element
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.VCard.VEmail.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.VCard.VEmail.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.VCard.VEmail.UserId">
            <summary>
            The e-mail address
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.VCard.VEmail.IsPreferred">
            <summary>
            Is this the preferred e-mail address?
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.VCard.VEmail.Type">
            <summary>
            What kind of address is this?
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.VCard.VGeo">
            <summary>
            Geographic location
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.VCard.VGeo.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.VCard.VGeo.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.VCard.VGeo.Lat">
            <summary>
            Latitude
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.VCard.VGeo.Lon">
            <summary>
            Longitude
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.VCard.VPhoto">
             <summary>
            
             </summary>
        </member>
        <member name="M:jabber.protocol.iq.VCard.VPhoto.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.VCard.VPhoto.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.VCard.VPhoto.ImageType">
            <summary>
            The MIME type of the image.  Must be set before
            calling Image.set.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.VCard.VPhoto.BinVal">
            <summary>
            The bytes associated with the picture
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.VCard.VPhoto.Image">
            <summary>
            An Image representation of the bytes in the picture.
            The MimeType MUST be set before calling set.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.PubSubEvent">
            <summary>
            Publish/Subscribe.  See XEP-60: http://www.xmpp.org/extensions/xep-0060.html
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.PubSubEvent.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.PubSubEvent.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.PubSubEvent.Command">
            <summary>
            The PubSub command associated with this instruction
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.EventRetract">
            <summary>
            Notification for item deletion.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.EventRetract.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.EventRetract.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.EventRetract.ID">
            <summary>
            When in an event, there may be an ID as an attribute.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.EventCollection">
            <summary>
            
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.PubSubCommand">
            <summary>
            A PubSub command
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.PubSubCommand.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create a pubsub command.  Should not be called directly.
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.PubSubCommand.#ctor(System.String,System.Xml.XmlElement)">
            <summary>
            Create for outbound, in the namespace of the parent element,
            then attach to the parent element.
            </summary>
            <param name="elementName">The name of the element to create</param>
            <param name="parent">The parent element</param>
        </member>
        <member name="M:jabber.protocol.iq.PubSubCommand.#ctor(System.String,System.String,System.Xml.XmlDocument)">
            <summary>
            Create a pubsub command.  Should not be called directly.
            </summary>
            <param name="prefix"></param>
            <param name="ns"></param>
            <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.PubSubCommand.Node">
            <summary>
            The node this command applies to.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.PubSubCommand.CommandType">
            <summary>
            What type of command?
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.EventCollection.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.EventCollection.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.EventCollection.CommandType">
            <summary>
            A collection notification
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.EventCollection.Associate">
            <summary>
            The new node associated with the collection
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.EventCollection.Disassociate">
            <summary>
            The node removed from the collection
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.EventAssociate">
            <summary>
            Nodes added to a collection
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.EventAssociate.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.EventAssociate.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.EventAssociate.Node">
            <summary>
            The new node name
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.EventAssociate.MetaData">
            <summary>
            An x:data form that describes the new node
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.EventDisassociate">
            <summary>
            Nodes removed from a collection
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.EventDisassociate.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.EventDisassociate.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.EventDisassociate.Node">
            <summary>
            The removed node name
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.EventItems">
            <summary>
            Pubsub items notification.  This is the main reason for XEP-60 to have been written.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.EventItems.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.EventItems.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.EventItems.GetItems">
            <summary>
            Retrieve all of the new items
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.EventItems.AddItem(System.String)">
            <summary>
            Add a new item to the list
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.EventItems.GetRetractions">
            <summary>
            Get a list of id's of deleted items.
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.EventItems.AddRetract(System.String)">
            <summary>
            Add a new item to the list
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="P:jabber.protocol.iq.EventItems.CommandType">
            <summary>
            A configuration event
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.EventConfiguration">
            <summary>
            New node configuration
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.EventConfiguration.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.EventConfiguration.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.EventConfiguration.CommandType">
            <summary>
            A configuration event
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.EventConfiguration.MetaData">
            <summary>
            An x:data form that describes the new configuration
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.EventPurge">
            <summary>
            All of the items in a node have been deleted.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.EventPurge.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.EventPurge.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.EventPurge.CommandType">
            <summary>
            A purge event
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.EventSubscription">
            <summary>
            Subscription state has changed
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.EventSubscription.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.EventSubscription.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.EventSubscription.CommandType">
            <summary>
            A subscription event
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.EventSubscription.Expiry">
            <summary>
            When does this subscription expire?  DateTime.MIN_VALUE for none.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.EventSubscription.JID">
            <summary>
            The JID of the subscriber
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.EventSubscription.SubscriptionID">
            <summary>
            The ID of the subscription
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.EventSubscription.Subscription">
            <summary>
            The subscription state
            </summary>
        </member>
        <member name="T:jabber.connection.sasl.SASLProcessorHandler">
            <summary>
            A SASL processor instance has been created.  Fill it with information, like USERNAME and PASSWORD.
            </summary>
        </member>
        <member name="T:jabber.connection.sasl.SASLException">
            <summary>
            Some sort of SASL error
            </summary>
        </member>
        <member name="M:jabber.connection.sasl.SASLException.#ctor(System.String)">
             <summary>
            
             </summary>
             <param name="message"></param>
        </member>
        <member name="M:jabber.connection.sasl.SASLException.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="T:jabber.connection.sasl.AuthenticationFailedException">
            <summary>
            Authentication failed.
            </summary>
        </member>
        <member name="M:jabber.connection.sasl.AuthenticationFailedException.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="M:jabber.connection.sasl.AuthenticationFailedException.#ctor(System.String)">
             <summary>
            
             </summary>
             <param name="message"></param>
        </member>
        <member name="T:jabber.connection.sasl.MissingDirectiveException">
            <summary>
            A required directive wasn't supplied.
            </summary>
        </member>
        <member name="M:jabber.connection.sasl.MissingDirectiveException.#ctor(System.String)">
             <summary>
            
             </summary>
             <param name="message"></param>
        </member>
        <member name="T:jabber.connection.sasl.InvalidServerChallengeException">
            <summary>
            Server sent an invalid challenge
            </summary>
        </member>
        <member name="M:jabber.connection.sasl.InvalidServerChallengeException.#ctor(System.String)">
             <summary>
            
             </summary>
             <param name="message"></param>
        </member>
        <member name="T:jabber.connection.HttpUploader">
            <summary>
            Manages HTTP Requests via XMPP (XEP-70).
            </summary>
        </member>
        <member name="M:jabber.connection.HttpUploader.Upload(System.String,System.String,System.String)">
            <summary>
            Uploads a file to a given URL and verifies the HTTP request
            through the XMPP server (XEP-0070).
            </summary>
            <param name="uri">URI to send the file to.</param>
            <param name="jid">JID to send as.</param>
            <param name="filename">File to send.</param>
        </member>
        <member name="E:jabber.connection.HttpUploader.OnUpload">
            <summary>
            Notifies the client that an upload has finished.
            </summary>
        </member>
        <member name="T:jabber.connection.HttpStanzaStream">
            <summary>
            Manages the HTTP Polling XMPP stream.
            </summary>
        </member>
        <member name="T:jabber.connection.StanzaStream">
            <summary>
            Manages the base stream for reading and writing full stanzas.
            </summary>
        </member>
        <member name="F:jabber.connection.StanzaStream.ENC">
            <summary>
            Text encoding.  Always UTF-8 for XMPP.
            </summary>
        </member>
        <member name="F:jabber.connection.StanzaStream.m_listener">
            <summary>
            Notifies the client that an event has occurred.
            </summary>
        </member>
        <member name="M:jabber.connection.StanzaStream.Create(jabber.connection.ConnectionType,jabber.connection.IStanzaEventListener)">
            <summary>
            Creates a StanzaStream.
            </summary>
            <param name="kind">Connection type, such as socket, polling, and so on.</param>
            <param name="listener">Connection event listeners.</param>
            <returns>StanzaStream used to connect to an XMPP server and send stanzas.</returns>
        </member>
        <member name="M:jabber.connection.StanzaStream.#ctor(jabber.connection.IStanzaEventListener)">
            <summary>
            Creates a new stanza stream.
            </summary>
            <param name="listener">Event listener associated with the new stanza stream.</param>
        </member>
        <member name="M:jabber.connection.StanzaStream.Connect">
            <summary>
            Starts the outbound connection to the XMPP server.
            </summary>
        </member>
        <member name="M:jabber.connection.StanzaStream.Accept">
            <summary>
            Listens for an inbound connection.  Only implemented by socket types for now.
            </summary>
        </member>
        <member name="M:jabber.connection.StanzaStream.StartTLS">
            <summary>
            Starts the TLS handshake.
            </summary>
        </member>
        <member name="M:jabber.connection.StanzaStream.StartCompression">
            <summary>
            Starts the compression on the connection.
            </summary>
        </member>
        <member name="M:jabber.connection.StanzaStream.InitializeStream">
            <summary>
            Initializes a new stream:stream.
            </summary>
        </member>
        <member name="M:jabber.connection.StanzaStream.WriteStartTag(jabber.protocol.stream.Stream)">
            <summary>
            Writes a stream:stream start tag.
            Some underlying implementations will ignore this,
            but may pull out pertinent data.
            </summary>
            <param name="stream">Stream containing the start tag.</param>
        </member>
        <member name="M:jabber.connection.StanzaStream.Write(System.Xml.XmlElement)">
            <summary>
            Writes an entire XML element.
            </summary>
            <param name="elem">XML element to write out.</param>
        </member>
        <member name="M:jabber.connection.StanzaStream.Write(System.String)">
            <summary>
            Writes a raw string.
            </summary>
            <param name="str">String to write out.</param>
        </member>
        <member name="M:jabber.connection.StanzaStream.Close(System.Boolean)">
            <summary>
            Closes the session with the XMPP server.
            </summary>
            <param name="clean">If true, send the stream:stream close packet.</param>
        </member>
        <member name="P:jabber.connection.StanzaStream.Acceptable">
            <summary>
            Determines whether or not the client can call the Accept() method.
            </summary>
        </member>
        <member name="P:jabber.connection.StanzaStream.Connected">
            <summary>
            Determines whether or not the client is connected to the XMPP server.
            </summary>
        </member>
        <member name="P:jabber.connection.StanzaStream.SupportsTLS">
            <summary>
            Determines whether or not Jabber-Net supports TLS.
            </summary>
        </member>
        <member name="P:jabber.connection.StanzaStream.SupportsCompression">
            <summary>
            Determines whether or not this stream supports compression (XEP-0138).
            </summary>
        </member>
        <member name="M:jabber.connection.HttpStanzaStream.#ctor(jabber.connection.IStanzaEventListener)">
            <summary>
            Create a new one.
            </summary>
            <param name="listener"></param>
        </member>
        <member name="M:jabber.connection.HttpStanzaStream.InitializeStream">
            <summary>
            Sets up the element stream.  This is the place to add factories.
            </summary>
        </member>
        <member name="M:jabber.connection.HttpStanzaStream.Connect">
            <summary>
            Connects the outbound socket.
            </summary>
        </member>
        <member name="M:jabber.connection.HttpStanzaStream.CreateSocket">
            <summary>
            Create a socket of the correct type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.connection.HttpStanzaStream.Accept">
            <summary>
            Listens for an inbound connection.
            </summary>
        </member>
        <member name="M:jabber.connection.HttpStanzaStream.Write(System.String)">
            <summary>
            Writes a string to the stream.
            </summary>
            <param name="str">
            The string to write; this will be transcoded to UTF-8.
            </param>
        </member>
        <member name="M:jabber.connection.HttpStanzaStream.WriteStartTag(jabber.protocol.stream.Stream)">
            <summary>
            Writes a stream:stream start tag.
            </summary>
            <param name="stream">Stream containing the stream:stream packet to send.</param>
        </member>
        <member name="M:jabber.connection.HttpStanzaStream.Write(System.Xml.XmlElement)">
            <summary>
            Writes a full stanza.
            </summary>
            <param name="elem">The stanza to write out.</param>
        </member>
        <member name="M:jabber.connection.HttpStanzaStream.Close(System.Boolean)">
            <summary>
            Closes the socket connection.
            </summary>
            <param name="clean">Sends the stream:stream close packet if true.</param>
        </member>
        <member name="M:jabber.connection.HttpStanzaStream.StartTLS">
            <summary>
            Negotiates Start-TLS with the other endpoint.
            </summary>
        </member>
        <member name="M:jabber.connection.HttpStanzaStream.bedrock#net#ISocketEventListener#OnInvalidCertificate(bedrock.net.BaseSocket,System.Security.Cryptography.X509Certificates.X509Certificate,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors)">
            <summary>
            An invalid peer certificate was sent during SSL/TLS neogtiation.
            </summary>
            <param name="sock">The socket that experienced the error</param>
            <param name="certificate">The bad certificate</param>
            <param name="chain">The chain of CAs for the cert</param>
            <param name="sslPolicyErrors">A bitfield for the erorrs in the certificate.</param>
            <returns>True if the cert should be accepted anyway.</returns>
        </member>
        <member name="P:jabber.connection.HttpStanzaStream.Socket">
            <summary>
            The underlying socket
            </summary>
        </member>
        <member name="P:jabber.connection.HttpStanzaStream.Connected">
            <summary>
            Determines whether or not the client is connected to the XMPP server.
            </summary>
        </member>
        <member name="P:jabber.connection.HttpStanzaStream.SupportsTLS">
            <summary>
            Supports Start-TLS if SSL is enabled.
            </summary>
        </member>
        <member name="T:bedrock.net.Socks4Proxy">
            <summary>
            Proxy object for sockets that want to do SOCKS4 proxying.
            </summary>
        </member>
        <member name="M:bedrock.net.Socks4Proxy.#ctor(bedrock.net.ISocketEventListener)">
            <summary>
            Wrap an existing socket event listener with a Socks5 proxy.  Make SURE to set Socket after this.
            </summary>
            <param name="chain">Event listener to pass events through to.</param>
        </member>
        <member name="M:bedrock.net.Socks4Proxy.Connect(bedrock.net.Address)">
            <summary>
            Saves the address passed in, and really connects to ProxyHost:ProxyPort to begin SOCKS5 handshake.
            </summary>
            <param name="addr"></param>
        </member>
        <member name="M:bedrock.net.Socks4Proxy.OnConnect(bedrock.net.BaseSocket)">
            <summary>
            overridden OnConnect to start off Socks5 protocol.
            </summary>
            <param name="sock"></param>
        </member>
        <member name="M:bedrock.net.Socks4Proxy.OnRead(bedrock.net.BaseSocket,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Overridden OnRead to handle 4 Socks5 states...
            </summary>
            <param name="sock"></param>
            <param name="buf"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:bedrock.net.Socks4Proxy.OnWrite(bedrock.net.BaseSocket,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Overridden OnWrite to ensure that the base only gets called when in running state.
            </summary>
            <param name="sock"></param>
            <param name="buf"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="T:bedrock.collections.IndexedTrie">
            <summary>
            A Trie that is searchable for substrings.  Uses a separate set of indexes
            to allow entry into the Trie at any point.  Yes, this
            </summary>
        </member>
        <member name="M:bedrock.collections.IndexedTrie.#ctor">
            <summary>
            Creates the indexed trie.
            </summary>
        </member>
        <member name="M:bedrock.collections.IndexedTrie.#ctor(System.Int32)">
            <summary>
            Creates the indexed trie and sets the maximum number of query results returned.
            </summary>
            <param name="maxResults">Maximum number of query results returned.</param>
        </member>
        <member name="M:bedrock.collections.IndexedTrie.IndexWalker(bedrock.collections.TrieNode,System.Object)">
            <summary>
            Traverse the trie, computing indexes.
            </summary>
            <param name="n"> </param>
            <param name="data"> </param>
        </member>
        <member name="M:bedrock.collections.IndexedTrie.Index">
            <summary>
            Computes the index.
            </summary>
        </member>
        <member name="M:bedrock.collections.IndexedTrie.CopyWalker(bedrock.collections.TrieNode,System.Object,bedrock.collections.ByteStack)">
            <summary>
            Copy the keys from the sub-tree into an ArrayList.
            </summary>
            <param name="n"> </param>
            <param name="data"> </param>
            <param name="key"> </param>
        </member>
        <member name="M:bedrock.collections.IndexedTrie.SubString(System.Byte[])">
            <summary>
            Return a list of keys that contain the given substring.
            </summary>
            <param name="lookFor">The substring to search for.</param>
        </member>
        <member name="P:bedrock.collections.IndexedTrie.MaxResults">
            <summary>
            The maximum number of results to return from any query.  This is an approximate number.
            </summary>
        </member>
        <member name="P:bedrock.collections.IndexedTrie.Item(System.Byte)">
            <summary>
            Finds the index for the given byte.
            </summary>
        </member>
        <member name="T:stringprep.XmppResource">
            <summary>
            A stringprep profile for draft-ietf-xmpp-resourceprep-02, used for Jabber resources.
            </summary>
        </member>
        <member name="M:stringprep.XmppResource.#ctor">
            <summary>
            Create an instance of an XmppResource
            </summary>
        </member>
        <member name="T:jabber.protocol.x.EventType">
            <summary>
            Types of events
            </summary>
        </member>
        <member name="F:jabber.protocol.x.EventType.NONE">
            <summary>
            No event type specified.
            </summary>
        </member>
        <member name="F:jabber.protocol.x.EventType.offline">
            <summary>
            Indicates that the message has been stored offline by the server, because the
            intended recipient is not available. This event is to be raised by the Jabber server.
            </summary>
        </member>
        <member name="F:jabber.protocol.x.EventType.delivered">
            <summary>
            Indicates that the message has been delivered to the recipient. This signifies
            that the message has reached the Jabber client, but does not necessarily mean
            that the message has been displayed. This event is to be raised by the Jabber client.
            </summary>
        </member>
        <member name="F:jabber.protocol.x.EventType.displayed">
            <summary>
            Once the message has been received by the Jabber client, it may be displayed
            to the user. This event indicates that the message has been displayed, and is
            to be raised by the Jabber client. Even if a message is displayed multiple times,
            this event should only be raised once.
            </summary>
        </member>
        <member name="F:jabber.protocol.x.EventType.composing">
            <summary>
            In threaded chat conversations, this indicates that the recipient is composing
            a reply to a message that was just sent. The event is to be raised by the Jabber
            client. A Jabber client is allowed to raise this event multiple times in response
            to the same request, providing that a specific sequence is followed.
            </summary>
        </member>
        <member name="T:jabber.protocol.x.Event">
            <summary>
            A event x element, described by XEP-0022.
            </summary>
        </member>
        <member name="M:jabber.protocol.x.Event.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.x.Event.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.x.Event.ID">
            <summary>
            The message to which this event refers.
            </summary>
        </member>
        <member name="P:jabber.protocol.x.Event.Type">
            <summary>
            The type of the event.
            </summary>
        </member>
        <member name="P:jabber.protocol.x.Event.IsOffline">
            <summary>
            Indicates that the message has been stored offline by the server, because the
            intended recipient is not available. This event is to be raised by the Jabber server.
            </summary>
        </member>
        <member name="P:jabber.protocol.x.Event.IsDelivered">
            <summary>
            Indicates that the message has been delivered to the recipient. This signifies
            that the message has reached the Jabber client, but does not necessarily mean
            that the message has been displayed. This event is to be raised by the Jabber client.
            </summary>
        </member>
        <member name="P:jabber.protocol.x.Event.IsDisplayed">
            <summary>
            Once the message has been received by the Jabber client, it may be displayed
            to the user. This event indicates that the message has been displayed, and is
            to be raised by the Jabber client. Even if a message is displayed multiple times,
            this event should only be raised once.
            </summary>
        </member>
        <member name="P:jabber.protocol.x.Event.IsComposing">
            <summary>
            In threaded chat conversations, this indicates that the recipient is composing
            a reply to a message that was just sent. The event is to be raised by the Jabber
            client. A Jabber client is allowed to raise this event multiple times in response
            to the same request, providing that a specific sequence is followed.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.PrivateIQ">
            <summary>
            Private storage IQ.
            See XEP-0049 (http://www.xmpp.org/extensions/xep-0049.html)
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.PrivateIQ.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create an IQ for the jabber:iq:private namespace.
            Make sure to add a body to the query before sending.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.Private">
            <summary>
            Private storage query.
            See XEP-0049 (http://www.xmpp.org/extensions/xep-0049.html)
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.Private.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Private.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound.
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.client.ErrorType">
            <summary>
            See RFC 3920, section 9.3.2.  These are the possible error types.
            </summary>
        </member>
        <member name="F:jabber.protocol.client.ErrorType.NONE">
            <summary>
            None specified (protocol error)
            </summary>
        </member>
        <member name="F:jabber.protocol.client.ErrorType.cancel">
            <summary>
            do not retry (the error is unrecoverable)
            </summary>
        </member>
        <member name="F:jabber.protocol.client.ErrorType.continue">
            <summary>
            proceed (the condition was only a warning)
            </summary>
        </member>
        <member name="F:jabber.protocol.client.ErrorType.modify">
            <summary>
            retry after changing the data sent
            </summary>
        </member>
        <member name="F:jabber.protocol.client.ErrorType.auth">
            <summary>
            retry after providing credentials
            </summary>
        </member>
        <member name="F:jabber.protocol.client.ErrorType.wait">
            <summary>
            retry after waiting (the error is temporary)
            </summary>
        </member>
        <member name="T:jabber.protocol.client.IQError">
            <summary>
            Error IQ
            </summary>
        </member>
        <member name="M:jabber.protocol.client.IQError.#ctor(System.Xml.XmlDocument,System.String)">
            <summary>
            Create an error IQ with the given code and message.
            </summary>
            <param name="doc"></param>
            <param name="condition"></param>
        </member>
        <member name="T:jabber.protocol.client.Error">
            <summary>
            Error in a message or IQ.
            </summary>
        </member>
        <member name="F:jabber.protocol.client.Error.BAD_REQUEST">
            <summary>
            modify      400
            </summary>
        </member>
        <member name="F:jabber.protocol.client.Error.CONFLICT">
            <summary>
            cancel      409
            </summary>
        </member>
        <member name="F:jabber.protocol.client.Error.FEATURE_NOT_IMPLEMENTED">
            <summary>
            cancel  501
            </summary>
        </member>
        <member name="F:jabber.protocol.client.Error.FORBIDDEN">
            <summary>
            auth    403
            </summary>
        </member>
        <member name="F:jabber.protocol.client.Error.GONE">
            <summary>
                modify  302 (permanent)
            </summary>
        </member>
        <member name="F:jabber.protocol.client.Error.INTERNAL_SERVER_ERROR">
            <summary>
                wait    500
            </summary>
        </member>
        <member name="F:jabber.protocol.client.Error.ITEM_NOT_FOUND">
            <summary>
                cancel  404
            </summary>
        </member>
        <member name="F:jabber.protocol.client.Error.JID_MALFORMED">
            <summary>
                modify  400
            </summary>
        </member>
        <member name="F:jabber.protocol.client.Error.NOT_ACCEPTABLE">
            <summary>
                modify  406
            </summary>
        </member>
        <member name="F:jabber.protocol.client.Error.NOT_ALLOWED">
            <summary>
                cancel  405
            </summary>
        </member>
        <member name="F:jabber.protocol.client.Error.NOT_AUTHORIZED">
            <summary>
                auth    401
            </summary>
        </member>
        <member name="F:jabber.protocol.client.Error.PAYMENT_REQUIRED">
            <summary>
                auth    402
            </summary>
        </member>
        <member name="F:jabber.protocol.client.Error.RECIPIENT_UNAVAILABLE">
            <summary>
                wait    404
            </summary>
        </member>
        <member name="F:jabber.protocol.client.Error.REDIRECT">
            <summary>
                modify  302 (temporary)
            </summary>
        </member>
        <member name="F:jabber.protocol.client.Error.REGISTRATION_REQUIRED">
            <summary>
                auth    407
            </summary>
        </member>
        <member name="F:jabber.protocol.client.Error.REMOTE_SERVER_NOT_FOUND">
            <summary>
                cancel  404
            </summary>
        </member>
        <member name="F:jabber.protocol.client.Error.REMOTE_SERVER_TIMEOUT">
            <summary>
                wait    504
            </summary>
        </member>
        <member name="F:jabber.protocol.client.Error.RESOURCE_CONSTRAINT">
            <summary>
                wait    500
            </summary>
        </member>
        <member name="F:jabber.protocol.client.Error.SERVICE_UNAVAILABLE">
            <summary>
                cancel  503
            </summary>
        </member>
        <member name="F:jabber.protocol.client.Error.SUBSCRIPTION_REQUIRED">
            <summary>
                auth    407
            </summary>
        </member>
        <member name="F:jabber.protocol.client.Error.UNDEFINED_CONDITION">
            <summary>
                [any]   500
            </summary>
        </member>
        <member name="F:jabber.protocol.client.Error.UNEXPECTED_REQUEST">
            <summary>
                wait    400
            </summary>
        </member>
        <member name="M:jabber.protocol.client.Error.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.client.Error.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.client.Error.GetStanzaError(System.Xml.XmlDocument,System.String)">
            <summary>
            Create an error element with the element name of the error condition.
            </summary>
            <param name="doc"></param>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.client.Error.GetStanzaError(System.Xml.XmlDocument,jabber.protocol.client.ErrorType,System.Int32,System.String)">
            <summary>
            Get an error element with a urn:ietf:params:xml:ns:xmpp-stanzas condition.
            Likely, you want the GetStanzaError(doc, condition) instead.
            </summary>
            <param name="doc"></param>
            <param name="type"></param>
            <param name="code"></param>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.client.Error.GetStreamError(System.Xml.XmlDocument,jabber.protocol.client.ErrorType,System.Int32,System.String)">
            <summary>
            Get an error stanza with a urn:ietf:params:xml:ns:xmpp-streams condition.
            </summary>
            <param name="doc"></param>
            <param name="type"></param>
            <param name="code"></param>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="P:jabber.protocol.client.Error.Code">
            <summary>
            The error code, as an integer.
            </summary>
        </member>
        <member name="P:jabber.protocol.client.Error.ErrorType">
            <summary>
            The type of the error
            </summary>
        </member>
        <member name="P:jabber.protocol.client.Error.Condition">
            <summary>
            The inner error condition element.
            </summary>
        </member>
        <member name="P:jabber.protocol.client.Error.Message">
            <summary>
            The error message.  Not used anymore (not I18N).
            </summary>
        </member>
        <member name="T:jabber.protocol.accept.XdbType">
            <summary>
            The type attribute
            </summary>
        </member>
        <member name="F:jabber.protocol.accept.XdbType.NONE">
            <summary>
            None specified
            </summary>
        </member>
        <member name="F:jabber.protocol.accept.XdbType.get">
            <summary>
            type='get'
            </summary>
        </member>
        <member name="F:jabber.protocol.accept.XdbType.set">
            <summary>
            type='set'
            </summary>
        </member>
        <member name="F:jabber.protocol.accept.XdbType.result">
            <summary>
            type='result'
            </summary>
        </member>
        <member name="F:jabber.protocol.accept.XdbType.error">
            <summary>
            type='error'
            </summary>
        </member>
        <member name="T:jabber.protocol.accept.XdbAction">
            <summary>
            The action attribute.
            </summary>
        </member>
        <member name="F:jabber.protocol.accept.XdbAction.NONE">
            <summary>
            None specified
            </summary>
        </member>
        <member name="F:jabber.protocol.accept.XdbAction.check">
            <summary>
            action='check'
            </summary>
        </member>
        <member name="F:jabber.protocol.accept.XdbAction.insert">
            <summary>
            action='insert'
            </summary>
        </member>
        <member name="T:jabber.protocol.accept.Xdb">
            <summary>
            The XDB packet.
            </summary>
        </member>
        <member name="M:jabber.protocol.accept.Xdb.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.accept.Xdb.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.accept.Xdb.Contents">
            <summary>
            The contents of the XDB packet
            </summary>
        </member>
        <member name="P:jabber.protocol.accept.Xdb.Type">
            <summary>
            The type attribute
            </summary>
        </member>
        <member name="P:jabber.protocol.accept.Xdb.Action">
            <summary>
            The action attribute
            </summary>
        </member>
        <member name="P:jabber.protocol.accept.Xdb.NS">
            <summary>
            The namespace to store/retrive from.
            </summary>
        </member>
        <member name="T:jabber.client.PrimarySessionHandler">
            <summary>
            Informs the client of a change of derived primary session for a user.
            </summary>
            <param name="sender">The PresenceManager object that sent the update</param>
            <param name="bare">The bare JID (node@domain) of the user whose presence changed</param>
        </member>
        <member name="T:jabber.client.PresenceManager">
            <summary>
            Specifies the presence proxy database.
            </summary>
        </member>
        <member name="F:jabber.client.PresenceManager.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:jabber.client.PresenceManager.#ctor(System.ComponentModel.IContainer)">
            <summary>
            Constructs a PresenceManager object and adds it to a container.
            </summary>
            <param name="container">Parent container.</param>
        </member>
        <member name="M:jabber.client.PresenceManager.#ctor">
            <summary>
            Constructs a new PresenceManager object.
            </summary>
        </member>
        <member name="M:jabber.client.PresenceManager.ToString">
            <summary>
            Gets the current presence state as a string.
            </summary>
            <returns>string in the format '{bare JID}={list of presence stanzas}, ...'</returns>
        </member>
        <member name="M:jabber.client.PresenceManager.AddPresence(jabber.protocol.client.Presence)">
            <summary>
            Adds a new available or unavailable presence packet to the database.
            </summary>
            <param name="p">Presence stanza to add.</param>
        </member>
        <member name="M:jabber.client.PresenceManager.IsAvailable(jabber.JID)">
            <summary>
            Determines if a specified JID is online with any resources.
            This performs better than retrieving the particular associated presence packet.
            </summary>
            <param name="jid">The JID to look up.</param>
            <returns>If true, the user is online; otherwise the user is offline</returns>
        </member>
        <member name="M:jabber.client.PresenceManager.GetFeatures(jabber.JID)">
            <summary>
            Get the features associated with the JID.  If a bare JID is passed in, this will be 
            a union of all of the features for all of the resources of this user.  Otherwise,
            it will be the features for the given resource.
            
            Requires a CapsManager to be set before use.
            </summary>
            <param name="jid"></param>
            <returns>Null if no features are known.</returns>
        </member>
        <member name="M:jabber.client.PresenceManager.HasFeature(jabber.JID,System.String)">
            <summary>
            Does the given JID implement the given feature?  Bare JID asks if any
            resource of that user implements that feature.  Full JID asks if the
            given resource implements that feature.
            
            Requires a CapsManager to be set before use.
            </summary>
            <param name="jid"></param>
            <param name="featureURI"></param>
            <returns>True if the feaure is implemented</returns>
        </member>
        <member name="M:jabber.client.PresenceManager.GetFeatureJID(jabber.JID,System.String)">
            <summary>
            Get the most available full JID that implements the given feature.  Unlike
            most routines in PresenceManager, may also return JIDs that have negative
            presence.  If a full JID is specified, this is effectively the same as
            HasFeature, but null will be returned if the feature isn't implemented.
            
            </summary>
            <param name="jid"></param>
            <param name="featureURI"></param>
            <returns>null if none found</returns>
        </member>
        <member name="M:jabber.client.PresenceManager.GetAll(jabber.JID)">
            <summary>
            Gets all of the current presence stanzas for the given user.
            </summary>
            <param name="jid">User who's presence stanzas you want.</param>
            <returns>Array of presence stanzas for the given user.</returns>
        </member>
        <member name="M:jabber.client.PresenceManager.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="M:jabber.client.PresenceManager.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Iterate over all of the JIDs we have not-unavilable presence from.
            </summary>
            <returns></returns>
        </member>
        <member name="P:jabber.client.PresenceManager.Client">
            <summary>
            Gets or sets the JabberClient associated with the Presence Manager.
            </summary>
        </member>
        <member name="P:jabber.client.PresenceManager.CapsManager">
            <summary>
            The CapsManager for this view
            </summary>
        </member>
        <member name="E:jabber.client.PresenceManager.OnPrimarySessionChange">
            <summary>
            Informs the client that the primary session has changed for a user.
            </summary>
        </member>
        <member name="P:jabber.client.PresenceManager.Item(jabber.JID)">
            <summary>
            Gets the primary presence if given a bare JID.
            If given a FQJ, returns the associated presence.
            </summary>
        </member>
        <member name="T:jabber.client.PresenceManager.UserPresenceManager">
             <summary>
             Manage the presence for all of the resources of a user.  No locking is performed,
             since PresenceManager is already doing locking.
            
             The intent of this class is to be able to deliver the last presence stanza
             from the "most available" resource.
             Note that negative priority sessions are never the most available.
             </summary>
        </member>
        <member name="T:bedrock.net.SocketWatcher">
            <summary>
            A collection of sockets.  This makes a lot more sense in the poll() version (Unix/C) since
            you need to have a place to collect all of the sockets and call poll().  Here, it's just
            convenience functions.
            </summary>
        </member>
        <member name="M:bedrock.net.SocketWatcher.#ctor">
            <summary>
            Create a new instance, which will manage an unlimited number of sockets.
            </summary>
        </member>
        <member name="M:bedrock.net.SocketWatcher.#ctor(System.Int32)">
            <summary>
            Create a new instance.
            </summary>
            <param name="maxsockets">Maximum number of sockets to watch.  In this version,
            this is mostly for rate-limiting purposes.</param>
        </member>
        <member name="M:bedrock.net.SocketWatcher.SetCertificateFile(System.String,System.String)">
            <summary>
            Set the certificate to be used for accept sockets.  To generate a test .pfx file using openssl,
            add this to openssl.conf:
              <blockquote>
              [ serverex ]
              extendedKeyUsage=1.3.6.1.5.5.7.3.1
              </blockquote>
            and run the following commands:
              <blockquote>
              openssl req -new -x509 -newkey rsa:1024 -keyout privkey.pem -out key.pem -extensions serverex
              openssl pkcs12 -export -in key.pem -inkey privkey.pem -name localhost -out localhost.pfx
              </blockquote>
            If you leave the certificate null, and you are doing Accept, the SSL class will try to find a
            default server cert on your box.  If you have IIS installed with a cert, this might just go...
            </summary>
            <param name="filename">A .pfx or .cer file</param>
            <param name="password">The password, if this is a .pfx file, null if .cer file.</param>
        </member>
        <member name="M:bedrock.net.SocketWatcher.SetCertificateStore(System.Security.Cryptography.X509Certificates.StoreName)">
            <summary>
            Set the certificate from a system store.  Try "MY" for the ones listed in IE.
            </summary>
            <param name="storeName"></param>
        </member>
        <member name="M:bedrock.net.SocketWatcher.CreateListenSocket(bedrock.net.ISocketEventListener,bedrock.net.Address,System.Int32,System.Boolean)">
            <summary>
            Create a socket that is listening for inbound connections.
            </summary>
            <param name="listener">Where to send notifications</param>
            <param name="addr">Address to connect to</param>
            <param name="backlog">The maximum length of the queue of pending connections</param>
            <param name="SSL">Do SSL3/TLS1 on connect</param>
            <returns>A socket that is ready for calling RequestAccept()</returns>
        </member>
        <member name="M:bedrock.net.SocketWatcher.CreateListenSocket(bedrock.net.ISocketEventListener,bedrock.net.Address,System.Boolean)">
            <summary>
            Create a socket that is listening for inbound connections.
            </summary>
            <param name="listener">Where to send notifications</param>
            <param name="addr">Address to connect to</param>
            <param name="SSL">Do SSL3/TLS1 on connect</param>
            <returns>A socket that is ready for calling RequestAccept()</returns>
        </member>
        <member name="M:bedrock.net.SocketWatcher.CreateListenSocket(bedrock.net.ISocketEventListener,bedrock.net.Address)">
            <summary>
            Create a socket that is listening for inbound connections, with no SSL/TLS.
            </summary>
            <param name="listener">Where to send notifications</param>
            <param name="addr">Address to connect to</param>
            <returns>A socket that is ready for calling RequestAccept()</returns>
        </member>
        <member name="M:bedrock.net.SocketWatcher.CreateListenSocket(bedrock.net.ISocketEventListener,bedrock.net.Address,System.Int32)">
            <summary>
            Create a socket that is listening for inbound connections, with no SSL/TLS.
            </summary>
            <param name="listener">Where to send notifications</param>
            <param name="addr">Address to connect to</param>
            <param name="backlog">The maximum length of the queue of pending connections</param>
            <returns>A socket that is ready for calling RequestAccept()</returns>
        </member>
        <member name="M:bedrock.net.SocketWatcher.CreateConnectSocket(bedrock.net.ISocketEventListener,bedrock.net.Address)">
            <summary>
            Create an outbound socket.
            </summary>
            <param name="listener">Where to send notifications</param>
            <param name="addr">Address to connect to</param>
            <returns>Socket that is in the process of connecting</returns>
        </member>
        <member name="M:bedrock.net.SocketWatcher.CreateConnectSocket(bedrock.net.ISocketEventListener,bedrock.net.Address,System.Boolean,System.String)">
            <summary>
            Create an outbound socket.
            </summary>
            <param name="listener">Where to send notifications</param>
            <param name="addr">Address to connect to</param>
            <param name="SSL">Do SSL3/TLS1 on startup</param>
            <param name="hostId">The logical name of the host to connect to, for SSL/TLS purposes.</param>
            <returns>Socket that is in the process of connecting</returns>
        </member>
        <member name="M:bedrock.net.SocketWatcher.RegisterSocket(bedrock.net.AsyncSocket)">
            <summary>
            Called by AsyncSocket when a new connection is received on a listen socket.
            </summary>
            <param name="s">New socket connection</param>
        </member>
        <member name="M:bedrock.net.SocketWatcher.CleanupSocket(bedrock.net.AsyncSocket)">
            <summary>
            Called by AsyncSocket when a socket is closed.
            </summary>
            <param name="s">Closed socket</param>
        </member>
        <member name="M:bedrock.net.SocketWatcher.PendingAccept(bedrock.net.AsyncSocket)">
            <summary>
            Called by AsyncSocket when this class is full, and the listening AsyncSocket
            socket would like to be restarted when there are slots free.
            </summary>
            <param name="s">Listening socket</param>
        </member>
        <member name="M:bedrock.net.SocketWatcher.Dispose">
            <summary>
            Or close.  Potato, tomato.  This is useful if you want to use using().
            </summary>
        </member>
        <member name="P:bedrock.net.SocketWatcher.Synchronous">
            <summary>
            Synchronous operation
            </summary>
        </member>
        <member name="P:bedrock.net.SocketWatcher.MaxSockets">
            <summary>
            The maximum number of sockets watched.  Throws
            InvalidOperationException if the new value is fewer than the number
            currently open.  -1 means no limit.
            </summary>
        </member>
        <member name="P:bedrock.net.SocketWatcher.LocalCertificate">
            <summary>
            The certificate to be used for the local side of sockets, with SSL on.
            </summary>
        </member>
        <member name="P:bedrock.net.SocketWatcher.RequireClientCert">
            <summary>
            Does the server require a client cert?  If not, the client cert won't be sent.
            </summary>
        </member>
        <member name="T:bedrock.net.AddressResolved">
            <summary>
            Callback for async DNS lookups.
            </summary>
        </member>
        <member name="T:bedrock.net.Address">
            <summary>
            Encapsulation and caching of IP address information.  Very similar to System.Net.IPEndPoint,
            but adds async DNS lookups.
            TODO: add SRV?
            </summary>
        </member>
        <member name="M:bedrock.net.Address.#ctor(System.Int32)">
            <summary>
            Address for a server, corresponding to IPAddress.Any.
            </summary>
            <param name="port"></param>
        </member>
        <member name="M:bedrock.net.Address.#ctor(System.String,System.Int32)">
            <summary>
            New connection endpoint.
            </summary>
            <param name="hostname">Host name or dotted-quad IP address</param>
            <param name="port">Port number</param>
        </member>
        <member name="M:bedrock.net.Address.#ctor(System.Net.IPAddress,System.Int32)">
            <summary>
            Create a new connection endpoint, where the IP address is already known.
            </summary>
            <param name="ip"></param>
            <param name="port"></param>
        </member>
        <member name="M:bedrock.net.Address.LookupSRV(System.String,System.String,System.String@,System.Int32@)">
            <summary>
            Look up a DNS SRV record, returning the best host and port number to connect to.
            </summary>
            <param name="prefix">The SRV prefix, ending with a dot.  Example: "_xmpp-client._tcp."</param>
            <param name="domain">The domain to check</param>
            <param name="host">The host name to connect to</param>
            <param name="port">The port number to connect to</param>
        </member>
        <member name="M:bedrock.net.Address.LookupTXT(System.String,System.String,System.String)">
            <summary>
            Look up a DNS TXT record.
            </summary>
            <param name="prefix">The prefix, ending in '.'.  Example: "_xmppconnect."</param>
            <param name="domain">The domain to search</param>
            <param name="attribute">The attribute name to look for.  Example: "_xmpp-client-xbosh"</param>
            <returns></returns>
        </member>
        <member name="M:bedrock.net.Address.Resolve(bedrock.net.AddressResolved)">
            <summary>
            Async DNS lookup.  IP will be null in callback on failure.  Callback will
            be called immediately if IP is already known (e.g. dotted-quad).
            </summary>
            <param name="callback">Called when resolution complete.</param>
        </member>
        <member name="M:bedrock.net.Address.Resolve">
            <summary>
            Synchronous DNS lookup.
            </summary>
        </member>
        <member name="M:bedrock.net.Address.OnResolved(System.IAsyncResult)">
            <summary>
            Handle the async DNS response.
            </summary>
            <param name="ar"></param>
        </member>
        <member name="M:bedrock.net.Address.ToString">
            <summary>
            Readable representation of the address.
            Host (IP):port
            </summary>
            <returns></returns>
        </member>
        <member name="P:bedrock.net.Address.Hostname">
            <summary>
            The host name.  When set, checks for dotted-quad representation, to avoid
            async DNS call when possible.
            </summary>
        </member>
        <member name="P:bedrock.net.Address.Port">
            <summary>
            Port number.
            TODO: add string version that looks in /etc/services (or equiv)?
            </summary>
        </member>
        <member name="P:bedrock.net.Address.IP">
            <summary>
            The binary IP address.  Gives IPAddress.Any if resolution hasn't occured, and
            null if resolution failed.
            </summary>
        </member>
        <member name="P:bedrock.net.Address.Service">
            <summary>
            Not implemented yet.
            </summary>
        </member>
        <member name="P:bedrock.net.Address.Endpoint">
            <summary>
            An IPEndPoint for making socket connections with.
            </summary>
        </member>
        <member name="T:xpnet.TOK">
            <summary>
            Tokens that might have been found
            </summary>
        </member>
        <member name="F:xpnet.TOK.DATA_CHARS">
            Represents one or more characters of data.
        </member>
        <member name="F:xpnet.TOK.DATA_NEWLINE">
            Represents a newline (CR, LF or CR followed by LF) in data.
        </member>
        <member name="F:xpnet.TOK.START_TAG_NO_ATTS">
            Represents a complete start-tag <code>&lt;name&gt;</code>,
            that doesn't have any attribute specifications.
        </member>
        <member name="F:xpnet.TOK.START_TAG_WITH_ATTS">
            Represents a complete start-tag <code>&lt;name
            att="val"&gt;</code>, that contains one or more
            attribute specifications.
        </member>
        <member name="F:xpnet.TOK.EMPTY_ELEMENT_NO_ATTS">
            Represents an empty element tag <code>&lt;name/&gt;</code>,
            that doesn't have any attribute specifications.
        </member>
        <member name="F:xpnet.TOK.EMPTY_ELEMENT_WITH_ATTS">
            Represents an empty element tag <code>&lt;name
            att="val"/&gt;</code>, that contains one or more
            attribute specifications.
        </member>
        <member name="F:xpnet.TOK.END_TAG">
            Represents a complete end-tag <code>&lt;/name&gt;</code>.
        </member>
        <member name="F:xpnet.TOK.CDATA_SECT_OPEN">
            Represents the start of a CDATA section
            <code>&lt;![CDATA[</code>.
        </member>
        <member name="F:xpnet.TOK.CDATA_SECT_CLOSE">
            Represents the end of a CDATA section <code>]]&gt;</code>.
        </member>
        <member name="F:xpnet.TOK.ENTITY_REF">
            Represents a general entity reference.
        </member>
        <member name="F:xpnet.TOK.MAGIC_ENTITY_REF">
            Represents a general entity reference to a one of the 5
            predefined entities <code>amp</code>, <code>lt</code>,
            <code>gt</code>, <code>quot</code>, <code>apos</code>.
        </member>
        <member name="F:xpnet.TOK.CHAR_REF">
            Represents a numeric character reference (decimal or
            hexadecimal), when the referenced character is less
            than or equal to 0xFFFF and so is represented by a
            single char.
        </member>
        <member name="F:xpnet.TOK.CHAR_PAIR_REF">
            Represents a numeric character reference (decimal or
            hexadecimal), when the referenced character is greater
            than 0xFFFF and so is represented by a pair of chars.
        </member>
        <member name="F:xpnet.TOK.PI">
            Represents a processing instruction.
        </member>
        <member name="F:xpnet.TOK.XML_DECL">
            Represents an XML declaration or text declaration (a
            processing instruction whose target is
            <code>xml</code>).
        </member>
        <member name="F:xpnet.TOK.COMMENT">
            Represents a comment <code>&lt;!-- comment --&gt;</code>.
            This can occur both in the prolog and in content.
        </member>
        <member name="F:xpnet.TOK.ATTRIBUTE_VALUE_S">
            Represents a white space character in an attribute
            value, excluding white space characters that are part
            of line boundaries.
        </member>
        <member name="F:xpnet.TOK.PARAM_ENTITY_REF">
            Represents a parameter entity reference in the prolog.
        </member>
        <member name="F:xpnet.TOK.PROLOG_S">
            Represents whitespace in the prolog.
            The token contains one or more whitespace characters.
        </member>
        <member name="F:xpnet.TOK.DECL_OPEN">
            Represents <code>&lt;!NAME</code> in the prolog.
        </member>
        <member name="F:xpnet.TOK.DECL_CLOSE">
            Represents <code>&gt;</code> in the prolog.
        </member>
        <member name="F:xpnet.TOK.NAME">
            Represents a name in the prolog.
        </member>
        <member name="F:xpnet.TOK.NMTOKEN">
            Represents a name token in the prolog that is not a name.
        </member>
        <member name="F:xpnet.TOK.POUND_NAME">
            Represents <code>#NAME</code> in the prolog.
        </member>
        <member name="F:xpnet.TOK.OR">
            Represents <code>|</code> in the prolog.
        </member>
        <member name="F:xpnet.TOK.PERCENT">
            Represents a <code>%</code> in the prolog that does not start
            a parameter entity reference.
            This can occur in an entity declaration.
        </member>
        <member name="F:xpnet.TOK.OPEN_PAREN">
            Represents a <code>(</code> in the prolog.
        </member>
        <member name="F:xpnet.TOK.CLOSE_PAREN">
            Represents a <code>)</code> in the prolog that is not
            followed immediately by any of
             <code>*</code>, <code>+</code> or <code>?</code>.
        </member>
        <member name="F:xpnet.TOK.OPEN_BRACKET">
            Represents <code>[</code> in the prolog.
        </member>
        <member name="F:xpnet.TOK.CLOSE_BRACKET">
            Represents <code>]</code> in the prolog.
        </member>
        <member name="F:xpnet.TOK.LITERAL">
            Represents a literal (EntityValue, AttValue, SystemLiteral or
            PubidLiteral).
        </member>
        <member name="F:xpnet.TOK.NAME_QUESTION">
            Represents a name followed immediately by <code>?</code>.
        </member>
        <member name="F:xpnet.TOK.NAME_ASTERISK">
            Represents a name followed immediately by <code>*</code>.
        </member>
        <member name="F:xpnet.TOK.NAME_PLUS">
            Represents a name followed immediately by <code>+</code>.
        </member>
        <member name="F:xpnet.TOK.COND_SECT_OPEN">
            Represents <code>&lt;![</code> in the prolog.
        </member>
        <member name="F:xpnet.TOK.COND_SECT_CLOSE">
            Represents <code>]]&gt;</code> in the prolog.
        </member>
        <member name="F:xpnet.TOK.CLOSE_PAREN_QUESTION">
            Represents <code>)?</code> in the prolog.
        </member>
        <member name="F:xpnet.TOK.CLOSE_PAREN_ASTERISK">
            Represents <code>)*</code> in the prolog.
        </member>
        <member name="F:xpnet.TOK.CLOSE_PAREN_PLUS">
            Represents <code>)+</code> in the prolog.
        </member>
        <member name="F:xpnet.TOK.COMMA">
            Represents <code>,</code> in the prolog.
        </member>
        <member name="T:xpnet.Encoding">
            <summary>
            Base tokenizer class
            </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_LEAD2">
            <summary>
            Need more bytes
            </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_LEAD3">
            <summary>
            Need more bytes
            </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_LEAD4">
            <summary>
            Need more bytes
            </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_NONXML">
            <summary>
            Not XML
            </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_MALFORM">
            <summary>
            Malformed XML
            </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_LT">
            <summary>
            Less than
            </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_AMP">
            <summary>
            Ampersand
            </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_RSQB">
            <summary>
            right square bracket
            </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_CR">
            <summary>
            carriage return
            </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_LF">
            <summary>
            line feed
            </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_GT">
            <summary>
            greater than
            </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_QUOT">
            <summary>
            Quote
            </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_APOS">
            <summary>
            Apostrophe
            </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_EQUALS">
            <summary>
            Equal sign
            </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_QUEST">
            <summary>
            Question mark
            </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_EXCL">
            <summary>
            Exclamation point
            </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_SOL">
            <summary>
            Solidus (/)
            </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_SEMI">
            <summary>
            Semicolon
            </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_NUM">
            <summary>
            Hash
            </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_LSQB">
            <summary>
            Left square bracket
            </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_S">
            <summary>
            space
            </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_NMSTRT">
             <summary>
            
             </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_NAME">
             <summary>
            
             </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_MINUS">
            <summary>
            Minus
            </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_OTHER">
            <summary>
            Other
            </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_PERCNT">
            <summary>
            Percent
            </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_LPAR">
            <summary>
            Left paren
            </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_RPAR">
            <summary>
            Right paren
            </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_AST">
             <summary>
            
             </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_PLUS">
            <summary>
            +
            </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_COMMA">
            <summary>
            ,
            </summary>
        </member>
        <member name="F:xpnet.Encoding.BT_VERBAR">
            <summary>
            Pipe
            </summary>
        </member>
        <member name="F:xpnet.Encoding.asciiTypeTable">
            <summary>
            What syntax do each of the ASCII7 characters have?
            </summary>
        </member>
        <member name="M:xpnet.Encoding.convert(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
             <summary>
            
             </summary>
             <param name="sourceBuf"></param>
             <param name="sourceStart"></param>
             <param name="sourceEnd"></param>
             <param name="targetBuf"></param>
             <param name="targetStart"></param>
             <returns></returns>
        </member>
        <member name="M:xpnet.Encoding.#ctor(System.Int32)">
            <summary>
            Constructor called by subclasses to set the minimum bytes per character
            </summary>
            <param name="minBPC"></param>
        </member>
        <member name="M:xpnet.Encoding.byteType(System.Byte[],System.Int32)">
            <summary>
            Get the byte type of the next byte.  There are guaranteed to be minBPC available bytes starting at off.
            </summary>
            <param name="buf"></param>
            <param name="off"></param>
            <returns></returns>
        </member>
        <member name="M:xpnet.Encoding.byteToAscii(System.Byte[],System.Int32)">
            <summary>
            Really only works for ASCII7.
            </summary>
            <param name="buf"></param>
            <param name="off"></param>
            <returns></returns>
        </member>
        <member name="M:xpnet.Encoding.charMatches(System.Byte[],System.Int32,System.Char)">
            <summary>
            This must only be called when c is an (XML significant)
            ASCII character.
            </summary>
            <param name="buf"></param>
            <param name="off"></param>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:xpnet.Encoding.byteType2(System.Byte[],System.Int32)">
            <summary>
            Called only when byteType(buf, off) == BT_LEAD2
            </summary>
            <param name="buf"></param>
            <param name="off"></param>
            <returns></returns>
        </member>
        <member name="M:xpnet.Encoding.byteType3(System.Byte[],System.Int32)">
            <summary>
            Called only when byteType(buf, off) == BT_LEAD3
            </summary>
            <param name="buf"></param>
            <param name="off"></param>
            <returns></returns>
        </member>
        <member name="M:xpnet.Encoding.byteType4(System.Byte[],System.Int32)">
            <summary>
            Called only when byteType(buf, off) == BT_LEAD4
            </summary>
            <param name="buf"></param>
            <param name="off"></param>
            <returns></returns>
        </member>
        <member name="M:xpnet.Encoding.movePosition(System.Byte[],System.Int32,System.Int32,xpnet.Position)">
            Moves a position forward.  On entry, <code>pos</code> gives
            the position of the byte at index <code>off</code> in
            <code>buf</code>.  On exit, it <code>pos</code> will give
            the position of the byte at index <code>end</code>, which
            must be greater than or equal to <code>off</code>.  The
            bytes between <code>off</code> and <code>end</code> must
            encode one or more complete characters.  A carriage return
            followed by a line feed will be treated as a single line
            delimiter provided that they are given to
            <code>movePosition</code> together.
        </member>
        <member name="M:xpnet.Encoding.tokenizeCdataSection(System.Byte[],System.Int32,System.Int32,xpnet.Token)">
             Scans the first token of a byte subarrary that starts with the
             content of a CDATA section.
             Returns one of the following integers according to the type of token
             that the subarray starts with:
             <ul>
             <li><code>TOK.DATA_CHARS</code></li>
             <li><code>TOK.DATA_NEWLINE</code></li>
             <li><code>TOK.CDATA_SECT_CLOSE</code></li>
             </ul>
             <p>
             Information about the token is stored in <code>token</code>.
             </p>
             After <code>TOK.CDATA_SECT_CLOSE</code> is returned, the application
             should use <code>tokenizeContent</code>.
            
             @exception EmptyTokenException if the subarray is empty
             @exception PartialTokenException if the subarray contains only part of
             a legal token
             @exception InvalidTokenException if the subarrary does not start
             with a legal token or part of one
             @exception ExtensibleTokenException if the subarray encodes just a carriage
             return ('\r')
            
             @see #TOK.DATA_CHARS
             @see #TOK.DATA_NEWLINE
             @see #TOK.CDATA_SECT_CLOSE
             @see Token
             @see EmptyTokenException
             @see PartialTokenException
             @see InvalidTokenException
             @see ExtensibleTokenException
             @see #tokenizeContent
        </member>
        <member name="M:xpnet.Encoding.tokenizeContent(System.Byte[],System.Int32,System.Int32,xpnet.ContentToken)">
             Scans the first token of a byte subarrary that contains content.
             Returns one of the following integers according to the type of token
             that the subarray starts with:
             <ul>
             <li><code>TOK.START_TAG_NO_ATTS</code></li>
             <li><code>TOK.START_TAG_WITH_ATTS</code></li>
             <li><code>TOK.EMPTY_ELEMENT_NO_ATTS</code></li>
             <li><code>TOK.EMPTY_ELEMENT_WITH_ATTS</code></li>
             <li><code>TOK.END_TAG</code></li>
             <li><code>TOK.DATA_CHARS</code></li>
             <li><code>TOK.DATA_NEWLINE</code></li>
             <li><code>TOK.CDATA_SECT_OPEN</code></li>
             <li><code>TOK.ENTITY_REF</code></li>
             <li><code>TOK.MAGIC_ENTITY_REF</code></li>
             <li><code>TOK.CHAR_REF</code></li>
             <li><code>TOK.CHAR_PAIR_REF</code></li>
             <li><code>TOK.PI</code></li>
             <li><code>TOK.XML_DECL</code></li>
             <li><code>TOK.COMMENT</code></li>
             </ul>
             <p>
             Information about the token is stored in <code>token</code>.
             </p>
             When <code>TOK.CDATA_SECT_OPEN</code> is returned,
             <code>tokenizeCdataSection</code> should be called until
             it returns <code>TOK.CDATA_SECT</code>.
            
             @exception EmptyTokenException if the subarray is empty
             @exception PartialTokenException if the subarray contains only part of
             a legal token
             @exception InvalidTokenException if the subarrary does not start
             with a legal token or part of one
             @exception ExtensibleTokenException if the subarray encodes just a carriage
             return ('\r')
            
             @see #TOK.START_TAG_NO_ATTS
             @see #TOK.START_TAG_WITH_ATTS
             @see #TOK.EMPTY_ELEMENT_NO_ATTS
             @see #TOK.EMPTY_ELEMENT_WITH_ATTS
             @see #TOK.END_TAG
             @see #TOK.DATA_CHARS
             @see #TOK.DATA_NEWLINE
             @see #TOK.CDATA_SECT_OPEN
             @see #TOK.ENTITY_REF
             @see #TOK.MAGIC_ENTITY_REF
             @see #TOK.CHAR_REF
             @see #TOK.CHAR_PAIR_REF
             @see #TOK.PI
             @see #TOK.XML_DECL
             @see #TOK.COMMENT
             @see ContentToken
             @see EmptyTokenException
             @see PartialTokenException
             @see InvalidTokenException
             @see ExtensibleTokenException
             @see #tokenizeCdataSection
        </member>
        <member name="M:xpnet.Encoding.getInitialEncoding(System.Byte[],System.Int32,System.Int32,xpnet.Token)">
             Returns an encoding object to be used to start parsing an
             external entity.  The encoding is chosen based on the
             initial 4 bytes of the entity.
            
             @param buf the byte array containing the initial bytes of
             the entity @param off the index in <code>buf</code> of the
             first byte of the entity @param end the index in
             <code>buf</code> following the last available byte of the
             entity; <code>end - off</code> must be greater than or
             equal to 4 unless the entity has fewer that 4 bytes, in
             which case it must be equal to the length of the entity
             @param token receives information about the presence of a
             byte order mark; if the entity starts with a byte order
             mark then <code>token.getTokenEnd()</code> will return
             <code>off + 2</code>, otherwise it will return
             <code>off</code>
            
             @see TextDecl
             @see XmlDecl
             @see #TOK.XML_DECL
             @see #getEncoding
             @see #getInternalEncoding
        </member>
        <member name="M:xpnet.Encoding.getEncoding(System.String)">
            Returns an <code>Encoding</code> corresponding to the
            specified IANA character set name.  Returns this
            <code>Encoding</code> if the name is null.  Returns null if
            the specified encoding is not supported.  Note that there
            are two distinct <code>Encoding</code> objects associated
            with the name <code>UTF-16</code>, one for each possible
            byte order; if this <code>Encoding</code> is UTF-16 with
            little-endian byte ordering, then
            <code>getEncoding("UTF-16")</code> will return this,
            otherwise it will return an <code>Encoding</code> for
            UTF-16 with big-endian byte ordering.  @param name a string
            specifying the IANA name of the encoding; this is case
            insensitive
        </member>
        <member name="M:xpnet.Encoding.getSingleByteEncoding(System.String)">
            Returns an <code>Encoding</code> for entities encoded with
            a single-byte encoding (an encoding in which each byte
            represents exactly one character).  @param map a string
            specifying the character represented by each byte; the
            string must have a length of 256;
            <code>map.charAt(b)</code> specifies the character encoded
            by byte <code>b</code>; bytes that do not represent any
            character should be mapped to <code>\uFFFD</code>
        </member>
        <member name="M:xpnet.Encoding.getInternalEncoding">
            Returns an <code>Encoding</code> object for use with
            internal entities.  This is a UTF-16 big endian encoding,
            except that newlines are assumed to have been normalized
            into line feed, so carriage return is treated like a space.
        </member>
        <member name="M:xpnet.Encoding.tokenizeProlog(System.Byte[],System.Int32,System.Int32,xpnet.Token)">
            Scans the first token of a byte subarray that contains part of a
            prolog.
            Returns one of the following integers according to the type of token
            that the subarray starts with:
            <ul>
            <li><code>TOK.PI</code></li>
            <li><code>TOK.XML_DECL</code></li>
            <li><code>TOK.COMMENT</code></li>
            <li><code>TOK.PARAM_ENTITY_REF</code></li>
            <li><code>TOK.PROLOG_S</code></li>
            <li><code>TOK.DECL_OPEN</code></li>
            <li><code>TOK.DECL_CLOSE</code></li>
            <li><code>TOK.NAME</code></li>
            <li><code>TOK.NMTOKEN</code></li>
            <li><code>TOK.POUND_NAME</code></li>
            <li><code>TOK.OR</code></li>
            <li><code>TOK.PERCENT</code></li>
            <li><code>TOK.OPEN_PAREN</code></li>
            <li><code>TOK.CLOSE_PAREN</code></li>
            <li><code>TOK.OPEN_BRACKET</code></li>
            <li><code>TOK.CLOSE_BRACKET</code></li>
            <li><code>TOK.LITERAL</code></li>
            <li><code>TOK.NAME_QUESTION</code></li>
            <li><code>TOK.NAME_ASTERISK</code></li>
            <li><code>TOK.NAME_PLUS</code></li>
            <li><code>TOK.COND_SECT_OPEN</code></li>
            <li><code>TOK.COND_SECT_CLOSE</code></li>
            <li><code>TOK.CLOSE_PAREN_QUESTION</code></li>
            <li><code>TOK.CLOSE_PAREN_ASTERISK</code></li>
            <li><code>TOK.CLOSE_PAREN_PLUS</code></li>
            <li><code>TOK.COMMA</code></li>
            </ul>
            @exception EmptyTokenException if the subarray is empty
            @exception PartialTokenException if the subarray contains only part of
            a legal token
            @exception InvalidTokenException if the subarrary does not start
            with a legal token or part of one
            @exception EndOfPrologException if the subarray starts with the document
            element; <code>tokenizeContent</code> should be used on the remainder
            of the entity
            @exception ExtensibleTokenException if the subarray is a legal token
            but subsequent bytes in the same entity could be part of the token
            @see #TOK.PI
            @see #TOK.XML_DECL
            @see #TOK.COMMENT
            @see #TOK.PARAM_ENTITY_REF
            @see #TOK.PROLOG_S
            @see #TOK.DECL_OPEN
            @see #TOK.DECL_CLOSE
            @see #TOK.NAME
            @see #TOK.NMTOKEN
            @see #TOK.POUND_NAME
            @see #TOK.OR
            @see #TOK.PERCENT
            @see #TOK.OPEN_PAREN
            @see #TOK.CLOSE_PAREN
            @see #TOK.OPEN_BRACKET
            @see #TOK.CLOSE_BRACKET
            @see #TOK.LITERAL
            @see #TOK.NAME_QUESTION
            @see #TOK.NAME_ASTERISK
            @see #TOK.NAME_PLUS
            @see #TOK.COND_SECT_OPEN
            @see #TOK.COND_SECT_CLOSE
            @see #TOK.CLOSE_PAREN_QUESTION
            @see #TOK.CLOSE_PAREN_ASTERISK
            @see #TOK.CLOSE_PAREN_PLUS
            @see #TOK.COMMA
            @see ContentToken
            @see EmptyTokenException
            @see PartialTokenException
            @see InvalidTokenException
            @see ExtensibleTokenException
            @see EndOfPrologException
        </member>
        <member name="M:xpnet.Encoding.tokenizeAttributeValue(System.Byte[],System.Int32,System.Int32,xpnet.Token)">
            Scans the first token of a byte subarrary that contains part of
            literal attribute value.  The opening and closing delimiters
            are not included in the subarrary.
            Returns one of the following integers according to the type of
            token that the subarray starts with:
            <ul>
            <li><code>TOK.DATA_CHARS</code></li>
            <li><code>TOK.DATA_NEWLINE</code></li>
            <li><code>TOK.ATTRIBUTE_VALUE_S</code></li>
            <li><code>TOK.MAGIC_ENTITY_REF</code></li>
            <li><code>TOK.ENTITY_REF</code></li>
            <li><code>TOK.CHAR_REF</code></li>
            <li><code>TOK.CHAR_PAIR_REF</code></li>
            </ul>
            @exception EmptyTokenException if the subarray is empty
            @exception PartialTokenException if the subarray contains only part of
            a legal token
            @exception InvalidTokenException if the subarrary does not start
            with a legal token or part of one
            @exception ExtensibleTokenException if the subarray encodes just a carriage
            return ('\r')
            @see #TOK.DATA_CHARS
            @see #TOK.DATA_NEWLINE
            @see #TOK.ATTRIBUTE_VALUE_S
            @see #TOK.MAGIC_ENTITY_REF
            @see #TOK.ENTITY_REF
            @see #TOK.CHAR_REF
            @see #TOK.CHAR_PAIR_REF
            @see Token
            @see EmptyTokenException
            @see PartialTokenException
            @see InvalidTokenException
            @see ExtensibleTokenException
        </member>
        <member name="M:xpnet.Encoding.tokenizeEntityValue(System.Byte[],System.Int32,System.Int32,xpnet.Token)">
            Scans the first token of a byte subarrary that contains part of
            literal entity value.  The opening and closing delimiters
            are not included in the subarrary.
            Returns one of the following integers according to the type of
            token that the subarray starts with:
            <ul>
            <li><code>TOK.DATA_CHARS</code></li>
            <li><code>TOK.DATA_NEWLINE</code></li>
            <li><code>TOK.PARAM_ENTITY_REF</code></li>
            <li><code>TOK.MAGIC_ENTITY_REF</code></li>
            <li><code>TOK.ENTITY_REF</code></li>
            <li><code>TOK.CHAR_REF</code></li>
            <li><code>TOK.CHAR_PAIR_REF</code></li>
            </ul>
            @exception EmptyTokenException if the subarray is empty
            @exception PartialTokenException if the subarray contains only part of
            a legal token
            @exception InvalidTokenException if the subarrary does not start
            with a legal token or part of one
            @exception ExtensibleTokenException if the subarray encodes just a carriage
            return ('\r')
            @see #TOK.DATA_CHARS
            @see #TOK.DATA_NEWLINE
            @see #TOK.MAGIC_ENTITY_REF
            @see #TOK.ENTITY_REF
            @see #TOK.PARAM_ENTITY_REF
            @see #TOK.CHAR_REF
            @see #TOK.CHAR_PAIR_REF
            @see Token
            @see EmptyTokenException
            @see PartialTokenException
            @see InvalidTokenException
            @see ExtensibleTokenException
        </member>
        <member name="M:xpnet.Encoding.skipIgnoreSect(System.Byte[],System.Int32,System.Int32)">
             Skips over an ignored conditional section.
             The subarray starts following the <code>&lt;![ IGNORE [</code>.
            
             @return the index of the character following the closing
             <code>]]&gt;</code>
            
             @exception PartialTokenException if the subarray does not contain the
             complete ignored conditional section
             @exception InvalidTokenException if the ignored conditional section
             contains illegal characters
        </member>
        <member name="M:xpnet.Encoding.getPublicId(System.Byte[],System.Int32,System.Int32)">
            Checks that a literal contained in the specified byte subarray
            is a legal public identifier and returns a string with
            the normalized content of the public id.
            The subarray includes the opening and closing quotes.
            @exception InvalidTokenException if it is not a legal public identifier
        </member>
        <member name="M:xpnet.Encoding.matchesXMLstring(System.Byte[],System.Int32,System.Int32,System.String)">
            Returns true if the specified byte subarray is equal to the string.
            The string must contain only XML significant characters.
        </member>
        <member name="M:xpnet.Encoding.skipS(System.Byte[],System.Int32,System.Int32)">
             Skips over XML whitespace characters at the start of the specified
             subarray.
            
             @return the index of the first non-whitespace character,
             <code>end</code> if there is the subarray is all whitespace
        </member>
        <member name="F:xpnet.Encoding.charTypeTable">
             <summary>
            
             </summary>
        </member>
        <member name="P:xpnet.Encoding.MinBytesPerChar">
            Returns the minimum number of bytes required to represent a single
            character in this encoding.  The value will be 1, 2 or 4.
        </member>
        <member name="T:stringprep.unicode.CombiningData">
            <summary>
            Combining class lookup tables.
            </summary>
        </member>
        <member name="F:stringprep.unicode.CombiningData.Classes">
            <summary>
            Combining classes for different pages.  All pages
            unspecified here will return combining class 0.
            </summary>
        </member>
        <member name="F:stringprep.unicode.CombiningData.Pages">
            <summary>
            Offset into the Classes array for each page, since Classes
            is sparse.
            255 here means that all of the combining classes for that page
            are 0.
            </summary>
        </member>
        <member name="T:stringprep.steps.NFKCStep">
            <summary>
            Perform Unicode Normalization Form KC.
            </summary>
        </member>
        <member name="T:stringprep.steps.ProfileStep">
            <summary>
            Base class for steps in a stringprep profile.
            </summary>
        </member>
        <member name="M:stringprep.steps.ProfileStep.#ctor(System.String)">
            <summary>
            Create a named profile step, with no flags.
            </summary>
            <param name="name">The profile name</param>
        </member>
        <member name="M:stringprep.steps.ProfileStep.Prepare(System.Text.StringBuilder)">
            <summary>
            This is the workhorse function, to be implemented in each subclass.
            </summary>
            <param name="result">Result will be modified in place</param>
        </member>
        <member name="P:stringprep.steps.ProfileStep.Name">
            <summary>
            The name of the step.
            </summary>
        </member>
        <member name="M:stringprep.steps.NFKCStep.#ctor">
            <summary>
            Create an NFKC step.
            </summary>
        </member>
        <member name="M:stringprep.steps.NFKCStep.Prepare(System.Text.StringBuilder)">
            <summary>
            Perform NFKC.  General overview: Decompose, Reorder, Compose
            </summary>
            <param name="result"></param>
        </member>
        <member name="M:stringprep.steps.NFKCStep.CanonicalOrdering(System.Text.StringBuilder)">
            <summary>
            Reorder characters in the given range into their correct cannonical ordering with
            respect to combining class.
            </summary>
            <param name="buf">Buffer to reorder</param>
        </member>
        <member name="T:jabber.protocol.iq.BrowseIQ">
            <summary>
            An browse IQ.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.BrowseIQ.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create a Browse IQ.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.Browse">
            <summary>
            Browse IQ query.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.Browse.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Browse.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Browse.GetItems">
            <summary>
            Sub-items of this item
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.Browse.AddItem">
            <summary>
            Add an item to the sub-item list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.Browse.GetNamespaces">
            <summary>
            The namespaces advertised by this item.
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.Browse.AddNamespace(System.String)">
            <summary>
            Add a namespace to the namespaces supported by this item.
            </summary>
            <param name="ns"></param>
        </member>
        <member name="P:jabber.protocol.iq.Browse.JID">
            <summary>
            The full JabberID of the entity described.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Browse.Category">
            <summary>
            One of the categories from the category list, or a non-standard category prefixed with the string "x-".
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Browse.Type">
            <summary>
            One of the official types from the specified category, or a non-standard type prefixed with the string "x-".
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Browse.BrowseName">
            <summary>
            A friendly name that may be used in a user interface.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Browse.Version">
            <summary>
            A string containing the version of the node, equivalent to the response provided to a
            query in the 'jabber:iq:version' namespace. This is useful for servers, especially for lists of services
            (see the 'service/serverlist' category/type above).
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.BookmarksIQ">
            <summary>
            An IQ in jabber:iq:private, with a bookmarks body.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.BookmarksIQ.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.BookmarksIQ.Bookmarks">
            <summary>
            Get the bookmarks element.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.Bookmarks">
            <summary>
            The bookmarks to be stored.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.Bookmarks.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Bookmarks.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound.
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Bookmarks.GetUrls">
            <summary>
            Get all of the URLs contained in the bookmark list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.Bookmarks.AddURL(System.String,System.String)">
            <summary>
            Add a URL bookmark
            </summary>
            <param name="URL">The URL to add</param>
            <param name="name">Descriptive text</param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.Bookmarks.GetConferences">
            <summary>
            Get all of the conferences contained in the bookmark list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.Bookmarks.AddConference(jabber.JID,System.String,System.Boolean,System.String)">
            <summary>
            Add a conference room to the bookmark list
            </summary>
            <param name="jid"></param>
            <param name="name"></param>
            <param name="autoJoin"></param>
            <param name="nick"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.Bookmarks.GetNotes">
            <summary>
            Get all of the notes contained in the bookmark list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.Bookmarks.AddNote(jabber.JID,System.String)">
            <summary>
            Add a note to the bookmark list.
            </summary>
            <param name="jid"></param>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="T:jabber.protocol.iq.BookmarkURL">
            <summary>
            A URL stored in bookmarks.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.BookmarkURL.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.BookmarkURL.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound.
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.BookmarkURL.URL">
            <summary>
            The HTTP or HTTPS URL of the web page, according to spec.
            In practice, any URI.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.BookmarkURL.URLName">
            <summary>
            A friendly name for the bookmark.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.BookmarkConference">
            <summary>
            A conference room name stored in bookmarks
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.BookmarkConference.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.BookmarkConference.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound.
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.BookmarkConference.AutoJoin">
            <summary>
            Should the room be joined on startup?
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.BookmarkConference.JID">
            <summary>
            The room@service JID of the room.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.BookmarkConference.ConferenceName">
            <summary>
            A friendly name for the bookmark.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.BookmarkConference.Nick">
            <summary>
            The user's preferred roomnick for the chatroom.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.BookmarkConference.Password">
            <summary>
            Plain-text string for the password needed to enter a password-protected room. 
            For security reasons, use of this element is NOT RECOMMENDED.
            
            TODO: should this be marked Obsolete?
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.BookmarkNote">
            <summary>
            A note stored in bookmarks.  Un-specified, but hinted at in version 1.1 of XEP-48.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.BookmarkNote.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.BookmarkNote.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound.
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.BookmarkNote.JID">
            <summary>
            The JID to which the note pertains.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.BookmarkNote.Created">
            <summary>
            The UTC date/time the note was created.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.BookmarkNote.Modified">
            <summary>
            The UTC date/time the note last modified.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.BookmarkNote.Text">
            <summary>
            The text of the note.
            </summary>
        </member>
        <member name="T:jabber.protocol.ProtocolHandler">
            <summary>
            A packet was received.  The specified element will likely be a sub-class
            of XmlElement, if the packet is found in the packet factory.
            </summary>
        </member>
        <member name="T:jabber.protocol.ElementList">
            <summary>
            Replacement for XmlElementList that removes the safety belt of checking for changes during traversal,
            but removes the big old memory leak in MS's implementation.  Also, only returns first-level children,
            rather than all children below here with the given name.  Thanks, MS.
            </summary>
        </member>
        <member name="M:jabber.protocol.ElementList.#ctor(System.Xml.XmlElement)">
            <summary>
            Create an element list that is for all child elements.
            </summary>
            <param name="parent">Parent to search</param>
        </member>
        <member name="M:jabber.protocol.ElementList.#ctor(System.Xml.XmlElement,System.String)">
            <summary>
            Create an element list that is for all child elements with the given name;
            </summary>
            <param name="parent"></param>
            <param name="name"></param>
        </member>
        <member name="M:jabber.protocol.ElementList.#ctor(System.Xml.XmlElement,System.String,System.String)">
            <summary>
            Create an element list that is for all child elements with the given name and namespace URI.
            </summary>
            <param name="parent"></param>
            <param name="name"></param>
            <param name="namespaceURI"></param>
        </member>
        <member name="M:jabber.protocol.ElementList.GetNextNode(System.Xml.XmlNode)">
            <summary>
            Get the next node in the enumeration.  Pass in null to start.
            </summary>
            <param name="start">Starting point for search.</param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.ElementList.GetEnumerator">
            <summary>
            Enumerate over the matching children.
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.ElementList.Item(System.Int32)">
            <summary>
            Retrieve a given child.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:jabber.protocol.ElementList.Count">
            <summary>
            Gets the number of matching children.
            </summary>
        </member>
        <member name="T:jabber.protocol.TypedElementList`1">
            <summary>
            Parameterized version of ElementList.
            </summary>
        </member>
        <member name="M:jabber.protocol.TypedElementList`1.#ctor(System.Xml.XmlElement)">
            <summary>
            Create an element list that is for all child elements with the specified type
            </summary>
            <param name="parent"></param>
        </member>
        <member name="M:jabber.protocol.TypedElementList`1.GetNextNode(`0)">
            <summary>
            Get the next node in the enumeration.  Pass in null to start.
            </summary>
            <param name="start">Starting point for search.</param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.TypedElementList`1.GetEnumerator">
            <summary>
            Enumerate over the matching children.
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.TypedElementList`1.Item(System.Int32)">
            <summary>
            Retrieve a given child.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.TypedElementList`1.ToArray">
            <summary>
            Create an aray from the list.
            </summary>
            <returns></returns>
        </member>
        <member name="P:jabber.protocol.TypedElementList`1.Count">
            <summary>
            Gets the number of matching children.
            </summary>
        </member>
        <member name="T:jabber.protocol.client.PresenceType">
            <summary>
            Presence type attribute
            </summary>
        </member>
        <member name="F:jabber.protocol.client.PresenceType.available">
            <summary>
            None specified
            </summary>
        </member>
        <member name="F:jabber.protocol.client.PresenceType.subscribe">
            <summary>
            May I subscribe to you?
            </summary>
        </member>
        <member name="F:jabber.protocol.client.PresenceType.subscribed">
            <summary>
            Yes, you may subscribe.
            </summary>
        </member>
        <member name="F:jabber.protocol.client.PresenceType.unsubscribe">
            <summary>
            Unsubscribe from this entity.
            </summary>
        </member>
        <member name="F:jabber.protocol.client.PresenceType.unsubscribed">
            <summary>
            No, you may not subscribe.
            </summary>
        </member>
        <member name="F:jabber.protocol.client.PresenceType.unavailable">
            <summary>
            Offline
            </summary>
        </member>
        <member name="F:jabber.protocol.client.PresenceType.probe">
            <summary>
            server-side only.
            </summary>
        </member>
        <member name="F:jabber.protocol.client.PresenceType.error">
            <summary>
            A presence error.
            </summary>
        </member>
        <member name="F:jabber.protocol.client.PresenceType.invisible">
            <summary>
            Invisible presence: we're unavailable to them, but still see
            theirs.
            </summary>
        </member>
        <member name="T:jabber.protocol.client.Presence">
            <summary>
            Client presence packet.
            </summary>
        </member>
        <member name="M:jabber.protocol.client.Presence.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.client.Presence.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.client.Presence.op_LessThan(jabber.protocol.client.Presence,jabber.protocol.client.Presence)">
            <summary>
            Compare two presences (from the same bare JID, but from
            different resources), to determine which is "more
            available".
            </summary>
            <param name="first"></param>
            <param name="second"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.client.Presence.op_GreaterThan(jabber.protocol.client.Presence,jabber.protocol.client.Presence)">
            <summary>
            Compare two presences (from the same bare JID, but from
            different resources), to determine which is "more
            available".
            </summary>
            <param name="first"></param>
            <param name="second"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.client.Presence.CompareTo(jabber.protocol.client.Presence)">
            <summary>
            Compare this presence element with another, first by priority, 
            then by show, then by time received.
            </summary>
            <param name="other"></param>
            <returns>
               Less than zero 
                This object is less than the other parameter.
               Zero 
                This object is equal to other. 
               Greater than zero 
                This object is greater than other. 
            </returns>
        </member>
        <member name="M:jabber.protocol.client.Presence.CompareTo(System.Object)">
            <summary>
            Compare this presence element with another, first by priority, 
            then by show, then by time received.
            </summary>
            <param name="other"></param>
            <returns>
               Less than zero 
                This object is less than the other parameter.
               Zero 
                This object is equal to other. 
               Greater than zero 
                This object is greater than other. 
            </returns>
        </member>
        <member name="P:jabber.protocol.client.Presence.Type">
            <summary>
            Presence type
            </summary>
        </member>
        <member name="P:jabber.protocol.client.Presence.Status">
            <summary>
            Presence status
            </summary>
        </member>
        <member name="P:jabber.protocol.client.Presence.Show">
            <summary>
            Presence show
            </summary>
        </member>
        <member name="P:jabber.protocol.client.Presence.Priority">
            <summary>
            Priority for this resource.
            </summary>
        </member>
        <member name="P:jabber.protocol.client.Presence.IntPriority">
            <summary>
            An integer version of the priority, constrained to -128..127.  0 if there was no priority element or it wasn't an integer.
            </summary>
        </member>
        <member name="P:jabber.protocol.client.Presence.Error">
            <summary>
            Presence error.
            </summary>
        </member>
        <member name="P:jabber.protocol.client.Presence.Stamp">
            <summary>
            Date/Time stamp that the presence was originially received by the sending
            server, if this presence is in response to a probe.
            </summary>
        </member>
        <member name="P:jabber.protocol.client.Presence.ReceivedTime">
            <summary>
            If there is a stamp, returns it, otherwise looks for and adds a new stamp element.
            This method should never be called for presence that is to be sent out, since it 
            will add non-standard protocol to the presence.
            </summary>
        </member>
        <member name="T:jabber.protocol.accept.LogType">
            <summary>
            The type field in a log tag.
            </summary>
        </member>
        <member name="F:jabber.protocol.accept.LogType.NONE">
            <summary>
            None specified
            </summary>
        </member>
        <member name="F:jabber.protocol.accept.LogType.warn">
            <summary>
            type='warn'
            </summary>
        </member>
        <member name="F:jabber.protocol.accept.LogType.info">
            <summary>
            type='info'
            </summary>
        </member>
        <member name="F:jabber.protocol.accept.LogType.verbose">
            <summary>
            type='verbose'
            </summary>
        </member>
        <member name="F:jabber.protocol.accept.LogType.debug">
            <summary>
            type='debug'
            </summary>
        </member>
        <member name="T:jabber.protocol.accept.Log">
            <summary>
            The log packet.
            </summary>
        </member>
        <member name="M:jabber.protocol.accept.Log.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.accept.Log.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.accept.Log.Element">
            <summary>
            The element inside the route tag.
            </summary>
        </member>
        <member name="P:jabber.protocol.accept.Log.Type">
            <summary>
            The type attribute
            </summary>
        </member>
        <member name="P:jabber.protocol.accept.Log.NS">
            <summary>
            The namespace for logging
            </summary>
        </member>
        <member name="P:jabber.protocol.accept.Log.Thread">
            <summary>
            The server thread this came from
            </summary>
        </member>
        <member name="P:jabber.protocol.accept.Log.Timestamp">
            <summary>
            Time sent.
            </summary>
        </member>
        <member name="T:jabber.connection.sasl.MD5Processor">
            <summary>
            RFC2831 DIGEST-MD5 SASL mechanism
            </summary>
        </member>
        <member name="F:jabber.connection.sasl.MD5Processor.REALM">
            <summary>
            DIGEST-MD5 Realm
            </summary>
        </member>
        <member name="F:jabber.connection.sasl.MD5Processor.NONCE">
            <summary>
            DIGEST-MD5 nonce
            </summary>
        </member>
        <member name="F:jabber.connection.sasl.MD5Processor.QOP">
            <summary>
            DIGEST-MD5 qop
            </summary>
        </member>
        <member name="F:jabber.connection.sasl.MD5Processor.CHARSET">
            <summary>
            DIGEST-MD5 charset
            </summary>
        </member>
        <member name="F:jabber.connection.sasl.MD5Processor.ALGORITHM">
            <summary>
            DIGEST-MD5 algorithm
            </summary>
        </member>
        <member name="F:jabber.connection.sasl.MD5Processor.AUTHZID">
            <summary>
            DIGEST-MD5 authorization id
            </summary>
        </member>
        <member name="F:jabber.connection.sasl.MD5Processor.m_response">
            <summary>
            Private members
            </summary>
        </member>
        <member name="F:jabber.connection.sasl.MD5Processor.s_requiredDirectives">
            <summary>
            The directives that are required to be set on the SASLProcessor in OnSASLStart
            </summary>
        </member>
        <member name="M:jabber.connection.sasl.MD5Processor.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="M:jabber.connection.sasl.MD5Processor.step(jabber.protocol.stream.Step,System.Xml.XmlDocument)">
            <summary>
            Process the next DIGEST-MD5 step.
            </summary>
            <param name="s">The previous step.  Null for the first step</param>
            <param name="doc">Document to create next step in.</param>
            <returns></returns>
            <exception cref="T:jabber.connection.sasl.AuthenticationFailedException">Thrown if authentication fails</exception>
        </member>
        <member name="M:jabber.connection.sasl.MD5Processor.populateDirectives(System.String)">
             <summary>
            
             </summary>
             <param name="decoded"></param>
        </member>
        <member name="M:jabber.connection.sasl.MD5Processor.validateStartDirectives">
             <summary>
            
             </summary>
            
        </member>
        <member name="M:jabber.connection.sasl.MD5Processor.generateResponse">
            <summary>
            Generates the entrire response to send to the server
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.connection.sasl.MD5Processor.generateResponseString">
            <summary>
            Generates the MD5 hash that goes in the response attribute of the
            response sent to the server.
            </summary>
        </member>
        <member name="T:jabber.connection.CertificatePrompt">
            <summary>
            Intentionally-ugly form to deal with bad certificates.  Because you don't like it, you should catch XmppStream.OnInvalidCertificate,
            and do something better.
            </summary>
        </member>
        <member name="F:jabber.connection.CertificatePrompt.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:jabber.connection.CertificatePrompt.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate2,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors)">
            <summary>
            Create an ugly form to prompt the user about an invalid certificate.
            </summary>
            <param name="cert">The invalid certificate</param>
            <param name="chain">The CA chain for the cert</param>
            <param name="errors">The errors associated with the certificate</param>
        </member>
        <member name="M:jabber.connection.CertificatePrompt.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:jabber.connection.CertificatePrompt.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:bedrock.net.HttpSocket">
            <summary>
            Do basic HTTP processing, with a long-lived socket.
            TODO: the BaseSocket parameter in the listener events will always be null for now.
            TODO: change HttpSocket to be a is-a of AsyncSocket, not has-a.
            </summary>
        </member>
        <member name="M:bedrock.net.HttpSocket.#ctor(bedrock.net.ISocketEventListener)">
            <summary>
            Create a socket.  This starts a thread for background processing, but the thread is mostly paused
            waiting for new requests.
            </summary>
        </member>
        <member name="M:bedrock.net.HttpSocket.Execute(System.String,System.Uri,System.Byte[],System.Int32,System.Int32,System.String)">
            <summary>
            Execute an HTTP request.
            </summary>
            <param name="method">The HTTP method verb.  E.g. "GET", "POST", etc.</param>
            <param name="URL">The URL to request.  MUST be for the same host as the first request.</param>
            <param name="body">Any data to post with the request</param>
            <param name="offset">The offset into body from which to start</param>
            <param name="len">The number of bytes to read from body, starting at offset</param>
            <param name="contentType">The MIME type of the supplied body</param>
        </member>
        <member name="M:bedrock.net.HttpSocket.Connect(System.Uri)">
            <summary>
            Generally should not be used.
            </summary>
            <param name="uri"></param>
        </member>
        <member name="M:bedrock.net.HttpSocket.Close">
            <summary>
            Shut down the socket, abandoning any outstainding requests
            </summary>
        </member>
        <member name="M:bedrock.net.HttpSocket.EnqueueClose">
            <summary>
            Close the socket after any pending request is completed.
            </summary>
        </member>
        <member name="M:bedrock.net.HttpSocket.Accept(bedrock.net.Address,System.Int32)">
            <summary>
            Not implemented.
            </summary>
            <param name="addr"></param>
            <param name="backlog"></param>
        </member>
        <member name="M:bedrock.net.HttpSocket.RequestAccept">
            <summary>
            Not implemented.
            </summary>
        </member>
        <member name="M:bedrock.net.HttpSocket.Connect(bedrock.net.Address)">
            <summary>
            Not implemented.
            </summary>
            <param name="addr"></param>
        </member>
        <member name="M:bedrock.net.HttpSocket.StartTLS">
            <summary>
            Not implemented.
            </summary>
        </member>
        <member name="M:bedrock.net.HttpSocket.StartCompression">
            <summary>
            Not implemented.
            </summary>
        </member>
        <member name="M:bedrock.net.HttpSocket.RequestRead">
            <summary>
            Not implemented.
            </summary>
        </member>
        <member name="M:bedrock.net.HttpSocket.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Not implemented.
            </summary>
            <param name="buf"></param>
            <param name="offset"></param>
            <param name="len"></param>
        </member>
        <member name="P:bedrock.net.HttpSocket.ProxyURI">
            <summary>
            The URI of the HTTP proxy.  Note: HTTPS connections through a proxy are not yet supported.
            </summary>
        </member>
        <member name="P:bedrock.net.HttpSocket.ProxyCredentials">
            <summary>
            Username/password for the proxy.
            </summary>
        </member>
        <member name="P:bedrock.net.HttpSocket.ReconnectTimeout">
            <summary>
            How long to wait before attempting to reconnect, in seconds.
            </summary>
        </member>
        <member name="P:bedrock.net.HttpSocket.MaxErrors">
            <summary>
            The maximum number of reconnect attempts before giving up.
            </summary>
        </member>
        <member name="P:bedrock.net.HttpSocket.Name">
            <summary>
            The name of the socket, for debugging purposes
            </summary>
        </member>
        <member name="P:bedrock.net.HttpSocket.IsPending">
            <summary>
            Is there an outstanding request that has not been responded to?
            </summary>
        </member>
        <member name="P:bedrock.net.HttpSocket.Connected">
            <summary>
            Are we currently connected? 
            </summary>
        </member>
        <member name="T:bedrock.collections.TrieNode">
            <summary>
            A node in a Trie.  This class is public to support traversal via Trie.Traverse().
            </summary>
        </member>
        <member name="M:bedrock.collections.TrieNode.#ctor(bedrock.collections.TrieNode,System.Byte)">
            <summary>
            Create a new node
            </summary>
            <param name="parent">The parent of the new node</param>
            <param name="key">The byte for this node</param>
        </member>
        <member name="M:bedrock.collections.TrieNode.Add(System.Byte)">
            <summary>
            Adds a child to this node.
            </summary>
            <param name="key">The key for the child.</param>
            <returns>The child noded added to this node.</returns>
        </member>
        <member name="M:bedrock.collections.TrieNode.HasChild(System.Byte)">
            <summary>
            Is there a child at the given byte?
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:bedrock.collections.TrieNode.Remove(System.Byte)">
            <summary>
            Remove the child at the given byte
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:bedrock.collections.TrieNode.Equals(System.Object)">
            <summary>
            Compares the specified object with this entry for equality.
            Returns <tt>true</tt> if the given object is also a map entry and
            the two entries represent the same mapping.  More formally, two
            entries <tt>e1</tt> and <tt>e2</tt> represent the same mapping
            if:<pre>
                (e1.getKey()==null ?
                 e2.getKey()==null : e1.getKey().equals(e2.getKey()))  &amp;&amp;
                (e1.getValue()==null ?
                 e2.getValue()==null : e1.getValue().equals(e2.getValue()))
            </pre>
            This ensures that the <tt>equals</tt> method works properly across
            different implementations of the <tt>Map.Entry</tt> interface.
            </summary>
            <param name="o">Object to be compared for equality with this map entry.</param>
            <returns><tt>True</tt> if the specified object is equal to this map
                    entry; otherwise false.</returns>
        </member>
        <member name="M:bedrock.collections.TrieNode.GetHashCode">
            <summary>
            Returns the hash code value for this map entry.
            </summary>
            <returns>Hash code.</returns>
        </member>
        <member name="M:bedrock.collections.TrieNode.GetEnumerator">
            <summary>
            Iterates over the child nodes.
            </summary>
            <returns>An IEnumerator to parse over the child nodes.</returns>
        </member>
        <member name="P:bedrock.collections.TrieNode.IsEmpty">
            <summary>
            Are there children of this node?
            </summary>
        </member>
        <member name="P:bedrock.collections.TrieNode.Parent">
            <summary>
            Get the parent of this node
            </summary>
        </member>
        <member name="P:bedrock.collections.TrieNode.Byte">
            <summary>
            Gets the byte associated with this node.
            </summary>
        </member>
        <member name="P:bedrock.collections.TrieNode.Key">
            <summary>
            Retrive the full key for this node, traversing parent-ward toward the root.
            </summary>
        </member>
        <member name="P:bedrock.collections.TrieNode.Value">
            <summary>
            The value associated with this node
            </summary>
        </member>
        <member name="P:bedrock.collections.TrieNode.Item(System.Byte)">
            <summary>
            Gets the child associated with the specified byte, or null if one does not exist.
            </summary>
        </member>
        <member name="P:bedrock.collections.TrieNode.Item(System.Byte,System.Boolean)">
            <summary>
            Gets the child associated with the specified byte, or null if one does not exist.
            If create is true, a node will be added with a null value
            if a node does not already exist, so that this can be used
            as an lvalue.
            </summary>
        </member>
        <member name="T:stringprep.unicode.Compose">
            <summary>
            Combine combining characters, where possible.
            Note: this is still Black Magic, as far as I can tell.
            </summary>
        </member>
        <member name="M:stringprep.unicode.Compose.Combine(System.Char,System.Char,System.Char@)">
            <summary>
            Combine two characters together, if possible.
            </summary>
            <param name="a">First character to combine</param>
            <param name="b">Second character to combine</param>
            <param name="result">The combined character, if method returns true.  Otherwise, undefined.</param>
            <returns>True if combination occurred</returns>
        </member>
        <member name="T:stringprep.RFC3454">
            <summary>
            Constants from RFC 3454, Stringprep.
            </summary>
        </member>
        <member name="F:stringprep.RFC3454.A_1">
             <summary>
             A.1 Unassigned code points in Unicode 3.2
            
             </summary>
        </member>
        <member name="F:stringprep.RFC3454.B_1">
             <summary>
             B.1 Commonly mapped to nothing
            
             </summary>
        </member>
        <member name="F:stringprep.RFC3454.B_2">
             <summary>
             B.2 Mapping for case-folding used with NFKC
            
             </summary>
        </member>
        <member name="F:stringprep.RFC3454.B_3">
             <summary>
             B.3 Mapping for case-folding used with no normalization
            
             </summary>
        </member>
        <member name="F:stringprep.RFC3454.C_1_1">
             <summary>
             C.1.1 ASCII space characters
            
             </summary>
        </member>
        <member name="F:stringprep.RFC3454.C_1_2">
            <summary>
            C.1.2 Non-ASCII space characters
                    /// </summary>
        </member>
        <member name="F:stringprep.RFC3454.C_2_1">
             <summary>
             C.2.1 ASCII control characters
            
             </summary>
        </member>
        <member name="F:stringprep.RFC3454.C_2_2">
             <summary>
             C.2.2 Non-ASCII control characters
            
             </summary>
        </member>
        <member name="F:stringprep.RFC3454.C_3">
             <summary>
             C.3 Private use
            
             </summary>
        </member>
        <member name="F:stringprep.RFC3454.C_4">
             <summary>
             C.4 Non-character code points
            
             </summary>
        </member>
        <member name="F:stringprep.RFC3454.C_5">
             <summary>
             C.5 Surrogate codes
            
             </summary>
        </member>
        <member name="F:stringprep.RFC3454.C_6">
             <summary>
             C.6 Inappropriate for plain text
            
             </summary>
        </member>
        <member name="F:stringprep.RFC3454.C_7">
             <summary>
             C.7 Inappropriate for canonical representation
            
             </summary>
        </member>
        <member name="F:stringprep.RFC3454.C_8">
             <summary>
             C.8 Change display properties or are deprecated
            
             </summary>
        </member>
        <member name="F:stringprep.RFC3454.C_9">
             <summary>
             C.9 Tagging characters
            
             </summary>
        </member>
        <member name="F:stringprep.RFC3454.D_1">
             <summary>
             D.1 Characters with bidirectional property "R" or "AL"
            
             </summary>
        </member>
        <member name="F:stringprep.RFC3454.D_2">
             <summary>
             D.2 Characters with bidirectional property "L"
            
             </summary>
        </member>
        <member name="T:jabber.connection.IqCB">
            <summary>
            Informs the client that a response to an IQ request has been received.
            </summary>
        </member>
        <member name="T:jabber.connection.IQTimeoutException">
            <summary>
            Informs the client that an IQ has timed out.
            </summary>
        </member>
        <member name="M:jabber.connection.IQTimeoutException.#ctor(System.String)">
            <summary>
            Creates a new timeout exception.
            </summary>
            <param name="message">Description of the error.</param>
        </member>
        <member name="T:jabber.connection.IIQTracker">
            <summary>
             Represents the interface for tracking an IQ packet.
            </summary>
        </member>
        <member name="M:jabber.connection.IIQTracker.BeginIQ(jabber.protocol.client.IQ,jabber.connection.IqCB,System.Object)">
            <summary>
             Does an asynchronous IQ call.
            </summary>
            <param name="iq">IQ packet to send.</param>
            <param name="cb">Callback to execute when the result comes back.</param>
            <param name="cbArg">Arguments to pass to the callback.</param>
        </member>
        <member name="M:jabber.connection.IIQTracker.IQ(jabber.protocol.client.IQ,System.Int32)">
            <summary>
             Does a synchronous IQ call.
            </summary>
            <param name="iqp">IQ packet to send.</param>
            <param name="millisecondsTimeout">Time, in milliseconds, to wait for the response.</param>
            <returns>The IQ packet that was sent back.</returns>
        </member>
        <member name="T:jabber.connection.IQTracker">
            <summary>
            Tracks outstanding IQ requests.
            </summary>
        </member>
        <member name="M:jabber.connection.IQTracker.#ctor(jabber.connection.XmppStream)">
            <summary>
            Creates a new IQ tracker.
            </summary>
            <param name="stream">The client to send/receive on</param>
        </member>
        <member name="M:jabber.connection.IQTracker.BeginIQ(jabber.protocol.client.IQ,jabber.connection.IqCB,System.Object)">
            <summary>
            Starts an IQ request.
            </summary>
            <param name="iq">IQ to send.</param>
            <param name="cb">Callback to use when a response comes back.</param>
            <param name="cbArg">Arguments to the callback.</param>
        </member>
        <member name="M:jabber.connection.IQTracker.IQ(jabber.protocol.client.IQ,System.Int32)">
            <summary>
            Sends an IQ request and waits for the response.
            </summary>
            <param name="iqp">An IQ packet to send, and wait for.</param>
            <param name="millisecondsTimeout">Time to wait for response, in milliseconds</param>
            <returns>An IQ in reponse to the sent IQ.</returns>
        </member>
        <member name="T:jabber.connection.IQTracker.TrackerData">
            <summary>
            Internal state for a pending tracker request
            </summary>
        </member>
        <member name="M:jabber.connection.IQTracker.TrackerData.#ctor(jabber.connection.IqCB,System.Object,jabber.JID,System.String)">
            <summary>
            Create a tracker data instance.
            </summary>
            <param name="callback"></param>
            <param name="state"></param>
            <param name="to"></param>
            <param name="iq_id"></param>
        </member>
        <member name="M:jabber.connection.IQTracker.TrackerData.IsMatch(jabber.protocol.client.IQ)">
            <summary>
            Is this IQ the one we're looking for?
            </summary>
            <param name="iq"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.connection.IQTracker.TrackerData.Call(System.Object,jabber.protocol.client.IQ)">
            <summary>
            Call the callback.
            </summary>
            <param name="sender"></param>
            <param name="iq"></param>
        </member>
        <member name="P:jabber.connection.IQTracker.TrackerData.Response">
            <summary>
            The response that came in.
            </summary>
        </member>
        <member name="T:jabber.connection.CapsManager">
            <summary>
            Manages the entity capabilities information for the local connection as well as remote ones.
            See XEP-0115, version 1.5 for details.
            </summary>
        </member>
        <member name="F:jabber.connection.CapsManager.DEFAULT_HASH">
            <summary>
            Defines the default hash function to use for calculating ver attributes.
            </summary>
        </member>
        <member name="F:jabber.connection.CapsManager.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:jabber.connection.CapsManager.#ctor">
            <summary>
            Creates a new capability manager.
            </summary>
        </member>
        <member name="M:jabber.connection.CapsManager.#ctor(System.ComponentModel.IContainer)">
            <summary>
            Creates a new capability manager and associates it with a container.
            </summary>
            <param name="container">Parent container.</param>
        </member>
        <member name="M:jabber.connection.CapsManager.#ctor(jabber.connection.DiscoNode)">
            <summary>
            Create a CapsManager from an existing Disco Node.  Pass in null
            to use a placeholder.
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:jabber.connection.CapsManager.Dispose(System.Boolean)">
            <summary>
            Performs tasks associated with freeing, releasing, or resetting resources.
            </summary>
            <param name="disposing">
            True if managed resources should be disposed; otherwise, false.
            </param>
        </member>
        <member name="M:jabber.connection.CapsManager.AddFeature(System.String)">
            <summary>
            Adds a feature to the feature list
            </summary>
            <param name="feature"></param>
        </member>
        <member name="M:jabber.connection.CapsManager.RemoveFeature(System.String)">
            <summary>
            Removes a feature from the feature list
            </summary>
            <param name="feature"></param>
        </member>
        <member name="M:jabber.connection.CapsManager.AddIdentity(System.String,System.String,System.String,System.String)">
            <summary>
            Adds a new identity.
            </summary>
            <param name="category"></param>
            <param name="type"></param>
            <param name="lang"></param>
            <param name="name"></param>
        </member>
        <member name="M:jabber.connection.CapsManager.AddIdentity(jabber.connection.Ident)">
            <summary>
            Adds a new identity
            </summary>
            <param name="id"></param>
        </member>
        <member name="M:jabber.connection.CapsManager.IsCaps(jabber.protocol.client.IQ)">
            <summary>
            Determines whether or not this is a capabilities request.
            Answers true for a bare no-node disco request, as well as
            for requests to the correct hash.
            </summary>
            <param name="iq">XML to look through for capabilities.</param>
            <returns>True if this is a capabilities request.</returns>
        </member>
        <member name="M:jabber.connection.CapsManager.FillInInfo(jabber.protocol.iq.DiscoInfo)">
            <summary>
            Take the info for this entity, and fill it in to the given DiscoInfo protocol element.
            Node, identities, and features get filled in.
            </summary>
            <param name="info">The empty info element to fill in.</param>
        </member>
        <member name="M:jabber.connection.CapsManager.GetCaps(System.Xml.XmlDocument)">
            <summary>
            Get a caps element that describes the current version, etc.
            </summary>
            <param name="doc"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.connection.CapsManager.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="P:jabber.connection.CapsManager.DiscoManager">
            <summary>
            The RosterManager for this view
            </summary>
        </member>
        <member name="P:jabber.connection.CapsManager.FileName">
            <summary>
            The file to store a cache of all received caps into.  If no cache file is supplied,
            caps queries will not be generated.
            </summary>
        </member>
        <member name="P:jabber.connection.CapsManager.Features">
            <summary>
            Gets or sets the current features enabled by this entity.
            </summary>
        </member>
        <member name="P:jabber.connection.CapsManager.Hash">
            <summary>
            Gets or sets the hash algorithm to use.
            </summary>
        </member>
        <member name="P:jabber.connection.CapsManager.Ver">
            <summary>
            Returns the calculated hash over all of the caps information.
            </summary>
        </member>
        <member name="P:jabber.connection.CapsManager.Node">
            <summary>
            Gets or sets the node URI for this client.
            </summary>
        </member>
        <member name="P:jabber.connection.CapsManager.NodeVer">
            <summary>
            Retrieves the node#ver to look for in queries.
            </summary>
        </member>
        <member name="P:jabber.connection.CapsManager.Identities">
            <summary>
            Gets or sets all of the identities currently supported by this manager.
            </summary>
        </member>
        <member name="P:jabber.connection.CapsManager.Item(System.String)">
            <summary>
            Get a DiscoNode that has all of the info associated with the 
            given ver hash, or null if there is none cached.
            
            </summary>
            <param name="ver"></param>
            <returns></returns>
        </member>
        <member name="T:bedrock.io.ReadEventStream">
            <summary>
            Wrap a stream, so that OnRead events can be fired.
            </summary>
        </member>
        <member name="M:bedrock.io.ReadEventStream.#ctor(System.IO.Stream)">
            <summary>
            Create a new stream.
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:bedrock.io.ReadEventStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous read operation.
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="callback"></param>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:bedrock.io.ReadEventStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous write operation.
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="callback"></param>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:bedrock.io.ReadEventStream.Close">
            <summary>
            Closes the current stream and releases any resources (such as sockets and file handles) associated with the current stream.
            </summary>
        </member>
        <member name="M:bedrock.io.ReadEventStream.EndRead(System.IAsyncResult)">
            <summary>
            Waits for the pending asynchronous read to complete.
            </summary>
            <param name="asyncResult"></param>
            <returns></returns>
        </member>
        <member name="M:bedrock.io.ReadEventStream.EndWrite(System.IAsyncResult)">
            <summary>
            Ends an asynchronous write operation.
            </summary>
            <param name="asyncResult"></param>
        </member>
        <member name="M:bedrock.io.ReadEventStream.Flush">
            <summary>
            Clears all buffers for this stream and causes any buffered data to be written to
            the underlying device.
            </summary>
        </member>
        <member name="M:bedrock.io.ReadEventStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a sequence of bytes from the current stream and advances the position within the stream
            by the number of bytes read.
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:bedrock.io.ReadEventStream.ReadByte">
            <summary>
            Reads a byte from the stream and advances the position within the stream by one byte,
            or returns -1 if at the end of the stream.
            </summary>
            <returns></returns>
        </member>
        <member name="M:bedrock.io.ReadEventStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the position within the current stream.
            </summary>
            <param name="offset"></param>
            <param name="origin"></param>
            <returns></returns>
        </member>
        <member name="M:bedrock.io.ReadEventStream.SetLength(System.Int64)">
            <summary>
            Sets the length of the current stream.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:bedrock.io.ReadEventStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            writes a sequence of bytes to the current stream and advances
            the current position within this stream by the number of bytes written.
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:bedrock.io.ReadEventStream.WriteByte(System.Byte)">
            <summary>
            Writes a byte to the current position in the stream and advances
            the position within the stream by one byte.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:bedrock.io.ReadEventStream.GetHashCode">
            <summary>
            Serves as a hash function for a particular type, suitable for use
            in hashing algorithms and data structures like a hash table.
            </summary>
            <returns></returns>
        </member>
        <member name="E:bedrock.io.ReadEventStream.OnRead">
            <summary>
            Bytes have been read from the underlying stream.
            </summary>
        </member>
        <member name="P:bedrock.io.ReadEventStream.CanRead">
            <summary>
            Gets a value indicating whether the current stream supports reading.
            </summary>
        </member>
        <member name="P:bedrock.io.ReadEventStream.CanSeek">
            <summary>
            Gets a value indicating whether the current stream supports seeking.
            </summary>
        </member>
        <member name="P:bedrock.io.ReadEventStream.CanWrite">
            <summary>
            Gets a value indicating whether the current stream supports writing.
            </summary>
        </member>
        <member name="P:bedrock.io.ReadEventStream.Length">
            <summary>
            Gets the length in bytes of the stream.
            </summary>
        </member>
        <member name="P:bedrock.io.ReadEventStream.Position">
            <summary>
            Gets or sets the position within the current stream.
            </summary>
        </member>
        <member name="T:jabber.client.BookmarkConferenceDelegate">
            <summary>
            A new conference bookmark.
            </summary>
            <param name="manager"></param>
            <param name="conference"></param>
        </member>
        <member name="T:jabber.client.BookmarkManager">
            <summary>
            Manager bookmarks on the server, with the old-style iq:private.
            TODO: add support for new-style PEP.
            </summary>
        </member>
        <member name="M:jabber.client.BookmarkManager.#ctor">
            <summary>
            Create
            </summary>
        </member>
        <member name="M:jabber.client.BookmarkManager.#ctor(System.ComponentModel.IContainer)">
            <summary>
            Create
            </summary>
            <param name="container"></param>
        </member>
        <member name="M:jabber.client.BookmarkManager.AddConference(jabber.JID,System.String,System.Boolean,System.String)">
            <summary>
            Add a conference room to the bookmark list
            </summary>
            <param name="jid">The room@service JID of the room</param>
            <param name="name">Human-readable text</param>
            <param name="autoJoin">Join on login</param>
            <param name="nick">Room nickname.  May be null.</param>
            <returns></returns>
        </member>
        <member name="F:jabber.client.BookmarkManager.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:jabber.client.BookmarkManager.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:jabber.client.BookmarkManager.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="P:jabber.client.BookmarkManager.AutoPrivate">
            <summary>
            Automatically request bookmarks using iq:private on login.
            </summary>
        </member>
        <member name="E:jabber.client.BookmarkManager.OnConferenceAdd">
            <summary>
            A conference bookmark has been .
            </summary>
        </member>
        <member name="E:jabber.client.BookmarkManager.OnConferenceRemove">
            <summary>
            A conference bookmark has been removed from the list.
            </summary>
        </member>
        <member name="P:jabber.client.BookmarkManager.ConferenceManager">
            <summary>
            A ConferenceManager into which to auto-join conference rooms.
            </summary>
        </member>
        <member name="P:jabber.client.BookmarkManager.Item(jabber.JID)">
            <summary>
            Get the details for the given conference bookmark.
            </summary>
            <param name="jid"></param>
            <returns></returns>
        </member>
        <member name="T:jabber.protocol.URI">
            <summary>
            Namespace constants for http://etherx.jabber.org/streams.
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.XMLNS">
            <summary>
            Namespace for the prefix "xmlns".
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.XML">
            <summary>
            Namespace for the prefix "xml", like xml:lang.
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.XHTML">
            <summary>
            XHTML namespace, for &lt;body&gt; element
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.XHTML_IM">
            <summary>
            XHTML-IM namespace, for &lt;html&gt; element
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.STREAM">
            <summary>
            stream:stream
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.START_TLS">
            <summary>
            Start-TLS feature namespace
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.COMPRESS_FEATURE">
            <summary>
            XEP-138 compression feature namespace.  Not the same as for the protocol!
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.COMPRESS">
            <summary>
            XEP-138 compression protocol namespace.  Not the same as the feature!
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.SASL">
            <summary>
            SASL feature namespace
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.SESSION">
            <summary>
            Start a session
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.BIND">
            <summary>
            Bind a resource
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.STANZA_ERROR">
            <summary>
            Stanza errors.  See RFC 3920, section 9.3.
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.STREAM_ERROR">
            <summary>
            Stream errors.  See RFC 3920, section 4.7.
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.CLIENT">
            <summary>
            Jabber client connections
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.HTTP_BIND">
            <summary>
            Jabber HTTP Binding connections
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.ACCEPT">
            <summary>
            Jabber component connections
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.CONNECT">
            <summary>
            Jabber component connections, from the router
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.SERVER">
            <summary>
            S2S connection
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.DIALBACK">
            <summary>
            S2S dialback
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.AUTH">
            <summary>
            Authentication
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.ROSTER">
            <summary>
            Roster manipulation
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.REGISTER">
            <summary>
            Register users
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.OOB">
            <summary>
            Out-of-band (file transfer)
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.AGENTS">
            <summary>
            Server agents
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.TIME">
            <summary>
            Client or server current time
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.LAST">
            <summary>
            Last activity
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.VERSION">
            <summary>
            Client or server version
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.BROWSE">
            <summary>
            Jabber Browsing
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.VCARD">
            <summary>
            Profile information
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.GEOLOC">
            <summary>
            Geographic locaiotn (lat/long).
            See XEP-80 (http://www.xmpp.org/extensions/xep-0080.html)
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.DISCO_ITEMS">
            <summary>
            Discover items from an entity.
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.DISCO_INFO">
            <summary>
            Discover info about an entity item.
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.XDELAY">
            <summary>
            Offline message timestamping.
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.DELAY">
            <summary>
            Modern, XEP-0203 delay.
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.XOOB">
            <summary>
            Out-of-band (file transfer)
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.XROSTER">
            <summary>
            Send roster entries to another user.
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.XEVENT">
            <summary>
            The jabber:x:event namespace qualifies extensions used to request and respond to
            events relating to the delivery, display, and composition of messages.
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.XDATA">
            <summary>
            jabber:x:data, as described in XEP-0004.
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.SEARCH">
            <summary>
            jabber:iq:search.
            See XEP-55 (http://www.xmpp.org/extensions/xep-0055.html)
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.MUC">
            <summary>
            Multi-user chat.
            See XEP-45 (http://www.xmpp.org/extensions/xep-0045.html)
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.MUC_USER">
            <summary>
            Multi-user chat user functions.
            See XEP-45 (http://www.xmpp.org/extensions/xep-0045.html)
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.MUC_ADMIN">
            <summary>
            Multi-user chat admin functions.
            See XEP-45 (http://www.xmpp.org/extensions/xep-0045.html)
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.MUC_OWNER">
            <summary>
            Multi-user chat owner functions.
            See XEP-45 (http://www.xmpp.org/extensions/xep-0045.html)
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.MUC_UNIQUE">
            <summary>
            Multi-user chat; request a unique room name.
            See XEP-45 (http://www.xmpp.org/extensions/xep-0045.html)
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.CAPS">
            <summary>
            Entity Capabilities.
            See XEP-115 (http://www.xmpp.org/extensions/xep-0115.html)
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.PUBSUB">
            <summary>
            Publish/Subscribe
            See XEP-0060 (http://www.xmpp.org/extensions/xep-0060.html)
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.PUBSUB_OWNER">
            <summary>
            Publish/Subscribe, Owner use cases
            See XEP-0060 (http://www.xmpp.org/extensions/xep-0060.html)
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.PUBSUB_NODE_CONFIG">
            <summary>
            Pub/Sub node configuration.
            See XEP-0060 (http://www.xmpp.org/extensions/xep-0060.html)
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.PUBSUB_EVENT">
            <summary>
            Publish/Subscribe Event
            See XEP-0060 (http://www.xmpp.org/extensions/xep-0060.html)
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.PUBSUB_ERRORS">
            <summary>
            Publish/Subscribe Errors
            See XEP-0060 (http://www.xmpp.org/extensions/xep-0060.html)
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.BOOKMARKS">
            <summary>
            Bookmarks.
            See XEP-0048 (http://www.xmpp.org/extensions/xep-0048.html)
            </summary>
        </member>
        <member name="F:jabber.protocol.URI.PRIVATE">
            <summary>
            Private storage.
            See XEP-0049 (http://www.xmpp.org/extensions/xep-0049.html)
            </summary>
        </member>
        <member name="T:jabber.protocol.NS">
            <summary>
            Namespace stack.
            </summary>
        </member>
        <member name="M:jabber.protocol.NS.#ctor">
            <summary>
            Create a new stack, primed with xmlns and xml as prefixes.
            </summary>
        </member>
        <member name="M:jabber.protocol.NS.PushScope">
            <summary>
            Declare a new scope, typically at the start of each element
            </summary>
        </member>
        <member name="M:jabber.protocol.NS.PopScope">
            <summary>
            Pop the current scope off the stack.  Typically at the end of each element.
            </summary>
        </member>
        <member name="M:jabber.protocol.NS.AddNamespace(System.String,System.String)">
            <summary>
            Add a namespace to the current scope.
            </summary>
            <param name="prefix"></param>
            <param name="uri"></param>
        </member>
        <member name="M:jabber.protocol.NS.LookupNamespace(System.String)">
            <summary>
            Lookup a prefix to find a namespace.  Searches down the stack, starting at the current scope.
            </summary>
            <param name="prefix"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.NS.ToString">
            <summary>
            Debug output only.
            </summary>
            <returns></returns>
        </member>
        <member name="P:jabber.protocol.NS.DefaultNamespace">
            <summary>
            The current default namespace.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.VersionIQ">
            <summary>
            IQ packet with a version query element inside.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.VersionIQ.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create a version IQ
            </summary>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.Version">
            <summary>
            A time query element.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.Version.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Version.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.Version.EntityName">
            <summary>
            Name of the entity.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Version.Ver">
            <summary>
            Enitity version.  (Version was a keyword, or something)
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Version.OS">
            <summary>
            Operating system of the entity.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.RegisterIQ">
            <summary>
            IQ packet with a register query element inside.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.RegisterIQ.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create a Register IQ.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.Register">
            <summary>
            User registration
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.Register.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Register.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.Register.Instructions">
            <summary>
            Instructions to the user.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Register.Username">
            <summary>
            Username to register
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Register.Nick">
            <summary>
            User nickname
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Register.Password">
            <summary>
            User password
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Register.JName">
            <summary>
            The name element.... what's this for?
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Register.First">
            <summary>
            The first name
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Register.Last">
            <summary>
            Last name
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Register.Email">
            <summary>
            E-mail address
            TODO: add format checking?
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Register.Address">
            <summary>
            User's mailing address
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Register.City">
            <summary>
            User's city
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Register.State">
            <summary>
            User's state
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Register.Zip">
            <summary>
            User's zip code
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Register.Phone">
            <summary>
            User's phone number
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Register.Url">
            <summary>
            URL for user
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Register.Date">
            <summary>
            Current date
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Register.Misc">
            <summary>
            Miscellaneous information
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Register.Text">
            <summary>
            Text... what is this used for?
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Register.Key">
            <summary>
            Public key?
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Register.Registered">
            <summary>
            Is the user already registered?
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Register.Remove">
            <summary>
            Remove the current user.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Register.Form">
            <summary>
            The x:data form for the registration request.  Null if none specified.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.Factory">
            <summary>
            ElementFactory for all currently supported IQ namespaces.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.DiscoItemsIQ">
            <summary>
            IQ packet with a disco#items query element inside.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.DiscoItemsIQ.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create a disco#items IQ
            </summary>
            <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.DiscoItemsIQ.Node">
            <summary>
            The node on the query.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.DiscoInfoIQ">
            <summary>
            IQ packet with a disco#info query element inside.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.DiscoInfoIQ.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create a disco#items IQ
            </summary>
            <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.DiscoInfoIQ.Node">
            <summary>
            The node on the query.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.DiscoItems">
            <summary>
            A disco#items query element.
            See <a href="http://www.xmpp.org/extensions/xep-0030.html">XEP-0030</a> for more information.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.DiscoItems.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.DiscoItems.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.DiscoItems.AddItem">
            <summary>
            Add a disco item
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.DiscoItems.GetItems">
            <summary>
            List of disco items
            </summary>
            <returns></returns>
        </member>
        <member name="P:jabber.protocol.iq.DiscoItems.Node">
            <summary>
            The sub-address of the discovered entity.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.DiscoAction">
            <summary>
            Actions for iq/set in the disco#items namespace.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.DiscoAction.NONE">
            <summary>
            None specified
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.DiscoAction.remove">
            <summary>
            Remove this item
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.DiscoAction.update">
            <summary>
            Update this item
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.DiscoItem">
            <summary>
            An item inside a disco#items result.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.DiscoItem.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.DiscoItem.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.DiscoItem.Jid">
            <summary>
            The Jabber ID associated with the item.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.DiscoItem.Named">
            <summary>
            The user-visible name of this node
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.DiscoItem.Node">
            <summary>
            The sub-node associated with this item.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.DiscoItem.Action">
            <summary>
            Actions for iq/set in the disco#items namespace.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.DiscoInfo">
            <summary>
            The information associated with a disco node.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.DiscoInfo.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.DiscoInfo.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.DiscoInfo.AddIdentity(System.String,System.String,System.String,System.String)">
            <summary>
            Add an identity
            </summary>
            <param name="category">The category of the identity.  Required.</param>
            <param name="discoType">The sub-type</param>
            <param name="name">A human-readable string</param>
            <param name="language">The xml:lang, or null to take the requestor's default</param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.DiscoInfo.GetIdentities">
            <summary>
            List of identities
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.DiscoInfo.AddFeature(System.String)">
            <summary>
            Add a feature
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.DiscoInfo.GetFeatures">
            <summary>
            List of features
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.DiscoInfo.HasFeature(System.String)">
            <summary>
            Is the given feature URI supported by this entity?
            </summary>
            <param name="featureURI">The URI to check</param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.DiscoInfo.ClearFeatures">
            <summary>
            Clear all of the features from the 
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.DiscoInfo.CreateExtension">
            <summary>
            Create a XEP-0128 x:data extension, or return the first existing one.
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.DiscoInfo.GetExtensions">
            <summary>
            In the unlikely event that there are multiple extensions, we need to be able
            to retrieve all of them.  
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.DiscoInfo.GetExtension(System.String)">
            <summary>
            Get the extension with the given XEP-0068 form type.
            </summary>
            <param name="formType">The value of the FORM_TYPE field to search for.</param>
            <returns>null if none found</returns>
        </member>
        <member name="P:jabber.protocol.iq.DiscoInfo.Node">
            <summary>
            The sub-node associated with this item.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.DiscoInfo.FeatureSet">
            <summary>
            Get or set a compressed set of features.
            Setting this has the side-effect of removing all existing features, and
            replacing them with the specified ones.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.DiscoInfo.Extension">
            <summary>
            Get or set the first XEP-0128 x:data extension.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.DiscoIdentity">
            <summary>
            The identitiy associated with a disco node.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.DiscoIdentity.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.DiscoIdentity.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.DiscoIdentity.Named">
            <summary>
            The user-visible name of this node
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.DiscoIdentity.Category">
            <summary>
            The category of the node
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.DiscoIdentity.Type">
            <summary>
            The type of the node
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.DiscoFeature">
            <summary>
            A feature associated with a disco node.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.DiscoFeature.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.DiscoFeature.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.DiscoFeature.Var">
            <summary>
            The namespace name or feature name.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.PubSubCommandType">
            <summary>
            Different pubsub operations
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubCommandType.affiliations">
            <summary>
            Retrieve the affiliations.  See: http://www.xmpp.org/extensions/xep-0060.html#entity-affiliations
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubCommandType.create">
            <summary>
            Create a node. See: http://www.xmpp.org/extensions/xep-0060.html#owner-create
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubCommandType.items">
            <summary>
            Retrieve the items for a node. See http://www.xmpp.org/extensions/xep-0060.html#subscriber-retrieve
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubCommandType.publish">
            <summary>
            Publish to a node.  See http://www.xmpp.org/extensions/xep-0060.html#publisher-publish
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubCommandType.retract">
            <summary>
            Delete an item from a node.  See: http://www.xmpp.org/extensions/xep-0060.html#publisher-delete
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubCommandType.subscribe">
            <summary>
            Subscribe to a node. See: http://www.xmpp.org/extensions/xep-0060.html#subscriber-subscribe
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubCommandType.subscriptions">
            <summary>
            Retrieve subscriptions.  See: http://www.xmpp.org/extensions/xep-0060.html#entity-subscriptions
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubCommandType.unsubscribe">
            <summary>
            Unsubscribe from a node.  See: http://www.xmpp.org/extensions/xep-0060.html#subscriber-unsubscribe
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubCommandType.delete">
            <summary>
            Delete a node. See: http://www.xmpp.org/extensions/xep-0060.html#owner-delete
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubCommandType.collection">
            <summary>
            Collection modification
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubCommandType.configuration">
            <summary>
            Node configuration change
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubCommandType.purge">
            <summary>
            All items purged
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubCommandType.subscription">
            <summary>
            A new subscription
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubCommandType.configure">
            <summary>
            Owner configuring the node
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubCommandType.defaults">
            <summary>
            Owner-level defaults, in a "default" element.  "default" is a C# keyword, though.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.PubSubIQ">
            <summary>
            A PubSub IQ
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.PubSubIQ.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create a pubsub IQ, with a single pubsub query element.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.PubSubIQ.#ctor(System.Xml.XmlDocument,jabber.protocol.iq.PubSubCommandType,System.String)">
            <summary>
            Create a pubsub IQ, with a pubusub query element and the given subelement.
            </summary>
            <param name="doc">Document to create in</param>
            <param name="command">The pubsub command</param>
            <param name="node">Add this as a node attrbute of the command</param>
        </member>
        <member name="P:jabber.protocol.iq.PubSubIQ.Command">
            <summary>
            Get the command from the pubsub element.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.PubSubCommandIQ`1">
            <summary>
            A type-safe PubSub IQ.
            </summary>
            <typeparam name="T">The type of command to create</typeparam>
        </member>
        <member name="M:jabber.protocol.iq.PubSubCommandIQ`1.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.PubSubCommandIQ`1.#ctor(System.Xml.XmlDocument,System.String)">
            <summary>
            Create, with node
            </summary>
            <param name="doc"></param>
            <param name="node"></param>
        </member>
        <member name="P:jabber.protocol.iq.PubSubCommandIQ`1.Command">
            <summary>
            The command inside the pubsub element.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.TypedPubSub`1">
            <summary>
            A type-safe pubsub element.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:jabber.protocol.iq.TypedPubSub`1.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create
            </summary>
            <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.TypedPubSub`1.Command">
            <summary>
            The pubsub command
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.TypedPubSub`1.CommandType">
            <summary>
            The type of pubsub command
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.PubSub">
            <summary>
            Publish/Subscribe.  See XEP-60: http://www.xmpp.org/extensions/xep-0060.html
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.PubSub.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.PubSub.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.PubSub.Command">
            <summary>
            The PubSub command associated with this instruction
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.Affiliations">
            <summary>
            Retrieve the affiliations.  See: http://www.xmpp.org/extensions/xep-0060.html#entity-affiliations
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.Affiliations.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Affiliations.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Affiliations.GetAffiliations">
            <summary>
            Retrieve all of the affiliations
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.Affiliations.AddAffiliation(jabber.protocol.iq.AffiliationType,System.String)">
            <summary>
            Add a new affiliation to the list.
            </summary>
            <param name="type"></param>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="P:jabber.protocol.iq.Affiliations.CommandType">
            <summary>
            What type of command?
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.AffiliationType">
            <summary>
            What affiliation does an entity have with respect to a node?
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.AffiliationType.NONE_SPECIFIED">
            <summary>
            No affiliation specified
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.AffiliationType.member">
            <summary>
            Can receive
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.AffiliationType.none">
            <summary>
            No affiliation
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.AffiliationType.outcast">
            <summary>
            Can't join
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.AffiliationType.owner">
            <summary>
            All permisions
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.AffiliationType.publisher">
            <summary>
            Can publish
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.Affiliation">
            <summary>
            The actual affiliation.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.Affiliation.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Affiliation.#ctor(System.Xml.XmlDocument,System.String)">
            <summary>
            Create a new instance for output, specifying the namespace.  This 
            exists for things in pubsub#owner.
            </summary>
            <param name="doc"></param>
            <param name="namespaceURI"></param>
        </member>
        <member name="M:jabber.protocol.iq.Affiliation.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.Affiliation.Node">
            <summary>
            The node this affiliation applies to.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Affiliation.Type">
            <summary>
            Which affiliation?
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.Create">
            <summary>
            Create a node. See: http://www.xmpp.org/extensions/xep-0060.html#owner-create
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.Create.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Create.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Create.GetConfiguration">
            <summary>
            Get the configuration.  Null if none exists.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.Create.CreateConfiguration">
            <summary>
            Add a (or return a pre-exisitng) configuration section to the creation request, complete with x:data.
            </summary>
            <returns>The x:data form</returns>
        </member>
        <member name="M:jabber.protocol.iq.Create.CreateConfiguration(jabber.protocol.x.Data)">
            <summary>
            Add a configuration section to the creation request, using the given x:data.
            </summary>
            <param name="form"></param>
            <returns></returns>
        </member>
        <member name="P:jabber.protocol.iq.Create.CommandType">
            <summary>
            What type of command?
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Create.HasConfigure">
            <summary>
            Does the element have a configure sibling?
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.Configure">
            <summary>
            Configuring a pubsub node.  If the default is desired, it will be empty.  Otherwise it will contain an x:data.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.Configure.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Configure.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Configure.CreateForm">
            <summary>
            Create or return the existing x:data form, with the appropriate form type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.Configure.CreateForm(jabber.protocol.x.Data)">
            <summary>
            Add the given form to the configuration, removing any existing form, and ensuring that the
            form type is correct.
            </summary>
            <param name="form"></param>
            <returns></returns>
        </member>
        <member name="P:jabber.protocol.iq.Configure.CommandType">
            <summary>
            What type of command?
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.PubSubItemCommand">
            <summary>
            Commands that deal with items.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.PubSubItemCommand.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create a pubsub command.  Should not be called directly.
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.PubSubItemCommand.#ctor(System.String,System.String,System.Xml.XmlDocument)">
            <summary>
            Create a pubsub command.  Should not be called directly.
            </summary>
            <param name="prefix"></param>
            <param name="ns"></param>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.PubSubItemCommand.GetItems">
            <summary>
            Retrieve all of the items
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.PubSubItemCommand.AddItem(System.String)">
            <summary>
            Add a new item to the list
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="T:jabber.protocol.iq.Items">
            <summary>
            Retrieve the items for a node. See http://www.xmpp.org/extensions/xep-0060.html#subscriber-retrieve
            Note: this same type is used for event notifications, in the pubsub#event namespace
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.Items.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Items.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.Items.CommandType">
            <summary>
            What type of command?
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Items.SubID">
            <summary>
            The subscription ID these items apply to.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Items.MaxItems">
            <summary>
            The maximum number of items to return
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.PubSubItem">
            <summary>
            The items in a node
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.PubSubItem.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.PubSubItem.#ctor(System.Xml.XmlDocument,System.String)">
            <summary>
            Create a new instance for output, specifying the namespace.  This 
            exists for things in pubsub#event.
            </summary>
            <param name="doc"></param>
            <param name="namespaceURI"></param>
        </member>
        <member name="M:jabber.protocol.iq.PubSubItem.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.PubSubItem.Node">
            <summary>
            The node of the published item, when doing hierachical subscribes
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.PubSubItem.ID">
            <summary>
            The item id number
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.PubSubItem.Contents">
            <summary>
            The actual contents to publish.  Make sure to set a namespace!
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.Publish">
            <summary>
            Publish to a node.  See http://www.xmpp.org/extensions/xep-0060.html#publisher-publish
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.Publish.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Publish.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.Publish.CommandType">
            <summary>
            What type of command?
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.Retract">
            <summary>
            Delete an item from a node.  See: http://www.xmpp.org/extensions/xep-0060.html#publisher-delete
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.Retract.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Retract.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.Retract.CommandType">
            <summary>
            What type of command?
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Retract.ID">
            <summary>
            When in an event, there may be an ID as an attribute.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Retract.Notify">
            <summary>
            Don notifications?
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.Subscribe">
            <summary>
            Subscribe to a node. See: http://www.xmpp.org/extensions/xep-0060.html#subscriber-subscribe
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.Subscribe.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Subscribe.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Subscribe.GetOptions">
            <summary>
            Get the configuration.  Null if none exists.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Subscribe.CommandType">
            <summary>
            What type of command?
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Subscribe.JID">
            <summary>
            The Jabber ID for this subscription
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Subscribe.HasOptions">
            <summary>
            Does the element have a options sibling?
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.PubSubOptions">
            <summary>
            PubSub subscription options
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.PubSubOptions.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.PubSubOptions.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.PubSubOptions.GetXData">
            <summary>
            Get the XData child, if it exists.
            </summary>
            <returns></returns>
        </member>
        <member name="P:jabber.protocol.iq.PubSubOptions.Node">
            <summary>
            The node these options apply to.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.PubSubOptions.JID">
            <summary>
            The Jabber ID these options apply to.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.PubSubOptions.SubID">
            <summary>
            The subscription ID these options apply to.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.PubSubOptions.HasXData">
            <summary>
            Does the element have an XData child?
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.Subscriptions">
            <summary>
            Retrieve subscriptions.  See: http://www.xmpp.org/extensions/xep-0060.html#entity-subscriptions
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.Subscriptions.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Subscriptions.#ctor(System.Xml.XmlDocument,System.String)">
            <summary>
            Create a new instance for output, specifying the namespace.  This 
            exists for things in pubsub#owner.
            </summary>
            <param name="doc"></param>
            <param name="namespaceURI"></param>
        </member>
        <member name="M:jabber.protocol.iq.Subscriptions.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Subscriptions.GetSubscriptions">
            <summary>
            Retrieve all of the subscriptions
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.Subscriptions.AddSubscription">
            <summary>
            Add a new subscription to the list
            </summary>
            <returns></returns>
        </member>
        <member name="P:jabber.protocol.iq.Subscriptions.CommandType">
            <summary>
            What type of command?
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.PubSubSubscription">
            <summary>
            A single subscription
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.PubSubSubscription.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.PubSubSubscription.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.PubSubSubscription.Node">
            <summary>
            The node these options apply to.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.PubSubSubscription.JID">
            <summary>
            The Jabber ID these options apply to.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.PubSubSubscription.SubID">
            <summary>
            The subscription ID these options apply to.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.PubSubSubscription.Type">
            <summary>
            The subscription state
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.PubSubSubscriptionType">
            <summary>
            The subscription state of a given pubsub node.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubSubscriptionType.NONE_SPECIFIED">
            <summary>
            No type given
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubSubscriptionType.none">
            <summary>
            No subscription
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubSubscriptionType.pending">
            <summary>
            Sub is pending
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubSubscriptionType.subscribed">
            <summary>
            Subscribed
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubSubscriptionType.unconfigured">
            <summary>
            Subscription needs to be configured
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.Unsubscribe">
            <summary>
            Unsubscribe from a node.  See: http://www.xmpp.org/extensions/xep-0060.html#subscriber-unsubscribe
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.Unsubscribe.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Unsubscribe.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.Unsubscribe.CommandType">
            <summary>
            What type of command?
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Unsubscribe.JID">
            <summary>
            The Jabber ID these options apply to.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Unsubscribe.SubID">
            <summary>
            The subscription ID these options apply to.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.RoomAffiliation">
            <summary>
            Affiliation with a MUC room, per user.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomAffiliation.UNSPECIFIED">
            <summary>
            No attribute specified
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomAffiliation.admin">
            <summary>
            Administrator
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomAffiliation.member">
            <summary>
            Member
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomAffiliation.none">
            <summary>
            No affiliation
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomAffiliation.outcast">
            <summary>
            Banned
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomAffiliation.owner">
            <summary>
            Room owner
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.RoomRole">
            <summary>
            Current role in the room.  Initial role is set by affiliation, if it exits.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomRole.UNSPECIFIED">
            <summary>
            No attribute specified
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomRole.moderator">
            <summary>
            Room moderator.  Can grant/revoke voice
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomRole.none">
            <summary>
            No role
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomRole.participant">
            <summary>
            Can speak
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomRole.visitor">
            <summary>
            Can listen
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.RoomStatus">
            <summary>
            Possible room status values.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomStatus.UNKNOWN">
            <summary>
            An invalid or unknown RoomStatus
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomStatus.NON_ANONYMOUS_JOIN">
            <summary>
            Inform user that any occupant is allowed to see the user's full JID.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomStatus.AFILLIATION_CHANGE">
            <summary>
            Inform user that his or her affiliation changed while not in the room
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomStatus.SHOW_UNAVAILABLE">
            <summary>
            Inform occupants that room now shows unavailable members
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomStatus.NO_SHOW_UNAVAILABLE">
            <summary>
            Inform occupants that room now does not show unavailable members
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomStatus.PRIVACY_CHANGE">
            <summary>
            Inform occupants that a non-privacy-related room configuration change has occurred
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomStatus.SELF">
            <summary>
            Inform user that presence refers to one of its own room occupants
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomStatus.LOGGING_ENABLED">
            <summary>
            Inform occupants that room logging is now enabled
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomStatus.LOGGING_DISABLED">
            <summary>
            Inform occupants that room logging is now disabled
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomStatus.NON_ANONYMOUS">
            <summary>
            Inform occupants that the room is now non-anonymous
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomStatus.SEMI_ANONYMOUS">
            <summary>
            Inform occupants that the room is now semi-anonymous
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomStatus.ANONYMOUS">
            <summary>
            Inform occupants that the room is now fully-anonymous
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomStatus.CREATED">
            <summary>
            Inform user that a new room has been created
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomStatus.NICK_CHANGED">
            <summary>
            Inform user that service has assigned or modified occupant's roomnick
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomStatus.BANNED">
            <summary>
            Inform user that he or she has been banned from the room
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomStatus.NEW_NICK">
            <summary>
            Inform all occupants of new room nickname
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomStatus.KICKED">
            <summary>
            Inform user that he or she has been kicked from the room
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomStatus.REMOVED_AFFILIATION">
            <summary>
            Inform user that he or she is being removed from the room
            because of an affiliation change
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomStatus.REMOVED_NONMEMBER">
            <summary>
            Inform user that he or she is being removed from the room
            because the room has been changed to members-only and the user
            is not a member
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.RoomStatus.REMOVED_SHUTDOWN">
            <summary>
            Inform user that he or she is being removed from the room
            because of a system shutdown
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.RoomPresence">
            <summary>
            Presence to join a multi-user chat.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.RoomPresence.#ctor(System.Xml.XmlDocument,jabber.JID)">
            <summary>
            Create, taking default room history, with no password.
            </summary>
            <param name="doc"></param>
            <param name="roomAndNick">A jid of the form room@conferenceServer/nick, where nick is the desired
            room nickname for this user</param>
        </member>
        <member name="M:jabber.protocol.iq.RoomPresence.#ctor(System.Xml.XmlDocument,jabber.JID,System.String)">
             <summary>
            
             </summary>
             <param name="doc"></param>
             <param name="roomAndNick"></param>
             <param name="password">Null for non-password rooms</param>
             TODO: getHistory?
        </member>
        <member name="P:jabber.protocol.iq.RoomPresence.X">
            <summary>
            The X tag denoting MUC-ness.  Use this to access passord and history
            after creation.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.RoomX">
            <summary>
            X tag for presence when joining a room.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.RoomX.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.RoomX.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.RoomX.AddHistory">
            <summary>
            Add a history element, or return the existing one.
            </summary>
            <returns></returns>
        </member>
        <member name="P:jabber.protocol.iq.RoomX.Password">
            <summary>
            Password to join room.  Null for no password.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.RoomX.History">
            <summary>
            History options
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.History">
            <summary>
            How much history to retrieve upon joining a room.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.History.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.History.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.History.MaxChars">
            <summary>
            Maximum number of characters.  -1 if not specified.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.History.MaxStanzas">
            <summary>
            Maximum number of stanzas.  -1 if not specified.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.History.Seconds">
            <summary>
            Number of seconds of history to retreive.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.History.since">
            <summary>
            Date of earliest history desired.
            DateTime.MinValue for not specified.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.UserX">
            <summary>
            Information about users
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.UserX.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.UserX.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.UserX.AddDecline">
            <summary>
            Add a decline element, or return the existing one.
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.UserX.AddDestroy">
            <summary>
            Add a destroy element, or return the existing one.
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.UserX.GetInvites">
            <summary>
            The list of invites
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.UserX.AddInvite(jabber.JID,System.String)">
            <summary>
            Add new invite
            </summary>
            <param name="to">Who to send the invite to?</param>
            <param name="reason">Why?  Null if none.</param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.UserX.AddRoomItem">
            <summary>
            Add a room item element, or return the existing one.
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.UserX.HasStatus(jabber.protocol.iq.RoomStatus)">
            <summary>
            Did we receive a given status?
            </summary>
            <param name="status"></param>
            <returns></returns>
        </member>
        <member name="P:jabber.protocol.iq.UserX.Decline">
            <summary>
            Invite was declined
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.UserX.Destroy">
            <summary>
            Room was destroyed
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.UserX.RoomItem">
            <summary>
            The associated item
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.UserX.Password">
            <summary>
            The password to join the room.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.UserX.Status">
            <summary>
            Sorted list of statuses of the request.
            </summary>
            <exception cref="T:System.FormatException">Invalid code</exception>
        </member>
        <member name="T:jabber.protocol.iq.Decline">
            <summary>
            Invitee Declines Invitation
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.Decline.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Decline.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.Decline.From">
            <summary>
            The From address
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Decline.To">
            <summary>
            The TO address
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Decline.Reason">
            <summary>
            The reason the invitation was declined.  May be null.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.Invite">
            <summary>
            An invite to a room
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.Invite.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Invite.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.Invite.From">
            <summary>
            The From address
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Invite.To">
            <summary>
            The TO address
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Invite.Reason">
            <summary>
            The reason the invitation was declined.  May be null.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.Destroy">
            <summary>
            A room was destroyed
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.Destroy.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Destroy.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.Destroy.JID">
            <summary>
            The JID of the destroyer
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Destroy.Reason">
            <summary>
            The reason the room was destroyed.  May be null.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.RoomItem">
            <summary>
            Item associated with a room.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.AdminItem">
            <summary>
            Item associated with a room.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.AdminItem.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.AdminItem.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.AdminItem.#ctor(System.String,System.String,System.Xml.XmlDocument)">
            <summary>
            Pass through.  I really wish C# would let me just call grand-superclass constructors.
            </summary>
            <param name="localName"></param>
            <param name="namespaceURI"></param>
            <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.AdminItem.Actor">
            <summary>
            The JID associated with this item
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.AdminItem.Reason">
            <summary>
            The reason the room was destroyed.  May be null.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.AdminItem.Affiliation">
            <summary>
            The affiliation of the item
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.AdminItem.Role">
            <summary>
            The role of the item
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.AdminItem.JID">
            <summary>
            The JID of the item
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.AdminItem.Nick">
            <summary>
            The nickname of the item
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.RoomItem.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.RoomItem.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.RoomItem.Continue">
            <summary>
            This is a continuation from 1-to-1 chat.  Not widely implemented yet.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.RoomActor">
            <summary>
            The JID associated with an item
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.RoomActor.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.RoomActor.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.RoomActor.JID">
            <summary>
            The JID of the destroyer
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.RoomAdminIQ">
            <summary>
            An IQ with a AdminQuery inside.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.RoomAdminIQ.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create a admin IQ, with a single muc#admin query element.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.AdminQuery">
            <summary>
            Moderator use cases
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.AdminQuery.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.AdminQuery.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.AdminQuery.GetItems">
            <summary>
            The list of invites
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.AdminQuery.AddItem">
            <summary>
            Add new item
            </summary>
            <returns></returns>
        </member>
        <member name="T:jabber.protocol.iq.OwnerIQ">
            <summary>
            IQ with an OwnerQuery inside
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.OwnerIQ.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create
            </summary>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.OwnerQuery">
            <summary>
            The query element inside an owner IQ.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.OwnerQuery.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.OwnerQuery.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.OwnerQuery.Form">
            <summary>
            The jabber:x:data form for configuration
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.OwnerQuery.Destroy">
            <summary>
            Should we destroy the room?
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.OwnerDestroy">
            <summary>
            Destroy the room
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.OwnerDestroy.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.OwnerDestroy.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.OwnerDestroy.Password">
            <summary>
            Password to destroy room.  Null for no password.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.OwnerDestroy.Reason">
            <summary>
            Reason to destroy room.  Null for no reason.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.OwnerDestroy.JID">
            <summary>
            The JID of the destroyer.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.UniqueIQ">
            <summary>
            Request for a unique room name.  Seems like just using a GUID on the
            create request would be enough, but it's in XEP-45.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.UniqueIQ.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create
            </summary>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.UniqueRoom">
            <summary>
            A unique name for a room.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.UniqueRoom.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.UniqueRoom.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.UniqueRoom.RoomNode">
            <summary>
            The room name returned by the server.  Note: must add conference server to this,
            it is just the node.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.LastIQ">
            <summary>
            IQ packet with an Last query element inside.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.LastIQ.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create a Last IQ
            </summary>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.Last">
            <summary>
            A Last query element, which requests the last activity from an entity.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.Last.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Last.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.Last.Message">
            <summary>
            The message inside the Last element.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Last.Seconds">
            <summary>
            How many seconds since the last activity.
            </summary>
        </member>
        <member name="T:jabber.protocol.client.IQType">
            <summary>
            IQ type attribute
            </summary>
        </member>
        <member name="F:jabber.protocol.client.IQType.get">
            <summary>
            type='get'
            </summary>
        </member>
        <member name="F:jabber.protocol.client.IQType.set">
            <summary>
            type='set'
            </summary>
        </member>
        <member name="F:jabber.protocol.client.IQType.result">
            <summary>
            type='result'
            </summary>
        </member>
        <member name="F:jabber.protocol.client.IQType.error">
            <summary>
            type='error'
            </summary>
        </member>
        <member name="T:jabber.protocol.client.Factory">
            <summary>
            ElementFactory for the jabber:client namespace.
            </summary>
        </member>
        <member name="T:jabber.JIDFormatException">
            <summary>
            Informs the client that an invalid JID was entered.
            </summary>
        </member>
        <member name="M:jabber.JIDFormatException.#ctor(System.String)">
            <summary>
            Creates a new exception for an invalid JID.
            </summary>
            <param name="badJid">The invalid JID</param>
        </member>
        <member name="M:jabber.JIDFormatException.#ctor">
            <summary>
            Creates a new exception instance.
            </summary>
        </member>
        <member name="M:jabber.JIDFormatException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new exception instance, wrapping another exception.
            </summary>
            <param name="badJid">Invalid JID.</param>
            <param name="e">Inner exception.</param>
        </member>
        <member name="M:jabber.JIDFormatException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the AsyncSocketConnectionException class with serialized data.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="ctx">The contextual information about the source or destination.</param>
        </member>
        <member name="T:jabber.JID">
            <summary>
            Provides simple JID management.
            </summary>
        </member>
        <member name="M:jabber.JID.#ctor(System.String)">
            <summary>
            Creates a JID from a string.
            This will parse and perform the stringprep (RFC 3454) process.
            </summary>
            <param name="jid">Jabber ID, in string form</param>
        </member>
        <member name="M:jabber.JID.#ctor(System.String,System.String,System.String)">
            <summary>
            Builds a new JID from the given components.
            This will parse and perform the stringprep (RFC 3454) process.
            </summary>
            <param name="user">The username value.</param>
            <param name="server">The XMPP server domain value.</param>
            <param name="resource">The current resource value.</param>
        </member>
        <member name="M:jabber.JID.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Builds a new JID, from portions that are guaranteed to already be stringprep'd.
            </summary>
            <param name="user"></param>
            <param name="server"></param>
            <param name="resource"></param>
            <param name="full">The full user@server/resource JID, so that it doesn't have to be recreated from the parts</param>
        </member>
        <member name="M:jabber.JID.GetHashCode">
            <summary>
            Gets the hash code on the string version of the JID.
            </summary>
            <returns>Hash code.</returns>
        </member>
        <member name="M:jabber.JID.ToString">
            <summary>
            Returns the string representation.
            </summary>
            <returns>String in the form of "[user]@[server]/[resource]</returns>
        </member>
        <member name="M:jabber.JID.Equals(System.Object)">
            <summary>
            Equality of string representations.
            </summary>
            <param name="other">JID or string to compare against.</param>
            <returns></returns>
        </member>
        <member name="M:jabber.JID.op_Equality(jabber.JID,jabber.JID)">
            <summary>
            Determines whether two JIDs have the same value.
            </summary>
            <param name="one">A JID to compare.</param>
            <param name="two">Another JID to compare to the first one.</param>
            <returns>True if everything (user, host and resource) are the same; otherwise false.</returns>
        </member>
        <member name="M:jabber.JID.op_Equality(System.String,jabber.JID)">
            <summary>
            Determines whether the string representation of the specified JID is equal to the current JID.
            </summary>
            <param name="one">This string is converted to a JID than compared to the second parameter.</param>
            <param name="two">JID to compare to the first one.</param>
            <returns>True if everything (user, host and resource) are the same; otherwise false.</returns>
        </member>
        <member name="M:jabber.JID.op_Inequality(System.String,jabber.JID)">
            <summary>
            Determines whether the string representation of the specified JID is not equal to the current JID.
            </summary>
            <param name="one">This string is converted to a JID than compared to the second parameter.</param>
            <param name="two">JID to compare to the first one.</param>
            <returns>True if one thing (user, host or resource) is different; otherwise false.</returns>
        </member>
        <member name="M:jabber.JID.op_Inequality(jabber.JID,jabber.JID)">
            <summary>
            Determines whether two JIDs have different values.
            </summary>
            <param name="one">A JID to compare.</param>
            <param name="two">Another JID to compare to the first one.</param>
            <returns>True if one thing (user, host and resource) is different; otherwise false.</returns>
        </member>
        <member name="M:jabber.JID.op_Implicit(System.String)~jabber.JID">
            <summary>
            Converts a string to a JID implicitly (no cast needed).
            </summary>
            <param name="jid">String containing a JID.</param>
            <returns>JID object representing the string passed in.</returns>
        </member>
        <member name="M:jabber.JID.op_Implicit(jabber.JID)~System.String">
            <summary>
            Converts a JID to a string implicitly (no cast needed).
            </summary>
            <param name="jid">JID whos string representation we want.</param>
            <returns>String version of the jid.</returns>
        </member>
        <member name="M:jabber.JID.op_LessThan(jabber.JID,jabber.JID)">
            <summary>
            Compares two JIDs.
            </summary>
            <param name="left">First JID.</param>
            <param name="right">Second JID.</param>
            <returns>True if the first JID is less to the second; otherwise false.</returns>
        </member>
        <member name="M:jabber.JID.op_GreaterThan(jabber.JID,jabber.JID)">
            <summary>
            Compares two JIDs.
            </summary>
            <param name="left">First JID.</param>
            <param name="right">Second JID.</param>
            <returns>True if the first JID is greater than the second; otherwise false.</returns>
        </member>
        <member name="M:jabber.JID.op_LessThanOrEqual(jabber.JID,jabber.JID)">
            <summary>
            Compares two JIDs.
            </summary>
            <param name="left">First JID.</param>
            <param name="right">Second JID.</param>
            <returns>True if the first JID is less than or equal to the second; otherwise false.</returns>
        </member>
        <member name="M:jabber.JID.op_GreaterThanOrEqual(jabber.JID,jabber.JID)">
            <summary>
            Compares two JIDs.
            </summary>
            <param name="left">First JID.</param>
            <param name="right">Second JID.</param>
            <returns>True if the first JID is greater than or equal to the second; otherwise false.</returns>
        </member>
        <member name="M:jabber.JID.Escape(System.String,System.String,System.String)">
            <summary>
            XEP-0106 escaping.
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.JID.Unescape">
            <summary>
            Unescape the username portion of a JID, as specified in XEP-106.
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.JID.CompareTo(System.Object)">
            <summary>
            Compares the current instance with another object of the same type.
            </summary>
            <param name="obj">An object to compare with this instance.</param>
            <returns>A 32-bit signed integer that indicates the relative order of the comparands. The return value has these meanings:
            Less than zero This instance is less than obj.
            Zero This instance is equal to obj.
            Greater than zero This instance is greater than obj.
            </returns>
        </member>
        <member name="P:jabber.JID.User">
            <summary>
            Gets and sets the username value of the JID, and returns null if it does not exist.
            </summary>
        </member>
        <member name="P:jabber.JID.Server">
            <summary>
            Gets and sets the XMPP server domain value.
            </summary>
        </member>
        <member name="P:jabber.JID.Resource">
            <summary>
            Gets and sets the resource value and returns null if it does not exist.
            </summary>
        </member>
        <member name="P:jabber.JID.Bare">
            <summary>
            Gets the username and XMPP server domain values of the JID. For example: user@example.com
            </summary>
        </member>
        <member name="P:jabber.JID.BareJID">
            <summary>
            Gets the user@server JID associated with this JID, as a JID.
            Slightly faster than building it yourself, since stringprep
            is avoided.
            </summary>
        </member>
        <member name="T:jabber.JIDTypeConverter">
            <summary>
            Convert a JID to and from a string, so that JIDs can be used as properties for
            components, and have those properties set at design time.
            </summary>
        </member>
        <member name="M:jabber.JIDTypeConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Returns whether this converter can convert an object of one type to the type of this converter. 
            </summary>
            <param name="context"></param>
            <param name="sourceType"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.JIDTypeConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Returns whether this converter can convert the object to the specified type. 
            </summary>
            <param name="context"></param>
            <param name="destinationType"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.JIDTypeConverter.IsValid(System.ComponentModel.ITypeDescriptorContext,System.Object)">
            <summary>
            Returns whether the given value object is valid for this type.
            Empty strings are allowed, since they will map to null.
            </summary>
            <param name="context"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.JIDTypeConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            Converts the given value to the type of this converter.
            Empty strings are converted to null.
            </summary>
            <param name="context"></param>
            <param name="culture"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.JIDTypeConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            Converts the given value object to the specified type.
            </summary>
            <param name="context"></param>
            <param name="culture"></param>
            <param name="value"></param>
            <param name="destinationType"></param>
            <returns></returns>
        </member>
        <member name="T:jabber.connection.ProxyType">
            <summary>
            Contains the types of proxies Jabber-Net supports.  This is only for socket connections.
            </summary>
        </member>
        <member name="F:jabber.connection.ProxyType.None">
            <summary>
            no proxy
            </summary>
        </member>
        <member name="F:jabber.connection.ProxyType.Socks4">
            <summary>
            SOCKS4 as in http://archive.socks.permeo.com/protocol/socks4.protocol
            </summary>
        </member>
        <member name="F:jabber.connection.ProxyType.Socks5">
            <summary>
            SOCKS5 as in http://archive.socks.permeo.com/rfc/rfc1928.txt
            </summary>
        </member>
        <member name="F:jabber.connection.ProxyType.HTTP">
            <summary>
            HTTP CONNECT
            </summary>
        </member>
        <member name="T:jabber.connection.SocketStanzaStream">
            <summary>
            "Standard" XMPP socket for outbound connections.
            </summary>
        </member>
        <member name="M:jabber.connection.SocketStanzaStream.#ctor(jabber.connection.IStanzaEventListener)">
            <summary>
            Create a new one.
            </summary>
            <param name="listener"></param>
        </member>
        <member name="M:jabber.connection.SocketStanzaStream.InitializeStream">
            <summary>
            Initializes the element stream.  This is the place to add factories.
            </summary>
        </member>
        <member name="M:jabber.connection.SocketStanzaStream.Connect">
            <summary>
            Connects to the XMPP server.
            </summary>
        </member>
        <member name="M:jabber.connection.SocketStanzaStream.Accept">
            <summary>
            Listens for an inbound connection.
            </summary>
        </member>
        <member name="M:jabber.connection.SocketStanzaStream.Write(System.String)">
            <summary>
            Writes the given string to the socket after UTF-8 encoding.
            </summary>
            <param name="str">String to write out.</param>
        </member>
        <member name="M:jabber.connection.SocketStanzaStream.WriteStartTag(jabber.protocol.stream.Stream)">
            <summary>
            Writes a stream:stream.
            </summary>
            <param name="stream">Stream containing the stream:stream packet to send.</param>
        </member>
        <member name="M:jabber.connection.SocketStanzaStream.Write(System.Xml.XmlElement)">
            <summary>
            Writes a full stanza.
            </summary>
            <param name="elem">XML stanza to write.</param>
        </member>
        <member name="M:jabber.connection.SocketStanzaStream.Close(System.Boolean)">
            <summary>
            Closes the session with the XMPP server.
            </summary>
            <param name="clean">Sends the close stanza to the XMPP server if true.</param>
        </member>
        <member name="M:jabber.connection.SocketStanzaStream.StartTLS">
            <summary>
            Negotiates Start-TLS with the other endpoint.
            </summary>
        </member>
        <member name="M:jabber.connection.SocketStanzaStream.StartCompression">
            <summary>
            Starts compressing outgoing traffic for this connection with the XMPP server.
            </summary>
        </member>
        <member name="M:jabber.connection.SocketStanzaStream.bedrock#net#ISocketEventListener#OnInvalidCertificate(bedrock.net.BaseSocket,System.Security.Cryptography.X509Certificates.X509Certificate,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors)">
            <summary>
            An invalid peer certificate was sent during SSL/TLS neogtiation.
            </summary>
            <param name="sock">The socket that experienced the error</param>
            <param name="certificate">The bad certificate</param>
            <param name="chain">The chain of CAs for the cert</param>
            <param name="sslPolicyErrors">A bitfield for the erorrs in the certificate.</param>
            <returns>True if the cert should be accepted anyway.</returns>
        </member>
        <member name="P:jabber.connection.SocketStanzaStream.Connected">
            <summary>
            Determines if the socket is connected.
            </summary>
        </member>
        <member name="P:jabber.connection.SocketStanzaStream.SupportsTLS">
            <summary>
            Determines whether or not Jabber-Net supports StartTLS.
            </summary>
        </member>
        <member name="P:jabber.connection.SocketStanzaStream.SupportsCompression">
            <summary>
            Determines whether or not Jabber-Net supports compression.
            </summary>
        </member>
        <member name="P:jabber.connection.SocketStanzaStream.Acceptable">
            <summary>
            Determines if the method Accept() can be called now.
            </summary>
        </member>
        <member name="T:jabber.connection.Ident">
            <summary>
            Manages a service discovery (disco) identity. See <a href="http://www.xmpp.org/extensions/xep-0030.html">XEP-0030</a> for more information.
            </summary>
        </member>
        <member name="M:jabber.connection.Ident.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Create a new identity from its constituent parts.
            </summary>
            <param name="name"></param>
            <param name="category"></param>
            <param name="type"></param>
            <param name="lang"></param>
        </member>
        <member name="M:jabber.connection.Ident.#ctor">
            <summary>
            Create a new, empty identity
            </summary>
        </member>
        <member name="M:jabber.connection.Ident.#ctor(jabber.protocol.iq.DiscoIdentity)">
            <summary>
            Create an identity from protocol
            </summary>
            <param name="id"></param>
        </member>
        <member name="M:jabber.connection.Ident.Matches(System.String,System.String)">
            <summary>
            Does this identity have the given category and type?
            </summary>
            <param name="category">The category to compare</param>
            <param name="type">The type to compare</param>
            <returns></returns>
        </member>
        <member name="M:jabber.connection.Ident.CompareTo(System.Object)">
            <summary>
            Compare to another identity, by comparing the string-ified versions
            of each.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.connection.Ident.Equals(System.Object)">
            <summary>
            Is this identity equal to that one?  If two are the same except for
            language, they are different by this method.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.connection.Ident.GetHashCode">
            <summary>
            Hash over the string version of the identity.
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.connection.Ident.ToString">
            <summary>
            A slash-separated version of the name, with the unset parts omitted.
            </summary>
            <returns></returns>
        </member>
        <member name="P:jabber.connection.Ident.Key">
            <summary>
            Retrieves the string representation of the Ident (category/type/lang/name).
            </summary>
            <returns></returns>
        </member>
        <member name="P:jabber.connection.Ident.Name">
            <summary>
            Contains the description of the entity.
            </summary>
        </member>
        <member name="P:jabber.connection.Ident.Category">
            <summary>
            Contains the capabilities category, such as server,
            client, gateway, directory and so on.
            </summary>
        </member>
        <member name="P:jabber.connection.Ident.Type">
            <summary>
            Contains the entity type.
            </summary>
        </member>
        <member name="P:jabber.connection.Ident.Lang">
            <summary>
            xml:lang language of this identity
            </summary>
        </member>
        <member name="T:jabber.connection.JIDNode">
            <summary>
            Manages a JID and Node combination.
            </summary>
        </member>
        <member name="M:jabber.connection.JIDNode.#ctor(jabber.JID,System.String)">
            <summary>
            Creates a new JID/Node combination.
            </summary>
            <param name="jid">JID to associate with JIDNode.</param>
            <param name="node">Node to associate with JIDNode.</param>
        </member>
        <member name="M:jabber.connection.JIDNode.GetKey(System.String,System.String)">
            <summary>
            Retrieves a hash key that combines the JID and the node.
            </summary>
            <param name="jid">JID to use in the hash code.</param>
            <param name="node">Node to use in the hash code.</param>
            <returns>The hash code.</returns>
        </member>
        <member name="M:jabber.connection.JIDNode.Equals(System.Object)">
            <summary>
            Determines if both the jid and the node are equal.
            </summary>
            <param name="obj">JIDNode to compare to.</param>
            <returns>True if both the jid and the node are equal.</returns>
        </member>
        <member name="M:jabber.connection.JIDNode.GetHashCode">
            <summary>
            Serves as a hash function to combine the JID and node together.
            GetHashCode() is suitable for use in hashing algorithms and
            data structures like a hash table.
            </summary>
            <returns>The hash code of this JIDNode.</returns>
        </member>
        <member name="M:jabber.connection.JIDNode.ToString">
            <summary>
            Returns a string representing the JID/Node.
            </summary>
            <returns>String representing the JID/Node.</returns>
        </member>
        <member name="P:jabber.connection.JIDNode.JID">
            <summary>
            Gets the JID.
            </summary>
        </member>
        <member name="P:jabber.connection.JIDNode.Node">
            <summary>
            Gets the Node.
            </summary>
        </member>
        <member name="P:jabber.connection.JIDNode.Key">
            <summary>
            Gets the JID/Node key for Hash lookup.
            </summary>
        </member>
        <member name="T:jabber.connection.DiscoNode">
             <summary>
             Manages the information and children of a given JID/Node combination.
            
             NOTE: If you have multiple connections in the same process, they all share the same Disco cache.
             </summary>
        </member>
        <member name="F:jabber.connection.DiscoNode.Children">
            <summary>
            Contains the children of this node.
            </summary>
        </member>
        <member name="F:jabber.connection.DiscoNode.Features">
            <summary>
            Contains the Features of this node.
            </summary>
        </member>
        <member name="F:jabber.connection.DiscoNode.Identity">
            <summary>
            Contains the identities of this node.
            </summary>
        </member>
        <member name="M:jabber.connection.DiscoNode.#ctor(jabber.JID,System.String)">
            <summary>
            Creates a disco node.
            </summary>
            <param name="jid">JID associated with this JIDNode.</param>
            <param name="node">node associated with this JIDNode.</param>
        </member>
        <member name="M:jabber.connection.DiscoNode.AddFeatureCallback(jabber.connection.DiscoManager,jabber.connection.DiscoNodeHandler,System.Object)">
            <summary>
            Add a callback for when features are received.
            
            Calls the callback immediately if the features have already been retrieved.
            </summary>
            <param name="manager"></param>
            <param name="callback"></param>
            <param name="state"></param>
            <returns>True if there were no features yet, and the callback was queued.</returns>
        </member>
        <member name="M:jabber.connection.DiscoNode.AddItemsCallback(jabber.connection.DiscoManager,jabber.connection.DiscoNodeHandler,System.Object)">
            <summary>
            Add a callback for when items are received.
            
            Calls the callback immediately if the items have already been retrieved.
            </summary>
            <param name="manager"></param>
            <param name="callback"></param>
            <param name="state"></param>
            <returns>True if there were no items yet, and the callback was queued.</returns>
        </member>
        <member name="M:jabber.connection.DiscoNode.AddIdentityCallback(jabber.connection.DiscoManager,jabber.connection.DiscoNodeHandler,System.Object)">
            <summary>
            Add a callback for when identities are received.
            
            Calls the callback immediately if the features have already been retrieved.
            </summary>
            <param name="manager"></param>
            <param name="callback"></param>
            <param name="state"></param>
            <returns>True if there were no identities yet, and the callback was queued.</returns>
        </member>
        <member name="M:jabber.connection.DiscoNode.GetIdentities">
            <summary>
            Retrieves an identity object for each identity of the node.
            </summary>
            <returns>List of identities associated with this node.</returns>
        </member>
        <member name="M:jabber.connection.DiscoNode.HasIdentity(System.String,System.String)">
            <summary>
            Determines whether or not this node has the given category and type among its identities.
            </summary>
            <param name="category">Category to look for.</param>
            <param name="type">Type to look for.</param>
            <returns>The node contains the category and the type if true.</returns>
        </member>
        <member name="M:jabber.connection.DiscoNode.HasFeature(System.String)">
            <summary>
            Determines if this node has the specified feature.
            </summary>
            <param name="URI">Feature to look for.</param>
            <returns>The node has this feature if true.</returns>
        </member>
        <member name="M:jabber.connection.DiscoNode.AddInfo(jabber.protocol.iq.DiscoInfo)">
            <summary>
            Pulls all of the data out of the given protocol response.
            </summary>
            <param name="info">If null, just calls callbacks</param>
        </member>
        <member name="M:jabber.connection.DiscoNode.AddFeature(System.String)">
            <summary>
            Add a single feature to the node.
            Does not fire OnFeatures, since this should mostly be used by
            things that are not querying externally.
            </summary>
            <param name="feature">The feature URI to add</param>
        </member>
        <member name="M:jabber.connection.DiscoNode.RemoveFeature(System.String)">
            <summary>
            Remove a single feature from the node.
            Does not fire OnFeatures, since this should mostly be used by
            things that are not querying externally.
            
            No exception should be thrown if the feature doesn't exist.
            </summary>
            <param name="feature">The feature URI to remove</param>
        </member>
        <member name="M:jabber.connection.DiscoNode.AddFeatures(jabber.protocol.iq.DiscoFeature[])">
            <summary>
            Adds these features to the node. Calls the OnFeatures event.
            </summary>
            <param name="features">Features to add to this node.</param>
        </member>
        <member name="M:jabber.connection.DiscoNode.AddFeatures(bedrock.collections.StringSet)">
            <summary>
            Add all of the features from the specified set.
            </summary>
            <param name="features"></param>
        </member>
        <member name="M:jabber.connection.DiscoNode.ClearFeatures">
            <summary>
            Clear out any features already in the list.
            </summary>
        </member>
        <member name="M:jabber.connection.DiscoNode.AddIdentity(jabber.connection.Ident)">
            <summary>
            Adds these identities to the node.
            </summary>
            <param name="id">Identities to add.</param>
        </member>
        <member name="M:jabber.connection.DiscoNode.AddIdentities(jabber.protocol.iq.DiscoIdentity[])">
            <summary>
            Add these identities to the node.
            Fires OnIdentities
            </summary>
            <param name="ids">Identities to add.</param>
        </member>
        <member name="M:jabber.connection.DiscoNode.ClearIdentity">
            <summary>
            Clear out any identities already in the list.
            </summary>
        </member>
        <member name="M:jabber.connection.DiscoNode.AddItems(jabber.connection.DiscoManager,jabber.protocol.iq.DiscoItem[])">
            <summary>
            Adds the given items to the cache.
            </summary>
            <param name="manager">The DiscoManager used to create/cache nodes</param>
            <param name="items">Items to add.</param>
        </member>
        <member name="M:jabber.connection.DiscoNode.InfoIQ(System.Xml.XmlDocument)">
            <summary>
            Creates a disco#info IQ packet.
            </summary>
            <param name="doc">XmlDocument to create the XML elements with.</param>
            <returns>XML representing the disco#info request.</returns>
        </member>
        <member name="M:jabber.connection.DiscoNode.ItemsIQ(System.Xml.XmlDocument)">
            <summary>
            Creates a disco#items IQ packet.
            </summary>
            <param name="doc">XmlDocument used to create the XML Elements.</param>
            <returns>XML element representing the disco#items request.</returns>
        </member>
        <member name="M:jabber.connection.DiscoNode.GetEnumerator">
            <summary>
            Gets an enumerator across all items.
            </summary>
            <returns>Set enumerator to loop over.</returns>
        </member>
        <member name="P:jabber.connection.DiscoNode.Name">
            <summary>
            Gets or sets the string representation of the first identity.
            </summary>
        </member>
        <member name="P:jabber.connection.DiscoNode.PendingInfo">
            <summary>
            Determines whether or not the disco#info packet has been sent.
            </summary>
        </member>
        <member name="P:jabber.connection.DiscoNode.PendingItems">
            <summary>
            Determines whether or not the disco#items packet has been sent.
            </summary>
        </member>
        <member name="P:jabber.connection.DiscoNode.FeatureNames">
            <summary>
            Retrieves the features associated with this node.
            </summary>
        </member>
        <member name="P:jabber.connection.DiscoNode.Identities">
            <summary>
            Retrieves the disco identities of the node.
            </summary>
        </member>
        <member name="P:jabber.connection.DiscoNode.Extensions">
            <summary>
            Gets or sets the x:data extensions of the disco information.
            </summary>
        </member>
        <member name="P:jabber.connection.DiscoNode.Info">
            <summary>
            This last info result returned for this JID and node.
            </summary>
        </member>
        <member name="T:jabber.connection.DiscoNodeHandler">
            <summary>
            Represents a callback with a new disco node.
            </summary>
            <param name="sender">The DiscoManager managing this node</param>
            <param name="node">The node that changed</param>
            <param name="state">State passed in to the Begin request.</param>
        </member>
        <member name="T:jabber.connection.DiscoManager">
            <summary>
            Manages the discovery (disco) database.
            </summary>
        </member>
        <member name="F:jabber.connection.DiscoManager.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:jabber.connection.DiscoManager.#ctor(System.ComponentModel.IContainer)">
            <summary>
            Creates a new DiscoManager and associates it with a parent container.
            </summary>
            <param name="container">Parent container.</param>
        </member>
        <member name="M:jabber.connection.DiscoManager.#ctor">
            <summary>
            Creates a new DiscoManager.
            </summary>
        </member>
        <member name="M:jabber.connection.DiscoManager.GetNode(jabber.JID,System.String)">
            <summary>
            Creates nodes and ensure that they are cached.
            </summary>
            <param name="jid">JID associated with DiscoNode.</param>
            <param name="node">Node associated with DiscoNode.</param>
            <returns>
            If DiscoNode exists, returns the found node.
            Otherwise it creates the node and return it.
            </returns>
        </member>
        <member name="M:jabber.connection.DiscoManager.GetNode(jabber.JID)">
            <summary>
            Creates nodes where only the JID is specified.
            </summary>
            <param name="jid">JID associated with DiscoNode.</param>
            <returns>
            If DiscoNode exists, returns the found node.
            Otherwise it creates the node and return it.
            </returns>
        </member>
        <member name="M:jabber.connection.DiscoManager.Clear">
            <summary>
            Deletes the cache.
            </summary>
        </member>
        <member name="M:jabber.connection.DiscoManager.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets all of the cached nodes.
            </summary>
            <returns>Tree enumerator to loop over.</returns>
        </member>
        <member name="M:jabber.connection.DiscoManager.BeginGetFeatures(jabber.connection.DiscoNode,jabber.connection.DiscoNodeHandler,System.Object)">
            <summary>
            Retrieves the features associated with this node and
            then calls back on the handler.
            If the information is in the cache, handler gets called right now.
            </summary>
            <param name="node">Node to look for.</param>
            <param name="handler">Callback to use afterwards.</param>
            <param name="state">Context to pass back to caller when complete</param>
        </member>
        <member name="M:jabber.connection.DiscoManager.BeginGetFeatures(jabber.JID,System.String,jabber.connection.DiscoNodeHandler,System.Object,System.Boolean)">
            <summary>
            Retrieves the features associated with this node and
            then calls back on the handler.
            
            If caching is specified, items already in the cache call the handler
            immediately.
            </summary>
            <param name="jid">JID to look for.</param>
            <param name="node">Node to look for.</param>
            <param name="handler">Callback to use afterwards.</param>
            <param name="state">Context to pass back to caller when complete</param>
            <param name="cache">Should caching be performed on this request?</param>
        </member>
        <member name="M:jabber.connection.DiscoManager.BeginGetFeatures(jabber.JID,System.String,jabber.connection.DiscoNodeHandler,System.Object)">
            <summary>
            Retrieves the features associated with this JID and node and
            then calls back on the handler.
            If the information is in the cache, handler gets called right now.
            </summary>
            <param name="jid">JID to look for.</param>
            <param name="node">Node to look for.</param>
            <param name="handler">Callback to use afterwards.</param>
            <param name="state">Context to pass back to caller when complete</param>
        </member>
        <member name="M:jabber.connection.DiscoManager.BeginGetItems(jabber.connection.DiscoNode,jabber.connection.DiscoNodeHandler,System.Object)">
            <summary>
            Retrieves the child items associated with this node,
            and then calls back on the handler.
            If the information is in the cache, handler gets
            called right now.
            </summary>
            <param name="node">Disco node to search.</param>
            <param name="handler">Callback that gets called with the items.</param>
            <param name="state">Context to pass back to caller when complete</param>
        </member>
        <member name="M:jabber.connection.DiscoManager.BeginGetItems(jabber.JID,System.String,jabber.connection.DiscoNodeHandler,System.Object,System.Boolean)">
            <summary>
            Retrieves the child items associated with this node,
            and then calls back on the handler.
            
            If caching is specified, items already in the cache call the handler
            immediately.
            </summary>
            <param name="jid">JID of Service to query.</param>
            <param name="node">Node on the service to interact with.</param>
            <param name="handler">Callback that gets called with the items.</param>
            <param name="state">Context to pass back to caller when complete</param>
            <param name="cache">Should caching be performed on this request?</param>
        </member>
        <member name="M:jabber.connection.DiscoManager.BeginGetItems(jabber.JID,System.String,jabber.connection.DiscoNodeHandler,System.Object)">
            <summary>
            Retrieves the child items associated with this node and JID,
            and then calls back on the handler.
            If the information is in the cache, handler gets
            called right now.
            </summary>
            <param name="jid">JID of Service to query.</param>
            <param name="node">Node on the service to interact with.</param>
            <param name="handler">Callback that gets called with the items.</param>
            <param name="state">Context to pass back to caller when complete</param>
        </member>
        <member name="M:jabber.connection.DiscoManager.BeginFindServiceWithFeature(System.String,jabber.connection.DiscoNodeHandler,System.Object)">
            <summary>
            Finds a component that implements a given feature, which is a child of
            the root. This will call back on the first match.  It will call back
            with null if none are found.
            </summary>
            <param name="featureURI">Feature to look for.</param>
            <param name="handler">Callback to use when finished.</param>
            <param name="state">Context to pass back to caller when complete</param>
        </member>
        <member name="M:jabber.connection.DiscoManager.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="P:jabber.connection.DiscoManager.Root">
            <summary>
            Gets the root node.  This is probably the server that the client is
            connected to. If the Children property of this root node is null,
            the disco#items request has not returned an answer. Register on this
            node's OnFeatures callback.
            </summary>
        </member>
        <member name="T:bedrock.collections.ISet">
            <summary>
            Set operations.
            </summary>
        </member>
        <member name="M:bedrock.collections.ISet.Add(System.Object)">
            <summary>
            Add an object to the set
            </summary>
            <param name="o">The object to add</param>
            <exception cref="T:System.ArgumentException">object was already in the set.</exception>
        </member>
        <member name="M:bedrock.collections.ISet.Remove(System.Object)">
            <summary>
            Remove the given object from the set.  If the object is not in the set, this is a no-op.
            </summary>
            <param name="o">The object to remove.</param>
        </member>
        <member name="M:bedrock.collections.ISet.Clear">
            <summary>
            Removes all items from the set.
            </summary>
        </member>
        <member name="M:bedrock.collections.ISet.Contains(System.Object)">
            <summary>
            Is the given object in the set?
            </summary>
            <param name="o">The object to search for.</param>
            <returns>True if the object is in the set.</returns>
        </member>
        <member name="M:bedrock.collections.ISet.Union(bedrock.collections.ISet)">
            <summary>
            Returns a new collection that contains all of the items that
            are in this set or the other set.
            </summary>
            <param name="other">Second set to combine with this one.</param>
            <returns>Combined set.</returns>
        </member>
        <member name="M:bedrock.collections.ISet.Intersection(bedrock.collections.ISet)">
            <summary>
            Return a new collection that contains all of the items that
            are in this list *and* the other set.
            </summary>
        </member>
        <member name="T:jabber.protocol.x.Factory">
            <summary>
            ElementFactory for all currently supported IQ namespaces.
            </summary>
        </member>
        <member name="T:jabber.protocol.stream.Stream">
            <summary>
            The fabled stream:stream packet.  Id's get assigned automatically on allocation.
            </summary>
        </member>
        <member name="M:jabber.protocol.stream.Stream.#ctor(System.Xml.XmlDocument,System.String)">
             <summary>
            
             </summary>
             <param name="doc"></param>
             <param name="xmlns"></param>
        </member>
        <member name="M:jabber.protocol.stream.Stream.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.stream.Stream.NS">
            <summary>
            Default stream namespace.  xmlns=''.
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Stream.Version">
            <summary>
            The version attribute.  "1.0" for an XMPP-core-compliant stream.
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Stream.OuterXml">
            <summary>
            Make sure that the namespace from this stream gets output.
            </summary>
        </member>
        <member name="T:jabber.client.RosterItemHandler">
            <summary>
            Informs the client of roster items.
            </summary>
        </member>
        <member name="T:jabber.client.SubscriptionHandler">
            <summary>
            Informs the client of a subscription requests.
            </summary>
            <param name="manager">The RosterManager than detected the subscription</param>
            <param name="ri">The affected roster item, in its current state.  Null if not found.</param>
            <param name="pres">The inbound presence stanza</param>
        </member>
        <member name="T:jabber.client.UnsubscriptionHandler">
            <summary>
            Manages unsubscription notifications.
            </summary>
            <param name="manager">The RosterManager than detected the subscription</param>
            <param name="remove">Set this to false to prevent the user being removed from the roster.</param>
            <param name="pres">The inbound presence stanza</param>
        </member>
        <member name="T:jabber.client.AutoSubscriptionHanding">
            <summary>
            Determines how the RosterManager deals with incoming subscriptions.
            </summary>
        </member>
        <member name="F:jabber.client.AutoSubscriptionHanding.NONE">
            <summary>
            Do not do any automatic processing
            </summary>
        </member>
        <member name="F:jabber.client.AutoSubscriptionHanding.AllowAll">
            <summary>
            Reply with a subscribed to every subscribe
            </summary>
        </member>
        <member name="F:jabber.client.AutoSubscriptionHanding.DenyAll">
            <summary>
            Reply with an unsubscribed to every subscribe
            </summary>
        </member>
        <member name="F:jabber.client.AutoSubscriptionHanding.AllowIfSubscribed">
            <summary>
            If the user is either subscribed or trying to subscribe to another user,
            allow the other user's subscription.
            Otherwise, treat as NONE, and fire the OnSubscribe event.
            </summary>
        </member>
        <member name="T:jabber.client.RosterManager">
            <summary>
            Manages the roster of the client.
            </summary>
        </member>
        <member name="F:jabber.client.RosterManager.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:jabber.client.RosterManager.#ctor(System.ComponentModel.IContainer)">
            <summary>
            Creates a new roster manager inside a container.
            </summary>
            <param name="container">Parent container</param>
        </member>
        <member name="M:jabber.client.RosterManager.#ctor">
            <summary>
            Creates a new roster manager.
            </summary>
        </member>
        <member name="M:jabber.client.RosterManager.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
        </member>
        <member name="M:jabber.client.RosterManager.AddRoster(jabber.protocol.client.IQ)">
            <summary>
            Adds a new roster item to the database.
            </summary>
            <param name="iq">An IQ containing a roster query.</param>
        </member>
        <member name="M:jabber.client.RosterManager.ReplyAllow(jabber.protocol.client.Presence)">
            <summary>
            Allows the subscription request and sends a subscribed to the user.
            </summary>
            <param name="pres">
            The presence packet containing the subscription request.
            </param>
        </member>
        <member name="M:jabber.client.RosterManager.ReplyDeny(jabber.protocol.client.Presence)">
            <summary>
            Denies the subscription request.
            </summary>
            <param name="pres">
            The presence packet containing the subscription request.
            </param>
        </member>
        <member name="M:jabber.client.RosterManager.Remove(jabber.JID)">
            <summary>
            Remove a contact from the roster
            </summary>
            <param name="jid">Typically just a user@host JID</param>
        </member>
        <member name="M:jabber.client.RosterManager.Modify(jabber.protocol.iq.Item)">
            <summary>
            Modifies the roster item to look like the given roster item.
            This does not modify the model,
            but waits for roster pushes from the XMPP server.
            </summary>
            <param name="item">Roster item that will appear in the roster.</param>
        </member>
        <member name="M:jabber.client.RosterManager.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="P:jabber.client.RosterManager.Client">
            <summary>
            Gets or sets the Jabber client associated with the Roster Manager.
            </summary>
        </member>
        <member name="P:jabber.client.RosterManager.AutoAllow">
            <summary>
            Gets the AutoSubscription Handling value for inbound subscriptions.
            </summary>
        </member>
        <member name="P:jabber.client.RosterManager.AutoSubscribe">
            <summary>
            Determines whether auto-subscribe is enabled or disabled for a user.
            </summary>
        </member>
        <member name="E:jabber.client.RosterManager.OnRosterItem">
            <summary>
            Informs the client that is has new roster items.
            </summary>
        </member>
        <member name="E:jabber.client.RosterManager.OnRosterBegin">
            <summary>
            Informs the client when a roster result starts, before any OnRosterItem events fire.
            This will not fire for type='set'.
            </summary>
        </member>
        <member name="E:jabber.client.RosterManager.OnRosterEnd">
            <summary>
            Informs the client that the roster has been retrieved from the XMPP server.
            </summary>
        </member>
        <member name="E:jabber.client.RosterManager.OnSubscription">
            <summary>
            Informs the client that a subscription request was received that cannot be auto-handled.
            </summary>
        </member>
        <member name="E:jabber.client.RosterManager.OnUnsubscription">
            <summary>
            Informs the client that an Unsubscribe/Unsubscribed notification from another
            user. By default, the user will be removed from the roster after this event
            fires. To prevent this, you need to set the remove property to false.
            </summary>
        </member>
        <member name="P:jabber.client.RosterManager.Item(jabber.JID)">
            <summary>
            Gets the currently-known version of a roster item for this JID.
            </summary>
        </member>
        <member name="P:jabber.client.RosterManager.Count">
            <summary>
            Gets the number of items currently in the roster.
            </summary>
        </member>
        <member name="T:bedrock.net.SocketEventListener">
            <summary>
            Default, empty implementation of ISocketEventListener
            </summary>
        </member>
        <member name="M:bedrock.net.SocketEventListener.OnInit(bedrock.net.BaseSocket)">
            <summary>
            An accept socket is about to be bound, or a connect socket is about to connect,
            or an incoming socket just came in.  Use this as an opportunity to
            </summary>
            <param name="newSock">The new socket that is about to be connected.</param>
        </member>
        <member name="M:bedrock.net.SocketEventListener.GetListener(bedrock.net.BaseSocket)">
            <summary>
            We accepted a socket, and need to get a listener.
            If the return value is null, then the socket will be closed,
            and RequestAccept will ALWAYS be called.
            </summary>
            <param name="newSock">The new socket.</param>
            <returns>The listener for the *new* socket, as compared to
            the listener for the *listen* socket</returns>
        </member>
        <member name="M:bedrock.net.SocketEventListener.OnAccept(bedrock.net.BaseSocket)">
            <summary>
            A new incoming connection was accepted.
            </summary>
            <param name="newsocket">Socket for new connection.</param>
            <returns>true if RequestAccept() should be called automatically again</returns>
        </member>
        <member name="M:bedrock.net.SocketEventListener.OnConnect(bedrock.net.BaseSocket)">
            <summary>
            Outbound connection was connected.
            </summary>
            <param name="sock">Connected socket.</param>
        </member>
        <member name="M:bedrock.net.SocketEventListener.OnClose(bedrock.net.BaseSocket)">
            <summary>
            Connection was closed.
            </summary>
            <param name="sock">Closed socket.  Already closed!</param>
        </member>
        <member name="M:bedrock.net.SocketEventListener.OnError(bedrock.net.BaseSocket,System.Exception)">
            <summary>
            An error happened in processing.  The socket is no longer open.
            </summary>
            <param name="sock">Socket in error</param>
            <param name="ec">Exception that caused the error</param>
        </member>
        <member name="M:bedrock.net.SocketEventListener.OnRead(bedrock.net.BaseSocket,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Bytes were read from the socket.
            </summary>
            <param name="sock">The socket that was read from.</param>
            <param name="buf">The bytes that were read.</param>
            <returns>true if RequestRead() should be called automatically again</returns>
            <param name="offset">Offset into the buffer to start at</param>
            <param name="length">Number of bytes to use out of the buffer</param>
        </member>
        <member name="M:bedrock.net.SocketEventListener.OnWrite(bedrock.net.BaseSocket,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Bytes were written to the socket.
            </summary>
            <param name="sock">The socket that was written to.</param>
            <param name="buf">The bytes that were written.</param>
            <param name="offset">Offset into the buffer to start at</param>
            <param name="length">Number of bytes to use out of the buffer</param>
        </member>
        <member name="M:bedrock.net.SocketEventListener.OnInvalidCertificate(bedrock.net.BaseSocket,System.Security.Cryptography.X509Certificates.X509Certificate,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors)">
            <summary>
            An invalid peer certificate was sent during SSL/TLS neogtiation.
            </summary>
            <param name="sock">The socket that experienced the error</param>
            <param name="certificate">The bad certificate</param>
            <param name="chain">The chain of CAs for the cert</param>
            <param name="sslPolicyErrors">A bitfield for the erorrs in the certificate.</param>
            <returns>True if the cert should be accepted anyway.</returns>
        </member>
        <member name="T:bedrock.io.BufferAggregate">
            <summary> Aggregate byte arrays together, so we can parse
            across IP packet boundaries
            </summary>
        </member>
        <member name="M:bedrock.io.BufferAggregate.#ctor">
            <summary>
            Create an empty buffer
            </summary>
        </member>
        <member name="M:bedrock.io.BufferAggregate.Write(System.Byte[])">
            <summary>
            Write to the buffer.  Please make sure that you won't use this memory any more after you hand it in.
            It will get mangled.
            </summary>
            <param name="buf"></param>
        </member>
        <member name="M:bedrock.io.BufferAggregate.GetBuffer">
            <summary>
            Get the current aggregate contents of the buffer.
            </summary>
            <returns></returns>
        </member>
        <member name="M:bedrock.io.BufferAggregate.Clear(System.Int32)">
            <summary>
            Clear the first "offset" bytes of the buffer, so they won't be parsed again.
            </summary>
            <param name="offset"></param>
        </member>
        <member name="M:bedrock.io.BufferAggregate.ToString">
            <summary>
            UTF8 encode the current contents of the buffer.  Just for prettiness in the debugger.
            </summary>
            <returns></returns>
        </member>
        <member name="T:stringprep.unicode.Decompose">
            <summary>
            Decomposition data for NFKC.
            </summary>
        </member>
        <member name="M:stringprep.unicode.Decompose.Find(System.Char)">
            <summary>
            Look up the expansion, if any, for the given character.
            </summary>
            <param name="ch">The character to find</param>
            <returns>the expansion, or null if none found.</returns>
        </member>
        <member name="T:jabber.protocol.stream.MechanismType">
            <summary>
            SASL mechanisms registered with IANA as of 5/16/2004.
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.MechanismType.NONE">
             <summary>
            
             </summary>
        </member>
        <member name="F:jabber.protocol.stream.MechanismType.KERBEROS_V4">
            <summary>
            LIMITED  [RFC2222]   IESG &lt;iesg@ietf.org&gt;
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.MechanismType.GSSAPI">
            <summary>
            COMMON   [RFC2222]   IESG &lt;iesg@ietf.org&gt;
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.MechanismType.SKEY">
            <summary>
            OBSOLETE [RFC2444]   IESG &lt;iesg@ietf.org&gt;
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.MechanismType.EXTERNAL">
            <summary>
            COMMON   [RFC2222]   IESG &lt;iesg@ietf.org&gt;
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.MechanismType.CRAM_MD5">
            <summary>
            LIMITED  [RFC2195]   IESG &lt;iesg@ietf.org&gt;
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.MechanismType.ANONYMOUS">
            <summary>
            COMMON   [RFC2245]   IESG &lt;iesg@ietf.org&gt;
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.MechanismType.OTP">
            <summary>
            COMMON   [RFC2444]   IESG &lt;iesg@ietf.org&gt;
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.MechanismType.GSS_SPNEGO">
            <summary>
            LIMITED  [Leach]     Paul Leach &lt;paulle@microsoft.com&gt;
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.MechanismType.PLAIN">
            <summary>
            COMMON   [RFC2595]   IESG &lt;iesg@ietf.org&gt;
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.MechanismType.SECURID">
            <summary>
            COMMON   [RFC2808]   Magnus Nystrom &lt;magnus@rsasecurity.com&gt;
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.MechanismType.NTLM">
            <summary>
            LIMITED  [Leach]     Paul Leach &lt;paulle@microsoft.com&gt;
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.MechanismType.NMAS_LOGIN">
            <summary>
            LIMITED  [Gayman]    Mark G. Gayman &lt;mgayman@novell.com&gt;
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.MechanismType.NMAS_AUTHEN">
            <summary>
            LIMITED  [Gayman]    Mark G. Gayman &lt;mgayman@novell.com&gt;
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.MechanismType.DIGEST_MD5">
            <summary>
            COMMON   [RFC2831]   IESG &lt;iesg@ietf.org&gt;
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.MechanismType.ISO_9798_U_RSA_SHA1_ENC">
            <summary>
            [RFC3163]  robert.zuccherato@entrust.com
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.MechanismType.ISO_9798_M_RSA_SHA1_ENC">
            <summary>
            COMMON   [RFC3163]   robert.zuccherato@entrust.com
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.MechanismType.ISO_9798_U_DSA_SHA1">
            <summary>
            COMMON   [RFC3163]   robert.zuccherato@entrust.com
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.MechanismType.ISO_9798_M_DSA_SHA1">
            <summary>
            COMMON   [RFC3163]   robert.zuccherato@entrust.com
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.MechanismType.ISO_9798_U_ECDSA_SHA1">
            <summary>
            COMMON   [RFC3163]   robert.zuccherato@entrust.com
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.MechanismType.ISO_9798_M_ECDSA_SHA1">
            <summary>
            COMMON   [RFC3163]   robert.zuccherato@entrust.com
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.MechanismType.KERBEROS_V5">
            <summary>
            COMMON   [Josefsson] Simon Josefsson &lt;simon@josefsson.org&gt;
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.MechanismType.NMAS_SAMBA_AUTH">
            <summary>
            LIMITED  [Brimhall]  Vince Brimhall &lt;vbrimhall@novell.com&gt;
            </summary>
        </member>
        <member name="T:jabber.protocol.stream.Mechanisms">
            <summary>
            SASL mechanisms in stream features.
            </summary>
        </member>
        <member name="M:jabber.protocol.stream.Mechanisms.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.stream.Mechanisms.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.stream.Mechanisms.GetMechanisms">
            <summary>
            The SASL mechanisms valid for this stream.
            </summary>
            <returns></returns>
        </member>
        <member name="P:jabber.protocol.stream.Mechanisms.Types">
            <summary>
            A bitmap of all of the implemented types.
            </summary>
        </member>
        <member name="T:jabber.protocol.stream.Mechanism">
            <summary>
            Stores SASL mechanisms in stream features.
            </summary>
        </member>
        <member name="M:jabber.protocol.stream.Mechanism.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.stream.Mechanism.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.stream.Mechanism.GetMechanismType(System.String)">
            <summary>
            The SASL mechanism, as an enum.
            </summary>
        </member>
        <member name="M:jabber.protocol.stream.Mechanism.GetMechanism(jabber.protocol.stream.MechanismType)">
            <summary>
            The SASL mechanism, as a string.
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Mechanism.MechanismName">
            <summary>
            The IANA-registered SASL mechanism name.
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Mechanism.MechanismType">
            <summary>
            SASL mechanism, as an enum
            </summary>
        </member>
        <member name="T:jabber.protocol.stream.Step">
            <summary>
            Auth, Challenge, and Response.
            </summary>
        </member>
        <member name="M:jabber.protocol.stream.Step.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.stream.Step.Bytes">
            <summary>
            The innards of the step.  If it is "=", it
            means an intentionally blank response, not one waiting for a challenge.
            </summary>
        </member>
        <member name="T:jabber.protocol.stream.Auth">
            <summary>
            First phase of SASL auth.
            </summary>
        </member>
        <member name="M:jabber.protocol.stream.Auth.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.stream.Auth.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.stream.Auth.Mechanism">
            <summary>
            The chosen mechanism
            </summary>
        </member>
        <member name="T:jabber.protocol.stream.Challenge">
            <summary>
            Subsequent phases of SASL auth sent by server.
            </summary>
        </member>
        <member name="M:jabber.protocol.stream.Challenge.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.stream.Challenge.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.stream.Response">
            <summary>
            First phase of SASL auth.
            </summary>
        </member>
        <member name="M:jabber.protocol.stream.Response.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.stream.Response.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.stream.SASLFailure">
            <summary>
            SASL auth failed.
            </summary>
        </member>
        <member name="M:jabber.protocol.stream.SASLFailure.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.stream.SASLFailure.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.stream.Abort">
            <summary>
            Abort SASL auth.
            </summary>
        </member>
        <member name="M:jabber.protocol.stream.Abort.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.stream.Abort.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.stream.Success">
            <summary>
            SASL auth successfult.
            </summary>
        </member>
        <member name="M:jabber.protocol.stream.Success.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.stream.Success.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.stream.Bind">
            <summary>
            Bind start after binding
            </summary>
        </member>
        <member name="M:jabber.protocol.stream.Bind.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.stream.Bind.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.stream.Bind.Resource">
            <summary>
            The resource to bind to.  Null says for the server to pick.
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Bind.JID">
            <summary>
            The JID that the server selected for us.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.AuthIQ">
            <summary>
            An auth IQ.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.AuthIQ.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create an Auth IQ.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.Auth">
            <summary>
            Client authentication, with digest support.  Call SetAuth() to compute
            the digest.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.Auth.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Auth.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Auth.SetDigest(System.String,System.String,System.String)">
            <summary>
            Set the authentication information.
            TODO: 0k
            </summary>
            <param name="username">The user name.  NOT the JID.</param>
            <param name="password">The user's password.</param>
            <param name="StreamID">The id from the stream:stream
            that the server sent, or null for plaintext.</param>
        </member>
        <member name="M:jabber.protocol.iq.Auth.SetAuth(System.String,System.String)">
            <summary>
            Set the authentication information, for plaintext auth.
            </summary>
            <param name="username">The user name.  NOT the JID.</param>
            <param name="password">The user's password.</param>
        </member>
        <member name="M:jabber.protocol.iq.Auth.SetZeroK(System.String,System.String,System.String,System.Int32)">
            <summary>
            Set the zero-knowledge information for this iq.
            </summary>
            <param name="username"></param>
            <param name="password"></param>
            <param name="token"></param>
            <param name="sequence"></param>
        </member>
        <member name="P:jabber.protocol.iq.Auth.Username">
            <summary>
            The user's account name.  NOT the JID.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Auth.Password">
            <summary>
            The plaintext password.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Auth.Digest">
            <summary>
            SHA1 hash of the StreamID and the password.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Auth.Resource">
            <summary>
            The resource to connect with.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Auth.Token">
            <summary>
            Gets the zero-k token.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Auth.Sequence">
            <summary>
            Zero-k sequence
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Auth.Hash">
            <summary>
            Zero-k hash.  NOT DIGEST!
            </summary>
        </member>
        <member name="T:jabber.protocol.accept.RouteType">
            <summary>
            The type field in a route tag.
            </summary>
        </member>
        <member name="F:jabber.protocol.accept.RouteType.NONE">
            <summary>
            None specified
            </summary>
        </member>
        <member name="F:jabber.protocol.accept.RouteType.error">
            <summary>
            type='error'
            </summary>
        </member>
        <member name="F:jabber.protocol.accept.RouteType.auth">
            <summary>
            type='auth'
            </summary>
        </member>
        <member name="F:jabber.protocol.accept.RouteType.session">
            <summary>
            type='session'
            </summary>
        </member>
        <member name="T:jabber.protocol.accept.Route">
            <summary>
            The route packet.
            </summary>
        </member>
        <member name="M:jabber.protocol.accept.Route.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.accept.Route.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.accept.Route.Contents">
            <summary>
            The element inside the route tag.
            </summary>
        </member>
        <member name="P:jabber.protocol.accept.Route.Type">
            <summary>
            The type attribute
            </summary>
        </member>
        <member name="T:jabber.client.PresenceHandler">
            <summary>
            Informs the client that a presence packet has been received.
            </summary>
        </member>
        <member name="T:jabber.client.MessageHandler">
            <summary>
            Informst the client that a message has been received.
            </summary>
        </member>
        <member name="T:jabber.client.IQHandler">
            <summary>
            Informs the client that an IQ has been received.
            </summary>
        </member>
        <member name="T:jabber.client.RegisterInfoHandler">
            <summary>
            Need more information for registration.  Return false to cancel.
            </summary>
        </member>
        <member name="T:jabber.client.JabberClient">
            <summary>
            Provides a component for clients to use to access the XMPP server.
            You can install this in your Toolbox, drop onto a form, a service, and so on.
            This class hooks into the OnProtocol event and calls the Connect() method.
            </summary>
        </member>
        <member name="M:jabber.client.JabberClient.#ctor(System.ComponentModel.IContainer)">
            <summary>
            Creates a new Jabber client and associates it with the parent window.
            Required for Windows.Forms Class Composition Designer support
            </summary>
            <param name="container">Parent container.</param>
        </member>
        <member name="M:jabber.client.JabberClient.#ctor">
            <summary>
            Creates a new JabberClient.
            Required for Windows.Forms Class Composition Designer support.
            </summary>
        </member>
        <member name="M:jabber.client.JabberClient.Connect">
            <summary>
            Connects to the XMPP server.  This happens asynchronously, and
            could take a couple of seconds to get the full handshake
            completed.  This will authenticate, send presence, and request
            roster info, if the Auto* properties are set.
            </summary>
        </member>
        <member name="M:jabber.client.JabberClient.Close">
            <summary>
            Closes down the connection.
            </summary>
        </member>
        <member name="M:jabber.client.JabberClient.Login">
            <summary>
            Initiates the authentication process.
            </summary>
        </member>
        <member name="M:jabber.client.JabberClient.Presence(jabber.protocol.client.PresenceType,System.String,System.String,System.Int32)">
            <summary>
            Sends a presence packet to the XMPP server.
            </summary>
            <param name="t">The type of presence.</param>
            <param name="status">Determines the status of the presence.</param>
            <param name="show">Shows the available, away, dnd and so on status.</param>
            <param name="priority">Prioritizes this connection.
            Higher number mean higher priority. 0 minumum, 127 max.
            -1 means this is a presence-only connection.</param>
        </member>
        <member name="M:jabber.client.JabberClient.Message(jabber.protocol.client.MessageType,System.String,System.String)">
            <summary>
            Sends a certain type of message packet to another user.
            </summary>
            <param name="t">The type of message.</param>
            <param name="to">The JID to send the message to.</param>
            <param name="body">The body of the message.</param>
        </member>
        <member name="M:jabber.client.JabberClient.Message(System.String,System.String)">
            <summary>
            Sends a message packet to another user
            </summary>
            <param name="to">The JID to send the message to.</param>
            <param name="body">The body of the message.</param>
        </member>
        <member name="M:jabber.client.JabberClient.GetRoster">
            <summary>
            Requests a new copy of the roster.
            </summary>
        </member>
        <member name="M:jabber.client.JabberClient.Subscribe(jabber.JID,System.String,System.String[])">
            <summary>
            Sends a presence subscription request and updates the roster
            for a new roster contact.
            </summary>
            <param name="to">The JID of the contact (required)</param>
            <param name="nickname">The nickname to show for the contact.</param>
            <param name="groups">A list of groups to put the contact in.  May be null.  Hint: new string[] {"foo", "bar"}</param>
        </member>
        <member name="M:jabber.client.JabberClient.RemoveRosterItem(jabber.JID)">
            <summary>
            Removes a contact from the roster.
            This will also remove the subscription for that contact being removed.
            </summary>
            <param name="to">The JID to remove</param>
        </member>
        <member name="M:jabber.client.JabberClient.GetAgents">
            <summary>
            Requests a list of agents from the XMPP server.
            </summary>
        </member>
        <member name="M:jabber.client.JabberClient.Register(jabber.JID)">
            <summary>
            Attempts to register a new user.  This will fire
            OnRegisterInfo to retrieve information about the
            new user, and OnRegistered when the registration
            is completed or failed.
            </summary>
            <param name="jid">The user to register.</param>
        </member>
        <member name="M:jabber.client.JabberClient.OnElement(System.Object,System.Xml.XmlElement)">
            <summary>
            Sorts the XML element looking for Presence, Message, and IQ packets.
            </summary>
            <param name="sender">The object calling this method.</param>
            <param name="tag">The XML element containing a stanza.</param>
        </member>
        <member name="M:jabber.client.JabberClient.FireAuthError(System.Xml.XmlElement)">
            <summary>
            Informs the client that an error occurred during authentication.
            This is public so that manual authenticators
            can fire errors using the same events.
            </summary>
            <param name="i">Xml element containing the error message.</param>
        </member>
        <member name="E:jabber.client.JabberClient.OnPresence">
            <summary>
            Informs the client that it received a presence packet.
            </summary>
        </member>
        <member name="E:jabber.client.JabberClient.OnMessage">
            <summary>
            Informs the client that it received a message packet.
            </summary>
        </member>
        <member name="E:jabber.client.JabberClient.OnIQ">
            <summary>
            Informs the client that it received an IQ packet.
            </summary>
        </member>
        <member name="E:jabber.client.JabberClient.OnAuthError">
            <summary>
            Informs the client that the authentication has failed. The connection is not
            terminated if there is an authentication error, and there
            is at least one event handler for this event.
            </summary>
        </member>
        <member name="E:jabber.client.JabberClient.OnBeforePresenceOut">
            <summary>
            Informs the client that the presence is about to be sent.
            This gives a chance to modify outbound presence (fore example, entity caps).
            </summary>
        </member>
        <member name="E:jabber.client.JabberClient.OnAfterPresenceOut">
            <summary>
            Informs the client that the presence has been sent.
            This gives a chance to send presence to other things, such as chat rooms.
            </summary>
        </member>
        <member name="E:jabber.client.JabberClient.OnLoginRequired">
            <summary>
            Determines if SutoLogin is false, and if it is time to log in.
            This callback will receive the results of the IQ type=get
            in the jabber:iq:auth namespace.  When login is completed,
            IsConnected property is set to true.  If there is a login error, the
            FireAuthError() method is called.
            </summary>
        </member>
        <member name="E:jabber.client.JabberClient.OnRegistered">
            <summary>
            Informs the client if the registration succeeded or failed.
            </summary>
        </member>
        <member name="E:jabber.client.JabberClient.OnRegisterInfo">
             <summary>
             Allows the user to enter registration requested information before sending to the XMPP server.
            
             WARNING: Make sure you do not return from this handler until the IQ is filled in.
             It is now safe to call UI elements, since this callback is now on the GUI thread if
             the InvokeControl is set.
             </summary>
        </member>
        <member name="P:jabber.client.JabberClient.User">
            <summary>
            Retrieves/Sets the username to connect as.
            </summary>
        </member>
        <member name="P:jabber.client.JabberClient.Priority">
            <summary>
            Gets the priority for this connection.
            </summary>
        </member>
        <member name="P:jabber.client.JabberClient.Password">
            <summary>
            Gets or sets the password to use for connecting to the XMPP server.
            This may be sent across the wire plaintext if the XMPP
            server doesn't support digest and PlaintextAuth is set to true.
            </summary>
        </member>
        <member name="P:jabber.client.JabberClient.AutoLogin">
            <summary>
            Allows auto-login to be used for the connection to the XMPP server if set to true.
            </summary>
        </member>
        <member name="P:jabber.client.JabberClient.AutoRoster">
            <summary>
            Retrieves the roster on connection.
            </summary>
        </member>
        <member name="P:jabber.client.JabberClient.AutoIQErrors">
            <summary>
            Sends 501/feature-not-implemented back to the client when an IQ
            has not been handled if set to true.
            </summary>
        </member>
        <member name="P:jabber.client.JabberClient.AutoPresence">
            <summary>
            Sends presence information when the connection has been established
            if set to true.
            </summary>
        </member>
        <member name="P:jabber.client.JabberClient.Resource">
            <summary>
            Gets or sets the connecting resource.
            Used to identify a unique connection.
            </summary>
        </member>
        <member name="P:jabber.client.JabberClient.NS">
            <summary>
            Gets the stream namespace for this connection.
            </summary>
        </member>
        <member name="P:jabber.client.JabberClient.IsAuthenticated">
            <summary>
            Are we currently connected?
            </summary>
        </member>
        <member name="T:jabber.client.GetAuthState">
            <summary>
            Contains the "Getting authorization" information.
            </summary>
        </member>
        <member name="F:jabber.client.GetAuthState.Instance">
            <summary>
            Gets the instance that is always used.
            </summary>
        </member>
        <member name="T:jabber.client.SetAuthState">
            <summary>
            Contains the "Setting authorization" information.
            </summary>
        </member>
        <member name="F:jabber.client.SetAuthState.Instance">
            <summary>
            Gets the instance that is always used.
            </summary>
        </member>
        <member name="T:jabber.client.ManualLoginState">
            <summary>
            Informs the client that the JabberClient is in
            the "Waiting for manual login" state.
            </summary>
        </member>
        <member name="F:jabber.client.ManualLoginState.Instance">
            <summary>
            Gets the instance that is always used.
            </summary>
        </member>
        <member name="T:jabber.client.ManualSASLLoginState">
            <summary>
            Informs the client that the JabberClient is in
            the "Waiting for manual login" state, but when Login()
            happens, it should try SASL.
            </summary>
        </member>
        <member name="F:jabber.client.ManualSASLLoginState.Instance">
            <summary>
            Gets the instance that is always used.
            </summary>
        </member>
        <member name="T:bedrock.io.CompressionFailedException">
            <summary>
            Compression failed.
            </summary>
        </member>
        <member name="M:bedrock.io.CompressionFailedException.#ctor(System.String)">
             <summary>
            
             </summary>
             <param name="message"></param>
        </member>
        <member name="M:bedrock.io.CompressionFailedException.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="T:bedrock.io.ZlibStream">
             <summary>
             Wrap two ComponentAce.Compression.Libs.zlib.ZStream's, one in and one out.
             The existing wrappers in the project are uni-directional.
            
             No, System.IO.Compression.GZipStream won't work, because they didn't expose
             compression levels or flush types.
             </summary>
        </member>
        <member name="M:bedrock.io.ZlibStream.#ctor(System.IO.Stream)">
            <summary>
            Wrap a bi-directional stream in a compression stream.
            </summary>
            <param name="innerStream">The stream to wrap.</param>
        </member>
        <member name="M:bedrock.io.ZlibStream.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Wrap a bi-directional stream in a compression stream.
            </summary>
            <param name="innerStream">The stream to wrap.</param>
            <param name="flush">The flush type.  TODO: doc these.</param>
        </member>
        <member name="M:bedrock.io.ZlibStream.Flush">
            <summary>
            This just flushes the stream, but doesn't perform zlib flushing.
            </summary>
        </member>
        <member name="M:bedrock.io.ZlibStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            Start an async read. Implemented locally, since Stream.BeginRead() isn't really asynch.
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="callback"></param>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:bedrock.io.ZlibStream.EndRead(System.IAsyncResult)">
            <summary>
            Complete a pending read, when the callback passed to BeginRead fires.
            </summary>
            <param name="asyncResult"></param>
            <returns></returns>
        </member>
        <member name="M:bedrock.io.ZlibStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Synchronous read.  Decompresses.
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:bedrock.io.ZlibStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Not implemented.
            </summary>
            <param name="offset"></param>
            <param name="origin"></param>
            <returns></returns>
        </member>
        <member name="M:bedrock.io.ZlibStream.SetLength(System.Int64)">
            <summary>
            Not implemented.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:bedrock.io.ZlibStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            Begin an asynch write, compressing first.  Implemented locally, since Stream.BeginWrite isn't asynch.
            Note: may call Write() on the underlying stream more than once.
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="callback"></param>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:bedrock.io.ZlibStream.EndWrite(System.IAsyncResult)">
            <summary>
            Complete a pending write, when the callback given to BeginWrite is called.
            </summary>
            <param name="asyncResult"></param>
        </member>
        <member name="M:bedrock.io.ZlibStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Synchronous write, after compressing.
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="P:bedrock.io.ZlibStream.Supported">
            <summary>
            Is zlib supported?  Note, this will throw an exception if the library is missing.
            </summary>
        </member>
        <member name="P:bedrock.io.ZlibStream.CanRead">
            <summary>
            Is the underlying stream readable?
            </summary>
        </member>
        <member name="P:bedrock.io.ZlibStream.CanSeek">
            <summary>
            No seeking on compressed streams.  That sounds hard.
            </summary>
        </member>
        <member name="P:bedrock.io.ZlibStream.CanWrite">
            <summary>
            Is the underlying stream writable?
            </summary>
        </member>
        <member name="P:bedrock.io.ZlibStream.Length">
            <summary>
            Not implemented.
            </summary>
        </member>
        <member name="P:bedrock.io.ZlibStream.Position">
            <summary>
            Not implemented.
            </summary>
        </member>
        <member name="T:jabber.connection.FileMap`1">
            <summary>
            A dictionary backed into a file.  Any modification to the dictionary re-writes the file, so 
            writes are somewhat costly.  Reads are cached lazily.
            </summary>
        </member>
        <member name="M:jabber.connection.FileMap`1.#ctor(System.String,jabber.protocol.ElementFactory)">
            <summary>
            Create a file map.
            </summary>
            <param name="fileName">Valid file name, either absoulte, or relative 
            to the current working directory.</param>
            <param name="factory">Element factory to create elements of a given type.  If null,
            Elements will always be created, and T MUST be Element.</param>
        </member>
        <member name="M:jabber.connection.FileMap`1.Remove(System.String)">
            <summary>
            Remove the specified key and value
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.connection.FileMap`1.Clear">
            <summary>
            Clear all stored keys/values.
            </summary>
        </member>
        <member name="M:jabber.connection.FileMap`1.Contains(System.String)">
            <summary>
            Is the given key in the map?
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:jabber.connection.FileMap`1.Factory">
            <summary>
            The ElementFactory that determines the type of the elements being stored.
            </summary>
        </member>
        <member name="P:jabber.connection.FileMap`1.FileName">
            <summary>
            The name of the file to manage.
            </summary>
        </member>
        <member name="P:jabber.connection.FileMap`1.Item(System.String)">
            <summary>
            Get or set the XmlElement associated with the given key.
            If the key already has a value, it WILL NOT be overridden; you 
            MUST call Clear or Remove first.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:jabber.connection.FileMap`1.Count">
            <summary>
            How many key/value pairs are stored?
            </summary>
        </member>
        <member name="T:stringprep.steps.MapStep">
            <summary>
            A stringprep profile step to map one input character into 0 or
            more output characters.
            </summary>
        </member>
        <member name="M:stringprep.steps.MapStep.#ctor(System.String[],System.String)">
            <summary>
            Map from one character to 0+
            </summary>
            <param name="table"></param>
            <param name="name"></param>
        </member>
        <member name="M:stringprep.steps.MapStep.Prepare(System.Text.StringBuilder)">
            <summary>
            Perform mapping for each character of input.
            </summary>
            <param name="result">Result is modified in place.</param>
        </member>
        <member name="T:stringprep.steps.BidiException">
            <summary>
            There was a problem with the Bidirection nature of a string to be prepped.
            </summary>
        </member>
        <member name="M:stringprep.steps.BidiException.#ctor(System.String)">
            <summary>
            Create a new BidiException
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:stringprep.steps.BidiStep">
            <summary>
            A stringprep profile step to check for Bidirectional correctness.
            If the NO_BIDI flag is set, this is a no-op.
            </summary>
        </member>
        <member name="M:stringprep.steps.BidiStep.#ctor">
            <summary>
            Create a new BidiStep.
            </summary>
        </member>
        <member name="M:stringprep.steps.BidiStep.Prepare(System.Text.StringBuilder)">
             <summary>
             Perform BiDi checks.
            
             From RFC 3454, Section 6:
             In any profile that specifies bidirectional character handling, all
             three of the following requirements MUST be met:
             <ol>
             <li>The characters in section 5.8 MUST be prohibited.</li>
             <li>If a string contains any RandALCat character, the string MUST NOT
             contain any LCat character.</li>
             <li> If a string contains any RandALCat character, a RandALCat
             character MUST be the first character of the string, and a
             RandALCat character MUST be the last character of the string.</li>
             </ol>
             </summary>
             <param name="result">Result is modified in place.</param>
             <exception cref="T:stringprep.steps.BidiException">A BiDi problem exists</exception>
        </member>
        <member name="T:stringprep.steps.ProhibitStep">
            <summary>
            A stringprep profile step that checks for prohibited characters
            </summary>
        </member>
        <member name="M:stringprep.steps.ProhibitStep.#ctor(System.Char[][],System.String)">
            <summary>
            These characters are prohibited
            </summary>
            <param name="table"></param>
            <param name="name"></param>
        </member>
        <member name="M:stringprep.steps.ProhibitStep.Contains(System.Char)">
            <summary>
            Does this step prohibit the given character?
            </summary>
            <param name="c">The character to check</param>
            <returns>True if the character is prohibited</returns>
        </member>
        <member name="M:stringprep.steps.ProhibitStep.FindStringInTable(System.Text.StringBuilder)">
            <summary>
            Check all of the characters for prohbition.
            </summary>
            <param name="s">String to check</param>
            <returns>If one of the characters is prohibited, returns the index of that character.
            If all are allowed, returns -1.</returns>
        </member>
        <member name="M:stringprep.steps.ProhibitStep.Prepare(System.Text.StringBuilder)">
            <summary>
            Check for prohibited characters
            </summary>
            <param name="result">No modifications</param>
            <exception cref="T:stringprep.steps.ProhibitedCharacterException">Invalid character detected.</exception>
        </member>
        <member name="T:jabber.protocol.stream.Error">
            <summary>
            Stream error packet.
            </summary>
        </member>
        <member name="M:jabber.protocol.stream.Error.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.stream.Error.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.stream.Error.Message">
            <summary>
            The error message
            </summary>
        </member>
        <member name="T:jabber.protocol.stream.Compression">
            <summary>
            XEP-138 compression.
            </summary>
        </member>
        <member name="M:jabber.protocol.stream.Compression.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create a new compression feature element.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.stream.Compression.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create a new compression element.
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.stream.Compression.HasMethod(System.String)">
            <summary>
            Does this compression element have the given method in it?
            </summary>
            <param name="method">The method to search for.  Typically: "zlib"</param>
            <returns></returns>
        </member>
        <member name="P:jabber.protocol.stream.Compression.Methods">
            <summary>
            The list of methods offered by the server.  Typically today, this will be one string: "zlib".
            </summary>
        </member>
        <member name="T:jabber.protocol.stream.CompressionFailure">
            <summary>
            XEP-138 compression failure.
            </summary>
        </member>
        <member name="M:jabber.protocol.stream.CompressionFailure.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create a new compression element.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.stream.CompressionFailure.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create a new compression element.
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.stream.CompressionFailure.Error">
            <summary>
            The error described by this failure.  One of:
            setup-failed
            processing-failed
            unsupported-method
            </summary>
        </member>
        <member name="T:jabber.protocol.stream.Compress">
            <summary>
            XEP-138 compression start.
            </summary>
        </member>
        <member name="M:jabber.protocol.stream.Compress.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create a new compress element.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.stream.Compress.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create a new compress element.
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.stream.Compress.Method">
            <summary>
            What compression method should be used?
            </summary>
        </member>
        <member name="T:jabber.protocol.stream.Compressed">
            <summary>
            XEP-138 compression success.
            </summary>
        </member>
        <member name="M:jabber.protocol.stream.Compressed.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create a new compression element.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.stream.Compressed.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create a new compression element.
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="T:xpnet.TokenException">
            <summary>
            Base class for other exceptions
            </summary>
        </member>
        <member name="T:xpnet.EmptyTokenException">
            <summary>
            An empty token was detected.  This only happens with a buffer of length 0 is passed in
            to the parser.
            </summary>
        </member>
        <member name="T:xpnet.EndOfPrologException">
            <summary>
            End of prolog.
            </summary>
        </member>
        <member name="T:xpnet.ExtensibleTokenException">
            Thrown to indicate that the byte subarray being tokenized is a legal XML
            token, but that subsequent bytes in the same entity could be part of
            the token.  For example, <code>Encoding.tokenizeProlog</code>
            would throw this if the byte subarray consists of a legal XML name.
            @version $Revision: 724 $ $Date: 2008-08-06 13:09:25 -0500 (Wed, 06 Aug 2008) $
        </member>
        <member name="M:xpnet.ExtensibleTokenException.#ctor(xpnet.TOK)">
             <summary>
            
             </summary>
             <param name="tokType"></param>
        </member>
        <member name="P:xpnet.ExtensibleTokenException.TokenType">
            Returns the type of token in the byte subarrary.
        </member>
        <member name="T:xpnet.InvalidTokenException">
            <summary>
            Several kinds of token problems.
            </summary>
        </member>
        <member name="F:xpnet.InvalidTokenException.ILLEGAL_CHAR">
            <summary>
            An illegal character
            </summary>
        </member>
        <member name="F:xpnet.InvalidTokenException.XML_TARGET">
            <summary>
            Doc prefix wasn't XML
            </summary>
        </member>
        <member name="F:xpnet.InvalidTokenException.DUPLICATE_ATTRIBUTE">
            <summary>
            More than one attribute with the same name on the same element
            </summary>
        </member>
        <member name="M:xpnet.InvalidTokenException.#ctor(System.Int32,System.Byte)">
            <summary>
            Some other type of bad token detected
            </summary>
            <param name="offset"></param>
            <param name="type"></param>
        </member>
        <member name="M:xpnet.InvalidTokenException.#ctor(System.Int32)">
            <summary>
            Illegal character detected
            </summary>
            <param name="offset"></param>
        </member>
        <member name="M:xpnet.InvalidTokenException.ToString">
            <summary>
            String
            </summary>
            <returns></returns>
        </member>
        <member name="P:xpnet.InvalidTokenException.Offset">
            <summary>
            Offset into the buffer where the problem ocurred.
            </summary>
        </member>
        <member name="P:xpnet.InvalidTokenException.Type">
            <summary>
            Type of exception
            </summary>
        </member>
        <member name="T:xpnet.PartialCharException">
            Thrown to indicate that the subarray being tokenized is not the
            complete encoding of one or more characters, but might be if
            more bytes were added.
            @version $Revision: 724 $ $Date: 2008-08-06 13:09:25 -0500 (Wed, 06 Aug 2008) $
        </member>
        <member name="T:xpnet.PartialTokenException">
            <summary>
            A partial token was received.  Try again, after you add more bytes to the buffer.
            </summary>
        </member>
        <member name="M:xpnet.PartialCharException.#ctor(System.Int32)">
             <summary>
            
             </summary>
             <param name="leadByteIndex"></param>
        </member>
        <member name="P:xpnet.PartialCharException.LeadByteIndex">
            Returns the index of the first byte that is not part of the complete
            encoding of a character.
        </member>
        <member name="T:stringprep.Nameprep">
            <summary>
            RFC 3491, "nameprep" profile, for internationalized domain names.
            </summary>
        </member>
        <member name="M:stringprep.Nameprep.#ctor">
            <summary>
            Create a nameprep instance.
            </summary>
        </member>
        <member name="T:jabber.protocol.x.Delay">
            <summary>
            A delay x element.
            </summary>
        </member>
        <member name="M:jabber.protocol.x.Delay.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.x.Delay.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.x.Delay.From">
            <summary>
            From whom?
            </summary>
        </member>
        <member name="P:jabber.protocol.x.Delay.Stamp">
            <summary>
            Date/time stamp.
            </summary>
        </member>
        <member name="P:jabber.protocol.x.Delay.Desc">
            <summary>
            Description
            </summary>
        </member>
        <member name="T:jabber.protocol.x.ModernDelay">
            <summary>
            A modern, XEP-0203 delay element
            </summary>
        </member>
        <member name="M:jabber.protocol.x.ModernDelay.#ctor(System.Xml.XmlDocument)">
             <summary>
            Create a delay element for sending
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.x.ModernDelay.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create a delay element from the received stream.
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.x.ModernDelay.From">
            <summary>
            From whom?
            </summary>
        </member>
        <member name="P:jabber.protocol.x.ModernDelay.Stamp">
            <summary>
            Date/time stamp.
            </summary>
        </member>
        <member name="P:jabber.protocol.x.ModernDelay.Desc">
            <summary>
            Description
            </summary>
        </member>
        <member name="T:jabber.protocol.x.Caps">
            <summary>
            Entity Capabilities.  See http://www.xmpp.org/extensions/xep-0115.html.
            </summary>
        </member>
        <member name="M:jabber.protocol.x.Caps.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.x.Caps.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.x.Caps.Node">
            <summary>
            The URI that describes the entity.
            </summary>
        </member>
        <member name="P:jabber.protocol.x.Caps.Version">
            <summary>
            The version of the entity.
            </summary>
        </member>
        <member name="P:jabber.protocol.x.Caps.Hash">
            <summary>
            The hash type being used, or null for pre-v1.5 of XEP-115.
            </summary>
        </member>
        <member name="P:jabber.protocol.x.Caps.NewStyle">
            <summary>
            Is this a new-style (post v1.5) caps?
            </summary>
        </member>
        <member name="P:jabber.protocol.x.Caps.Extensions">
            <summary>
            The extensions currently on in the entity.
            </summary>
        </member>
        <member name="P:jabber.protocol.x.Caps.DiscoInfoNodes">
            <summary>
            All of the combinations of node#ver, node#ext.
            </summary>
        </member>
        <member name="T:jabber.protocol.stream.Session">
            <summary>
            Session start after binding
            </summary>
        </member>
        <member name="M:jabber.protocol.stream.Session.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.stream.Session.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.stream.ConditionType">
            <summary>
            These error conditions may be read by constrained clients. 
            They are used for connection manager problems, abstracting stream errors, 
            communication problems between the connection manager and the server, 
            and invalid client requests (binding syntax errors, possible attacks, etc.)
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.ConditionType.UNSPECIFIED">
            <summary>
             None specified
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.ConditionType.host_gone">
            <summary>
            The target domain specified in the 'to' attribute or the target host or
            port specified in the 'route' attribute is no longer serviced by 
            the connection manager.
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.ConditionType.host_unknown">
            <summary>
            The target domain specified in the 'to' attribute or the target host
            or port specified in the 'route' attribute is unknown to the connection manager.
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.ConditionType.improper_addressing">
            <summary>
            The initialization element lacks a 'to' or 'route' attribute (or the 
            attribute has no value) but the connection manager requires one.
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.ConditionType.internal_server_error">
            <summary>
            The connection manager has experienced an internal error that prevents 
            it from servicing the request.
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.ConditionType.remote_connection_failed">
            <summary>
            The connection manager was unable to connect to, or unable to 
            connect securely to, or has lost its connection to, the server.
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.ConditionType.remote_stream_error">
            <summary>
            Encapsulates an error in the protocol being transported.
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.ConditionType.see_other_uri">
            <summary>
            The connection manager does not operate at this URI 
            (e.g., the connection manager accepts only SSL or TLS connections at 
            some https: URI rather than the http: URI requested by the client). 
            The client may try POSTing to the URI in the content of the <uri/> child element.
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.ConditionType.system_shutdown">
            <summary>
            The connection manager is being shut down. All active HTTP sessions are
            being terminated. No new sessions can be created.
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.ConditionType.undefined_condition">
            <summary>
            The error is not one of those defined herein; the connection manager SHOULD 
            include application-specific information in the content of the <body/> wrapper.
            </summary>
        </member>
        <member name="T:jabber.protocol.stream.BodyType">
            <summary>
            Is this an error or a termination?
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.BodyType.UNSPECIFIED">
            <summary>
            None specified
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.BodyType.error">
            <summary>
            Error encapsulated in response
            </summary>
        </member>
        <member name="F:jabber.protocol.stream.BodyType.terminate">
            <summary>
            Terminate the stream
            </summary>
        </member>
        <member name="T:jabber.protocol.stream.Body">
            <summary>
            An HTTP Binding body element, which encapsulates stanzas.
            See XEP-124 and XEP-206 for details.
            </summary>
        </member>
        <member name="M:jabber.protocol.stream.Body.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.stream.Body.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create inbound instance
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.stream.Body.Contents">
            <summary>
            The child elements of the body.  0 or more stanzas.
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Body.Accept">
            <summary>
            The content encodings that server can handle.
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Body.Ack">
            <summary>
            Acknowledgement of a given RID.
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Body.AuthID">
            <summary>
            Stream ID for digest auth calculations
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Body.Charsets">
            <summary>
            The charsets supported by the server.  Almost always just UTF8, if it exists.
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Body.Condition">
            <summary>
            The error condition, if this is an error.
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Body.Content">
            <summary>
            
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Body.From">
            <summary>
            A client MAY include a 'from' attribute to enable the 
            connection manager to forward its identity to the server.
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Body.Hold">
            <summary>
            This attribute specifies the maximum number of requests the connection manager 
            is allowed to keep waiting at any one time during the session. If the client 
            is not able to use HTTP Pipelining then this SHOULD be set to "1".
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Body.Inactivity">
            <summary>
            This attribute specifies the longest allowable inactivity period (in seconds). 
            This enables the client to ensure that the periods with no requests pending 
            are never too long (see Polling Sessions and Inactivity).
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Body.Key">
            <summary>
            The client MUST set the 'key' attribute of all subsequent requests to the 
            value of the next key in the generated sequence (decrementing from K(n-1) 
            towards K(1) with each request sent).
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Body.MaxPause">
            <summary>
            If the connection manager supports session pausing (see Inactivity) then it 
            SHOULD advertise that to the client by including a 'maxpause' attribute in 
            the session creation response element. The value of the attribute indicates 
            the maximum length of a temporary session pause (in seconds) that a client
            MAY request.
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Body.NewKey">
            <summary>
            The client MUST set the 'newkey' attribute of the first request in the session to the value K(n).
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Body.Pause">
            <summary>
            If a client encounters an exceptional temporary situation during which it 
            will be unable to send requests to the connection manager for a period of 
            time greater than the maximum inactivity period (e.g., while a runtime 
            environment changes from one web page to another), and if the connection 
            manager included a 'maxpause' attribute in its Session Creation Response,
            then the client MAY request a temporary increase to the maximum inactivity 
            period by including a 'pause' attribute in a request.
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Body.Polling">
            <summary>
            This attribute specifies the shortest allowable polling interval (in seconds). 
            This enables the client to not send empty request elements more often than desired.
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Body.Report">
            <summary>
            After receiving a request with an 'ack' value less than the 'rid' of the last
            request that it has already responded to, the connection manager MAY inform 
            the client of the situation by sending its next response immediately instead
            of waiting until it has stanzas to send to the client (e.g., if some time
            has passed since it responded). In this case it SHOULD include a 'report'
            attribute set to one greater than the 'ack' attribute it received from the 
            client, and a 'time' attribute set to the number of milliseconds since it 
            sent the response associated with the 'report' attribute.
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Body.Requests">
            <summary>
            This attribute enables the connection manager to limit the number of 
            simultaneous requests the client makes. The RECOMMENDED values are 
            either "2" or one more than the value of the 'hold' attribute specified 
            in the session request.
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Body.RID">
            <summary>
            Request ID.  Needs to start out random, and increment by one for each new BOSH
            request.
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Body.Route">
            <summary>
            connection manager MAY be configured to enable sessions with more than one 
            server in different domains.  When requesting a session with such a 'proxy' 
            connection manager, a client SHOULD include a 'route' attribute that 
            specifies the protocol, hostname, and port of the server with which it 
            wants to communicate, formatted as "proto:host:port" 
            (e.g., "xmpp:jabber.org:9999").
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Body.Secure">
            <summary>
            A client MAY include a 'secure' attribute to specify that communications 
            between the connection manager and the server must be "secure". (Note: The
            'secure' attribute is of type xs:boolean (see XML Schema Part 2) and the 
            default value is "false". [17]) If a connection manager receives a session
            request with the 'secure' attribute set to "true" or "1", then it MUST 
            respond to the client with a remote-connection-failed error as soon as it
            determines that it cannot communicate in a secure way with the server.
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Body.SID">
            <summary>
            Stream ID
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Body.Stream">
            <summary>
            If a connection manager supports the multi-streams feature, it MUST 
            include a 'stream' attribute in its Session Creation Response. If a
            client does not receive the 'stream' attribute then it MUST assume 
            that the connection manager does not support the feature. [22]
            
            The 'stream' attribute identifies the first stream to be opened for 
            the session. The value of each 'stream' attribute MUST be an opaque 
            and unpredictable name that is unique within the context of the 
            connection manager application.
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Body.Time">
            <summary>
            After receiving a request with an 'ack' value less than the 'rid' 
            of the last request that it has already responded to, the connection 
            manager MAY inform the client of the situation by sending its next
            response immediately instead of waiting until it has stanzas to
            send to the client (e.g., if some time has passed since it responded).
            In this case it SHOULD include a 'report' attribute set to one greater
            than the 'ack' attribute it received from the client, and a 'time' 
            attribute set to the number of milliseconds since it sent the response
            associated with the 'report' attribute.
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Body.To">
            <summary>
            This attribute specifies the target domain of the first stream.
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Body.Type">
            <summary>
            At any time, the client MAY gracefully terminate the session by sending a <body/> 
            element with a 'type' attribute set to "terminate". The termination request 
            MAY include one or more stanzas that the connection manager MUST forward to 
            the server to ensure graceful logoff.
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Body.Ver">
            <summary>
            This attribute specifies the highest version of the BOSH protocol 
            that the client supports. The numbering scheme is "major.minor" 
            (where the minor number MAY be incremented higher than a single digit, 
            so it MUST be treated as a separate integer). Note: The 'ver' attribute 
            should not be confused with the version of any protocol being transported.
            </summary>
        </member>
        <member name="P:jabber.protocol.stream.Body.Wait">
            <summary>
            This attribute specifies the longest time (in seconds) that the connection
            manager is allowed to wait before responding to any request during the session. 
            This enables the client to limit the delay before it discovers any network failure, 
            and to prevent its HTTP/TCP connection from expiring due to inactivity.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.RosterIQ">
            <summary>
            IQ packet with a roster query element inside.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.RosterIQ.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create a roster IQ.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.Roster">
            <summary>
            A roster query element.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.Roster.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Roster.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Roster.AddItem">
            <summary>
            Add a roster item
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.Roster.GetItems">
            <summary>
            List of roster items
            </summary>
            <returns></returns>
        </member>
        <member name="T:jabber.protocol.iq.Subscription">
            <summary>
            The current status of the subscription related to this item.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.Subscription.UNSPECIFIED">
            <summary>
            No subscription state has been specified.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.Subscription.to">
            <summary>
            Subscription to this person.  They are a lurkee.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.Subscription.from">
            <summary>
            Subscription from this person.  They are a lurker.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.Subscription.both">
            <summary>
            subscriptions in both ways.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.Subscription.none">
            <summary>
            No subscription yet.  Often an Ask on this item.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.Subscription.remove">
            <summary>
            Remove this subscription from the local roster.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.Ask">
            <summary>
            An optional attribute specifying the current status of a request to this contact.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.Ask.NONE">
            <summary>
            No Ask specified.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.Ask.subscribe">
            <summary>
            this entity is asking to subscribe to that contact's presence
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.Ask.unsubscribe">
            <summary>
            this entity is asking unsubscribe from that contact's presence
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.Item">
            <summary>
            Roster items.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.Item.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Item.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Item.AddGroup(System.String)">
            <summary>
            Add an item group, or return an existing group with the given name
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.Item.RemoveGroup(System.String)">
            <summary>
            Remove a group of the given name.  Does nothing if that group is not found.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:jabber.protocol.iq.Item.GetGroups">
            <summary>
            List of item groups
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.Item.HasGroup(System.String)">
            <summary>
            Is this item in the specified group?
            </summary>
            <param name="name">The name of the group to check</param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.Item.GetGroup(System.String)">
            <summary>
            Get the group object of the given name in this item.
            If there is no group of that name, returns null.
            </summary>
            <param name="name">The name of the group to return</param>
            <returns>null if none found.</returns>
        </member>
        <member name="P:jabber.protocol.iq.Item.JID">
            <summary>
            Item JID
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Item.Nickname">
            <summary>
            The user's nick
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Item.Subscription">
            <summary>
            How are we subscribed?
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Item.Ask">
            <summary>
            Pending?
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.Group">
            <summary>
            Roster item groups.  &lt;group&gt;GroupName&lt;/group&gt;
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.Group.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Group.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.Group.GroupName">
            <summary>
            Name of the group.
            </summary>
        </member>
        <member name="T:jabber.protocol.XMLAttribute">
            <summary>
            How should the marked-up entity be rendered in XML?  Only used
            for enums that are going to be put in attributes at the moment.
            TODO: support namespaces, use for element definitions.
            </summary>
        </member>
        <member name="M:jabber.protocol.XMLAttribute.#ctor(System.String)">
            <summary>
            Create
            </summary>
            <param name="name"></param>
        </member>
        <member name="P:jabber.protocol.XMLAttribute.Name">
            <summary>
            The string to use when converting to and from XML.
            </summary>
        </member>
        <member name="T:jabber.protocol.EnumParser">
            <summary>
            Parse enums
            </summary>
        </member>
        <member name="M:jabber.protocol.EnumParser.Parse``1(System.String)">
            <summary>
            Parse a string into an enum value for the given type T.  
            Any errors map to -1.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.EnumParser.Parse(System.String,System.Type)">
            <summary>
            Parse a string into an enum value for the given type.  
            Any errors map to -1.
            </summary>
            <param name="value"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.EnumParser.ToString(System.Object)">
            <summary>
            Convert an enum value into its string representation.
            any -1 value gets mapped to null.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:jabber.protocol.QnameType">
            <summary>
            Qname to type mapping.
            </summary>
        </member>
        <member name="F:jabber.protocol.QnameType.Name">
            <summary>
            Element name
            </summary>
        </member>
        <member name="F:jabber.protocol.QnameType.NS">
            <summary>
            Element namespace URI
            </summary>
        </member>
        <member name="F:jabber.protocol.QnameType.ElementType">
            <summary>
            Type to create for NS/Name pair
            </summary>
        </member>
        <member name="M:jabber.protocol.QnameType.#ctor(System.String,System.String,System.Type)">
            <summary>
            Create a QnameType
            </summary>
            <param name="name"></param>
            <param name="ns"></param>
            <param name="typ"></param>
        </member>
        <member name="M:jabber.protocol.QnameType.Equals(System.Object)">
            <summary>
            Is this the same qname by element name and namespace?
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.QnameType.GetHashCode">
            <summary>
            Get a hash over the name and namespace.
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.QnameType.ToString">
            <summary>
            Namespace|Name
            </summary>
            <returns></returns>
        </member>
        <member name="T:jabber.protocol.ElementFactory">
            <summary>
            A ElementFactory is a class that knows how to create packet instances of
            a wide variety of different types.
            </summary>
        </member>
        <member name="M:jabber.protocol.ElementFactory.AddType(System.String,System.String,System.Type)">
            <summary>
            Add a type to the packet factory.
            </summary>
            <param name="localName"></param>
            <param name="ns"></param>
            <param name="t"></param>
        </member>
        <member name="M:jabber.protocol.ElementFactory.AddType(System.Xml.XmlQualifiedName,System.Type)">
            <summary>
            Add a type to the packet factory.
            </summary>
            <param name="qname"></param>
            <param name="t"></param>
        </member>
        <member name="M:jabber.protocol.ElementFactory.AddType(System.Xml.XmlQualifiedName,System.Reflection.ConstructorInfo)">
            <summary>
            Add a type to the packet factory.
            </summary>
            <param name="qname"></param>
            <param name="ci"></param>
        </member>
        <member name="M:jabber.protocol.ElementFactory.AddType(jabber.protocol.IPacketTypes)">
            <summary>
            Add a type to the packet factory.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:jabber.protocol.ElementFactory.GetElement(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create an element of the appropriate type, based on the qname of the packet.
            </summary>
            <param name="prefix">The namespace prefix for the element</param>
            <param name="qname">The namespaceURI/element name pair</param>
            <param name="doc">The document to create the element in.</param>
            <returns></returns>
        </member>
        <member name="P:jabber.protocol.ElementFactory.Item(System.Xml.XmlQualifiedName)">
            <summary>
            Get a constructor for the appropriate type for the given qname.
            </summary>
        </member>
        <member name="T:jabber.connection.ConnectionType">
            <summary>
            Specifies the connection type, such as socket, polling, and so on.
            </summary>
        </member>
        <member name="F:jabber.connection.ConnectionType.Socket">
            <summary>
            Uses "Normal" XMPP socket
            </summary>
        </member>
        <member name="F:jabber.connection.ConnectionType.HTTP_Polling">
            <summary>
            Uses HTTP Polling, as in http://www.xmpp.org/extensions/xep-0025.html
            </summary>
        </member>
        <member name="F:jabber.connection.ConnectionType.HTTP_Binding">
            <summary>
            Uses HTTP Binding, as in http://www.xmpp.org/extensions/xep-0124.html
            </summary>
        </member>
        <member name="T:jabber.connection.StanzaStreamHandler">
            <summary>
            Informs the client that something happened on a StanzaStream.
            </summary>
        </member>
        <member name="T:bedrock.util.ConfigFile">
            <summary>
            XML configuration file manager.
            </summary>
        </member>
        <member name="M:bedrock.util.ConfigFile.GetInstance(System.String)">
            <summary>
            Singleton factory
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:bedrock.util.ConfigFile.GetNode(System.String)">
            <summary>
            Get the configuration file XML node associated
            with a given XPath query.
            </summary>
            <param name="xpath"></param>
            <returns></returns>
        </member>
        <member name="M:bedrock.util.ConfigFile.GetNodes(System.String)">
            <summary>
            Get the configuration file XML nodes associated with a give XPath query
            </summary>
            <param name="xpath"></param>
            <returns></returns>
        </member>
        <member name="E:bedrock.util.ConfigFile.OnFileChange">
            <summary>
            The config file has been modified, and reloaded.
            </summary>
        </member>
        <member name="P:bedrock.util.ConfigFile.Filename">
            <summary>
            The full path of the filename being used.
            </summary>
        </member>
        <member name="P:bedrock.util.ConfigFile.Item(System.String)">
            <summary>
            Get the configuration file string associated
            with a given XPath query, or null if not found.
            </summary>
        </member>
        <member name="P:bedrock.util.ConfigFile.Item(System.String,System.String)">
            <summary>
            Get the configuration file string associated
            with a given XPath query, or defaultValue if not found.
            </summary>
        </member>
        <member name="T:bedrock.net.XEP25Exception">
            <summary>
            XEP25 Error conditions
            </summary>
        </member>
        <member name="M:bedrock.net.XEP25Exception.#ctor(System.String)">
             <summary>
            
             </summary>
             <param name="reason"></param>
        </member>
        <member name="T:bedrock.net.XEP25Socket">
            <summary>
            Make a XEP-25 (http://www.xmpp.org/extensions/xep-0025.html) polling "connection" look like a socket.
            TODO: get rid of the PipeStream, if possible.
            </summary>
        </member>
        <member name="F:bedrock.net.XEP25Socket.UntrustedRootOK">
            <summary>
            Do trust all server sertificates?
            </summary>
        </member>
        <member name="M:bedrock.net.XEP25Socket.#ctor(bedrock.net.ISocketEventListener)">
            <summary>
            Create an instance
            </summary>
            <param name="listener"></param>
        </member>
        <member name="M:bedrock.net.XEP25Socket.Accept(bedrock.net.Address,System.Int32)">
            <summary>
            Accept a socket.  Not implemented.
            </summary>
            <param name="addr"></param>
            <param name="backlog"></param>
        </member>
        <member name="M:bedrock.net.XEP25Socket.Close">
            <summary>
            Stop polling.
            </summary>
        </member>
        <member name="M:bedrock.net.XEP25Socket.Connect(bedrock.net.Address)">
            <summary>
            Start polling
            </summary>
            <param name="addr"></param>
        </member>
        <member name="M:bedrock.net.XEP25Socket.RequestAccept">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="M:bedrock.net.XEP25Socket.RequestRead">
            <summary>
            Start reading.
            </summary>
        </member>
        <member name="M:bedrock.net.XEP25Socket.StartTLS">
            <summary>
            Start TLS over this connection.  Not implemented.
            </summary>
        </member>
        <member name="M:bedrock.net.XEP25Socket.StartCompression">
            <summary>
            Start TLS over this connection.  Not implemented.
            </summary>
        </member>
        <member name="M:bedrock.net.XEP25Socket.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Send bytes to the jabber server
            </summary>
            <param name="buf"></param>
            <param name="offset"></param>
            <param name="len"></param>
        </member>
        <member name="M:bedrock.net.XEP25Socket.PollThread">
            <summary>
            Keep polling until
            </summary>
        </member>
        <member name="M:bedrock.net.XEP25Socket.ToString">
            <summary>
            Descripton, including poll URL.
            </summary>
            <returns></returns>
        </member>
        <member name="P:bedrock.net.XEP25Socket.MaxPoll">
            <summary>
            Maximum time between polls, in seconds
            </summary>
        </member>
        <member name="P:bedrock.net.XEP25Socket.MinPoll">
            <summary>
            Minimum time between polls, in seconds
            </summary>
        </member>
        <member name="P:bedrock.net.XEP25Socket.URL">
            <summary>
            The URL to poll
            </summary>
        </member>
        <member name="P:bedrock.net.XEP25Socket.NumKeys">
            <summary>
            The number of keys to generate at a time.  Higher numbers use more memory,
            and more CPU to generate keys, less often.  Defaults to 512.
            </summary>
        </member>
        <member name="P:bedrock.net.XEP25Socket.Proxy">
            <summary>
            Proxy information.  My guess is if you leave this null, the IE proxy
            info may be used.  Not tested.
            </summary>
        </member>
        <member name="P:bedrock.net.XEP25Socket.LocalCertificate">
            <summary>
            The local certificate of the socket.
            </summary>
        </member>
        <member name="P:bedrock.net.XEP25Socket.RemoteCertificate">
            <summary>
            The remote certificate.
            </summary>
        </member>
        <member name="P:bedrock.net.XEP25Socket.Connected">
            <summary>
            Is socket connected.
            </summary>
        </member>
        <member name="T:bedrock.net.AsyncSocketConnectionException">
            <summary>
            Lame exception, since I couldn't find one I liked.
            </summary>
        </member>
        <member name="M:bedrock.net.AsyncSocketConnectionException.#ctor(System.String)">
            <summary>
            Create a new exception instance.
            </summary>
            <param name="description"></param>
        </member>
        <member name="M:bedrock.net.AsyncSocketConnectionException.#ctor">
            <summary>
            Create a new exception instance.
            </summary>
        </member>
        <member name="M:bedrock.net.AsyncSocketConnectionException.#ctor(System.String,System.Exception)">
            <summary>
            Create a new exception instance, wrapping another exception.
            </summary>
            <param name="description">Desecription of the exception</param>
            <param name="e">Inner exception</param>
        </member>
        <member name="M:bedrock.net.AsyncSocketConnectionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the
            AsyncSocketConnectionException class with serialized
            data.
            </summary>
            <param name="info">The object that holds the serialized
            object data.</param>
            <param name="ctx">The contextual information about the
            source or destination.</param>
        </member>
        <member name="T:bedrock.ObjectHandler">
            <summary>
            Delegate for memebers that just have a sender
            </summary>
        </member>
        <member name="T:bedrock.TextHandler">
            <summary>
            Delegate for members that receive a string
            </summary>
        </member>
        <member name="T:bedrock.ByteHandler">
            <summary>
            Delegate for methods that get a block of bytes
            </summary>
        </member>
        <member name="T:bedrock.ByteOffsetHandler">
            <summary>
            Delegate for members that receive partial blocks of bytes.
            </summary>
        </member>
        <member name="T:bedrock.ExceptionHandler">
            <summary>
            Delegate for members that receive an exception
            </summary>
        </member>
        <member name="T:bedrock.collections.LinkedList">
            <summary>
            A doubly-linked list implementation, with a sentinal wrap-around
            m_header.  Yes, it <b>does</b> seem like this should have been included
            in System.Collections.  This may be a nicer implementation of Queue
            than the one in System.Collections, which uses an array.  YMMV.
            </summary>
        </member>
        <member name="M:bedrock.collections.LinkedList.#ctor">
            <summary>
            Creates an empty list.
            </summary>
        </member>
        <member name="M:bedrock.collections.LinkedList.#ctor(System.Collections.IEnumerable)">
            <summary>
            Create a list with the targets of the given
            enumeration copied into it.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:bedrock.collections.LinkedList.GetEnumerator">
            <summary>
            Iterate over the list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:bedrock.collections.LinkedList.CopyTo(System.Array,System.Int32)">
            <summary>
            Copy this list to the given array.
            </summary>
            <param name="array">Array to copy into</param>
            <param name="index">Index to start copying at</param>
        </member>
        <member name="M:bedrock.collections.LinkedList.Add(System.Object)">
            <summary>
            Insert an element at the end of the list
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:bedrock.collections.LinkedList.Clear">
            <summary>
            Remove all of the elements.
            </summary>
        </member>
        <member name="M:bedrock.collections.LinkedList.Contains(System.Object)">
            <summary>
            Is the given object in the list?
            </summary>
            <param name="value">The object to find</param>
            <returns>True if the object is in the list</returns>
        </member>
        <member name="M:bedrock.collections.LinkedList.IndexOf(System.Object)">
            <summary>
            Determines where in the index the specified object exists.
            </summary>
            <param name="value">The object to find</param>
            <returns>The position of the object in the list, or -1 if not found</returns>
        </member>
        <member name="M:bedrock.collections.LinkedList.Insert(System.Int32,System.Object)">
            <summary>
            Inserts an item into the list at the given index.
            </summary>
            <param name="index">The position to insert before</param>
            <param name="value">The object to insert</param>
        </member>
        <member name="M:bedrock.collections.LinkedList.Remove(System.Object)">
            <summary>
            Finds the first matching object, and removes it from the list.
            </summary>
            <param name="value">The object to remove</param>
            <exception cref="T:System.ArgumentException">Object not found</exception>
        </member>
        <member name="M:bedrock.collections.LinkedList.RemoveAt(System.Int32)">
            <summary>
            Removes the indexth element from the list.
            </summary>
            <param name="index">The index of the element to delete</param>
        </member>
        <member name="M:bedrock.collections.LinkedList.Enqueue(System.Object)">
            <summary>
            Inserts an element at the end of the list.
            </summary>
            <param name="value">Element to insert.</param>
        </member>
        <member name="M:bedrock.collections.LinkedList.Dequeue">
            <summary>
            Remove and return the element at the front of the list
            </summary>
            <returns>The element at the end of the list</returns>
        </member>
        <member name="M:bedrock.collections.LinkedList.Peek">
            <summary>
            Retrieve the element at the front of the list, without removing it.
            </summary>
            <returns></returns>
        </member>
        <member name="M:bedrock.collections.LinkedList.Push(System.Object)">
            <summary>
            Add an element to the front of the list.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:bedrock.collections.LinkedList.Pop">
            <summary>
            Retrieve and remove the element at the front of the list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:bedrock.collections.LinkedList.ToString">
            <summary>
            Comma-separated list of element.ToString()'s.
            </summary>
            <returns></returns>
        </member>
        <member name="M:bedrock.collections.LinkedList.Insert(System.Object)">
            <summary>
            Insert in order.
            </summary>
            <param name="value">Value to insert.</param>
            <returns>The position of the insertion point.</returns>
        </member>
        <member name="M:bedrock.collections.LinkedList.ReadOnly(System.Collections.IEnumerable)">
            <summary>
            Returns a read-only linked list from the given enumeration.
            </summary>
            <param name="e">Collection to be copied over to the read-only list.</param>
            <returns>The new read-only list.</returns>
        </member>
        <member name="P:bedrock.collections.LinkedList.Count">
            <summary>
            How many elements in the list?
            </summary>
        </member>
        <member name="P:bedrock.collections.LinkedList.IsReadOnly">
            <summary>
            Determines if the list is read-only (Can the user add or remove an item from this list).
            </summary>
        </member>
        <member name="P:bedrock.collections.LinkedList.IsSynchronized">
            <summary>
            Is the list thread-safe?
            TODO: implement thread-safe
            </summary>
        </member>
        <member name="P:bedrock.collections.LinkedList.SyncRoot">
            <summary>
            The object to synchronize on.
            TODO: implement settable SyncRoot
            </summary>
        </member>
        <member name="P:bedrock.collections.LinkedList.Item(System.Int32)">
            <summary>
            Gets the indexth element by walking the list.
            </summary>
        </member>
        <member name="P:bedrock.collections.LinkedList.IsFixedSize">
            <summary>
            Always returns "false" for now.
            TODO: implement fixed size
            </summary>
        </member>
        <member name="P:bedrock.collections.LinkedList.Comparator">
            <summary>
            The object to use for comparisons.
            </summary>
        </member>
        <member name="T:stringprep.steps.ProhibitedCharacterException">
            <summary>
            A character that is forbidden by the current stringprep profile exists in the input.
            </summary>
        </member>
        <member name="F:stringprep.steps.ProhibitedCharacterException.InvalidChar">
            <summary>
            The character that was invalid.
            </summary>
        </member>
        <member name="M:stringprep.steps.ProhibitedCharacterException.#ctor(stringprep.steps.ProfileStep,System.Char)">
            <summary>
            Create an instance.
            </summary>
            <param name="step">In which step did this occur?</param>
            <param name="c">The offending character</param>
        </member>
        <member name="T:jabber.protocol.stream.StartTLS">
            <summary>
            Start-TLS in stream features.
            </summary>
        </member>
        <member name="M:jabber.protocol.stream.StartTLS.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.stream.StartTLS.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.stream.StartTLS.Required">
            <summary>
            Is starttls required?
            </summary>
        </member>
        <member name="T:jabber.protocol.stream.Proceed">
            <summary>
            Start-TLS proceed.
            </summary>
        </member>
        <member name="M:jabber.protocol.stream.Proceed.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.stream.Proceed.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.stream.TLSFailure">
            <summary>
            Start-TLS failure.
            </summary>
        </member>
        <member name="M:jabber.protocol.stream.TLSFailure.#ctor(System.Xml.XmlDocument,System.String)">
             <summary>
            
             </summary>
             <param name="doc"></param>
             <param name="xmlns"></param>
        </member>
        <member name="M:jabber.protocol.stream.TLSFailure.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.client.MessageType">
            <summary>
            Message type attribute
            </summary>
        </member>
        <member name="F:jabber.protocol.client.MessageType.normal">
            <summary>
            Normal message
            </summary>
        </member>
        <member name="F:jabber.protocol.client.MessageType.error">
            <summary>
            Error message
            </summary>
        </member>
        <member name="F:jabber.protocol.client.MessageType.chat">
            <summary>
            Chat (one-to-one) message
            </summary>
        </member>
        <member name="F:jabber.protocol.client.MessageType.groupchat">
            <summary>
            Groupchat
            </summary>
        </member>
        <member name="F:jabber.protocol.client.MessageType.headline">
            <summary>
            Headline
            </summary>
        </member>
        <member name="T:jabber.protocol.client.Message">
            <summary>
            A client-to-client message.
            TODO: Some XHTML is supported by setting the .Html property,
            but extra xmlns="" get put everywhere at the moment.
            </summary>
        </member>
        <member name="M:jabber.protocol.client.Message.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.client.Message.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.client.Message.Type">
            <summary>
            The message type attribute
            </summary>
        </member>
        <member name="P:jabber.protocol.client.Message.Html">
            <summary>
            On set, creates both an html element, and a body element, which will
            have the de-html'd version of the html element.
            </summary>
        </member>
        <member name="P:jabber.protocol.client.Message.Body">
            <summary>
            The message body
            </summary>
        </member>
        <member name="P:jabber.protocol.client.Message.Thread">
            <summary>
            The message thread
            TODO: some help to generate these, please.
            </summary>
        </member>
        <member name="P:jabber.protocol.client.Message.Subject">
            <summary>
            The message subject
            </summary>
        </member>
        <member name="P:jabber.protocol.client.Message.X">
            <summary>
            The first x tag, regardless of namespace.
            </summary>
        </member>
        <member name="P:jabber.protocol.client.Message.Error">
            <summary>
            Message error.
            </summary>
        </member>
        <member name="T:jabber.protocol.accept.Factory">
            <summary>
            A packet factory for the jabber:component:accept namespace.
            </summary>
        </member>
        <member name="T:jabber.connection.RunningState">
            <summary>
            Specifies the state is up and running.  If subclasses change the
            state transition approach, they should end at the RunningState state.
            </summary>
        </member>
        <member name="F:jabber.connection.RunningState.Instance">
            <summary>
            Returns the instance of the running state.
            </summary>
        </member>
        <member name="T:jabber.connection.ClosedState">
            <summary>
            Specifies the state is not connected.
            </summary>
        </member>
        <member name="F:jabber.connection.ClosedState.Instance">
            <summary>
            Returns the instance of the closed state.
            </summary>
        </member>
        <member name="T:jabber.connection.ConnectingState">
            <summary>
            Specifies the state is in the process of connecting such as
            DNS lookup, socket setup, and so on.
            </summary>
        </member>
        <member name="F:jabber.connection.ConnectingState.Instance">
            <summary>
            Returns the instance of the connecting state.
            </summary>
        </member>
        <member name="T:jabber.connection.ConnectedState">
            <summary>
            Specifies the state is in the "connected socket" state.
            </summary>
        </member>
        <member name="F:jabber.connection.ConnectedState.Instance">
            <summary>
            The instance that is always used.
            </summary>
        </member>
        <member name="T:jabber.connection.StreamState">
            <summary>
            Specifies the state is in the "stream:stream has been received" state.
            </summary>
        </member>
        <member name="F:jabber.connection.StreamState.Instance">
            <summary>
            Returns the instance of the XMPP stream state.
            </summary>
        </member>
        <member name="T:jabber.connection.ClosingState">
            <summary>
            Specifies the state is in a closing state.
            A close was requested, but hasn't yet finalized.
            </summary>
        </member>
        <member name="F:jabber.connection.ClosingState.Instance">
            <summary>
            Returns the instance for the closing state.
            </summary>
        </member>
        <member name="T:jabber.connection.ReconnectingState">
            <summary>
            Specifies the state is in a paused state waiting for reconnect timeout.
            </summary>
        </member>
        <member name="F:jabber.connection.ReconnectingState.Instance">
            <summary>
            Returns the instance of the reconnecting state.
            </summary>
        </member>
        <member name="T:jabber.connection.AcceptingState">
            <summary>
            Specifies the state is in the "Accepting incoming socket connections" state.
            </summary>
        </member>
        <member name="F:jabber.connection.AcceptingState.Instance">
            <summary>
            Returns the instance of the accepting state.
            </summary>
        </member>
        <member name="T:jabber.connection.NonSASLAuthState">
            <summary>
            Specifies the state is in Old-style auth, iq:auth or handshake.
            </summary>
        </member>
        <member name="F:jabber.connection.NonSASLAuthState.Instance">
            <summary>
            Returns the instance of the non SASL authentication state.
            </summary>
        </member>
        <member name="T:jabber.connection.ServerFeaturesState">
            <summary>
            Specifies the state is in waiting for the server to send the features element.
            </summary>
        </member>
        <member name="F:jabber.connection.ServerFeaturesState.Instance">
            <summary>
            Returns the instance of the server features state.
            </summary>
        </member>
        <member name="T:jabber.connection.StartTLSState">
            <summary>
            Specifies the state is in Start-TLS.
            </summary>
        </member>
        <member name="F:jabber.connection.StartTLSState.Instance">
            <summary>
            Returns the instance of the Start-TLS state.
            </summary>
        </member>
        <member name="T:jabber.connection.CompressionState">
            <summary>
            Specifies the state is in the compression state.
            </summary>
        </member>
        <member name="F:jabber.connection.CompressionState.Instance">
            <summary>
            The instance that is always used.
            </summary>
        </member>
        <member name="T:jabber.connection.SASLState">
            <summary>
            Specifies the state is in SASL Authentication.
            </summary>
        </member>
        <member name="F:jabber.connection.SASLState.Instance">
            <summary>
            Returns the instance of the SASL state.
            </summary>
        </member>
        <member name="T:jabber.connection.SASLAuthedState">
            <summary>
            Specifies the state is in the SASL Authentication has finished state.
            Restarting the stream for the last time.
            </summary>
        </member>
        <member name="F:jabber.connection.SASLAuthedState.Instance">
            <summary>
            Returns the instance for the SASL authentication state.
            </summary>
        </member>
        <member name="T:jabber.connection.SASLFailedState">
            <summary>
            SASL Authentication failed.  On some servers you can re-try, or register.
            </summary>
        </member>
        <member name="F:jabber.connection.SASLFailedState.Instance">
            <summary>
            The instance that is always used.
            </summary>
        </member>
        <member name="T:jabber.connection.BindState">
            <summary>
            Specifies the state is in the "Binding session" state.
            </summary>
        </member>
        <member name="F:jabber.connection.BindState.Instance">
            <summary>
            Returns the instance for the Bind state.
            </summary>
        </member>
        <member name="T:bedrock.collections.SkipList">
            <summary>
            Summary description for SkipList.
            </summary>
        </member>
        <member name="F:bedrock.collections.SkipList.DEFAULT_PROBABILITY">
            <summary>
            The default probability for adding new node levels.
            .25 provides a good balance of speed and size.
            .5 will be slightly less variable in run time,
            and take up more space
            </summary>
        </member>
        <member name="F:bedrock.collections.SkipList.DEFAULT_MAX_LEVEL">
            <summary>
            The maximum depth for searching.
            log(1/p, n), where n is the max number of
            expected nodes.  For the defaults, n = 4096.
            The list will continue to work for larger lists,
            but performance will start to degrade toward
            that of a linear search to further you get
            above n.
            TODO: automatically reset max_level when Length
            goes above n.
            </summary>
        </member>
        <member name="M:bedrock.collections.SkipList.#ctor">
            <summary>
            Creates a skiplist with the default probability (0.25).
            </summary>
        </member>
        <member name="M:bedrock.collections.SkipList.#ctor(System.Single)">
            <summary>
            Create a skiplist with the default max_level.
            </summary>
            <param name="probability">Probability of adding a new level</param>
        </member>
        <member name="M:bedrock.collections.SkipList.#ctor(System.Single,System.Int32)">
            <summary>
            Create a skiplist.
            </summary>
            <param name="probability">Probability of adding a new level</param>
            <param name="maxLevel">Highest level in the list</param>
        </member>
        <member name="M:bedrock.collections.SkipList.Add(System.Object,System.Object)">
            <summary>
            Add an item to the list.
            </summary>
            <param name="key">Key for later retrieval.
            Must implement IComparable.</param>
            <param name="val">The value to store</param>
            <exception cref="T:System.ArgumentException">Thrown if the same key is added twice</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if key is null</exception>
        </member>
        <member name="M:bedrock.collections.SkipList.Contains(System.Object)">
            <summary>
            Is the given key found in the tree?
            </summary>
            <param name="key">The key to search for</param>
            <returns></returns>
        </member>
        <member name="M:bedrock.collections.SkipList.Clear">
            <summary>
            Remove all of the items from the list.
            </summary>
        </member>
        <member name="M:bedrock.collections.SkipList.Remove(System.Object)">
            <summary>
            Removes the item associated with this key from the list.
            </summary>
            <param name="key">Object that implements IComparable</param>
        </member>
        <member name="M:bedrock.collections.SkipList.GetEnumerator">
            <summary>
            Iterate over the list
            </summary>
            <returns></returns>
        </member>
        <member name="M:bedrock.collections.SkipList.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Iterate over the list
            </summary>
            <returns></returns>
        </member>
        <member name="M:bedrock.collections.SkipList.CopyTo(System.Array,System.Int32)">
            <summary>
            Copy the *values* from this list to the given array.
            It's not clear from the .Net docs wether this should be
            entries or values, so I chose values.
            </summary>
            <param name="array">The array to copy into</param>
            <param name="arrayIndex">The index to start at</param>
        </member>
        <member name="P:bedrock.collections.SkipList.Count">
            <summary>
            Gets the current number of elements in the list.
            </summary>
        </member>
        <member name="P:bedrock.collections.SkipList.Item(System.Object)">
            <summary>
            Looks up the key, and returns the corresponding value, or null if not found.
            </summary>
        </member>
        <member name="P:bedrock.collections.SkipList.IsFixedSize">
            <summary>
            Returns true if the list will not accept more items than constructed with.
            </summary>
        </member>
        <member name="P:bedrock.collections.SkipList.IsReadOnly">
            <summary>
            Returns true if one is unable to add or removed an item from this list.
            </summary>
        </member>
        <member name="P:bedrock.collections.SkipList.Keys">
            <summary>
            Gets all of the keys in the list.
            </summary>
        </member>
        <member name="P:bedrock.collections.SkipList.Values">
            <summary>
            Gets all of the values in the list.
            </summary>
        </member>
        <member name="P:bedrock.collections.SkipList.IsSynchronized">
            <summary>
            Returns false, for now
            </summary>
        </member>
        <member name="P:bedrock.collections.SkipList.SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to ICollection.
            </summary>
            <exception cref="T:System.NotImplementedException">Currently this Property is not implemented.</exception>
        </member>
        <member name="T:bedrock.collections.SkipList.Ali">
            <summary>
            An object that is the greatest.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.TimeIQ">
            <summary>
            IQ packet with an time query element inside.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.TimeIQ.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create a time IQ
            </summary>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.Time">
            <summary>
            A time query element.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.Time.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Time.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Time.SetCurrentTime">
            <summary>
            Set the current UTC, TZ, and Display based on the machine's current settings/locale.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Time.UTC">
            <summary>
            Universal coordinated time.  (More or less GMT).
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Time.TZ">
            <summary>
            Timezone
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Time.Display">
            <summary>
            Human-readable date/time.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.ClosedNode">
            <summary>
            For nodes with a node access model of "whitelist", if the requesting 
            entity is not on the whitelist then the service MUST return a 
            not-allowed error, specifying a pubsub-specific error condition of closed-node.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.ClosedNode.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.ClosedNode.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.ConfigurationRequired">
            <summary>
            The node must be configured.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.ConfigurationRequired.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.ConfigurationRequired.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.InvalidJID">
            <summary>
            An invalid JID was specified
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.InvalidJID.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.InvalidJID.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.InvalidOptions">
            <summary>
            Invalid options were specified
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.InvalidOptions.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.InvalidOptions.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.InvalidPayload">
            <summary>
            An invalid item was specified.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.InvalidPayload.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.InvalidPayload.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.InvalidSubid">
            <summary>
            An invalid ID was specified.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.InvalidSubid.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.InvalidSubid.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.ItemForbidden">
            <summary>
            An item was forbidden.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.ItemForbidden.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.ItemForbidden.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.ItemRequired">
            <summary>
            An item was required, but was not specified.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.ItemRequired.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.ItemRequired.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.JIDRequired">
            <summary>
            A JID was required, but not specified.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.JIDRequired.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.JIDRequired.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.MaxItemsExceeded">
            <summary>
            The maximum number of items was exceeded.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.MaxItemsExceeded.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.MaxItemsExceeded.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.MaxNodesExceeded">
            <summary>
            The maximum number of nodes was exceeded.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.MaxNodesExceeded.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.MaxNodesExceeded.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.NodeIDRequired">
            <summary>
            The node was required, but not specified.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.NodeIDRequired.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.NodeIDRequired.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.NotInRosterGroup">
            <summary>
            Not allowed to subscribe, because you aren't in one of the correct roster
            groups of the publisher.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.NotInRosterGroup.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.NotInRosterGroup.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.NotSubscribed">
            <summary>
            You must be subscribed to perform this function.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.NotSubscribed.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.NotSubscribed.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.PayloadTooBig">
            <summary>
            The item is too large.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.PayloadTooBig.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.PayloadTooBig.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.PayloadRequired">
            <summary>
            An item is required, but was not specified.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.PayloadRequired.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.PayloadRequired.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.PendingSubscription">
            <summary>
            The subscription is pending.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.PendingSubscription.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.PendingSubscription.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.PresenceSubscriptionRequired">
            <summary>
            You must be subscribed first.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.PresenceSubscriptionRequired.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.PresenceSubscriptionRequired.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.SubidRequired">
            <summary>
            An subscription ID is required, but was not specified.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.SubidRequired.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.SubidRequired.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.PubSubFeature">
            <summary>
            Supported features
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.UNSPECIFIED">
            <summary>
            None specified
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.access_authorize">
            <summary>
            Access authorizations
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.access_open">
            <summary>
            Open Access
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.access_presence">
            <summary>
            Presence-based access control
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.access_roster">
            <summary>
            Roster-based access control
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.access_whitelist">
            <summary>
            Whitelist-based access control
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.auto_create">
            <summary>
            Auto-creation of nodes
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.auto_subscribe">
            <summary>
            Auto-subscription to nodes
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.collections">
            <summary>
            Collection support
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.config_node">
            <summary>
            Configuration
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.create_and_configure">
            <summary>
            Create and configure atomically
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.create_nodes">
            <summary>
            Node creation
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.delete_any">
            <summary>
            Delete items
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.delete_nodes">
            <summary>
            Delete nodes
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.filtered_notifications">
            <summary>
            Notify on some criteria, only
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.get_pending">
            <summary>
            Process pending subscription requests
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.instant_nodes">
            <summary>
            The server can create unused node names
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.item_ids">
            <summary>
            Items have IDs
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.last_published">
            <summary>
            Geting the last published item
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.leased_subscription">
            <summary>
            Time-based subscriptions are supported.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.manage_subscriptions">
            <summary>
            Node owners may manage subscriptions
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.member_affiliation">
            <summary>
            The member affiliation is supported
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.meta_data">
            <summary>
            Node meta-data is supported.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.modify_affiliations">
            <summary>
            Node owners may modify affiliations.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.multi_collection">
            <summary>
            A single leaf node may be associated with multiple collections
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.multi_subscribe">
            <summary>
            A single entity may subscribe to a node multiple times.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.outcast_affiliation">
            <summary>
            The outcast affiliation is supported
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.persistent_items">
            <summary>
            Persistent items are supported.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.presence_notifications">
            <summary>
            Presence-based delivery of event notifications is supported
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.presence_subscribe">
            <summary>
            Authorized contacts are automatically subscribed to a user's virtual pubsub service.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.publish">
            <summary>
            Publishing items is supported (note: not valid for collection nodes).
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.publish_options">
            <summary>
            Publishing an item with options is supported.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.publisher_affiliation">
            <summary>
            The publisher affiliation is supported.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.purge_nodes">
            <summary>
            Purging of nodes is supported.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.retract_items">
            <summary>
            Item retraction is supported.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.retrieve_affiliations">
            <summary>
            Retrieval of current affiliations is supported.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.retrieve_default">
            <summary>
            Retrieval of default node configuration is supported.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.retrieve_items">
            <summary>
            Item retrieval is supported.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.retrieve_subscriptions">
            <summary>
            Retrieval of current subscriptions is supported.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.subscribe">
            <summary>
            Subscribing and unsubscribing are supported.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.subscription_options">
            <summary>
            Configuration of subscription options is supported.
            </summary>
        </member>
        <member name="F:jabber.protocol.iq.PubSubFeature.subscription_notifications">
            <summary>
            Notification of subscription state changes is supported.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.Unsupported">
            <summary>
            An unsupported protocol was used.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.Unsupported.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Unsupported.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.Unsupported.Feature">
            <summary>
            Which feature was unsupported?
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.UnsupportedAccessModel">
            <summary>
            An invalid access model was specified.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.UnsupportedAccessModel.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.UnsupportedAccessModel.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.connection.PollingStanzaStream">
            <summary>
            Manages the HTTP Polling XMPP stream.
            </summary>
        </member>
        <member name="M:jabber.connection.PollingStanzaStream.#ctor(jabber.connection.IStanzaEventListener)">
            <summary>
             Creates a PollingStanzaStream
            </summary>
            <param name="listener">Listener associated with PollingStanzaStream.</param>
        </member>
        <member name="M:jabber.connection.PollingStanzaStream.CreateSocket">
            <summary>
            Create a XEP25Socket.
            </summary>
            <returns></returns>
        </member>
        <member name="T:bedrock.collections.ByteStack">
            <summary>
            A type-safe stack for bytes, implemented as a growable
            buffer.
            </summary>
        </member>
        <member name="M:bedrock.collections.ByteStack.#ctor">
            <summary>
            Creates an instance with the default initial capacity.
            </summary>
        </member>
        <member name="M:bedrock.collections.ByteStack.#ctor(System.Int32)">
            <summary>
            Create an instance with the given initial capacity.
            </summary>
            <param name="initialSize">The initial capacity</param>
        </member>
        <member name="M:bedrock.collections.ByteStack.#ctor(System.Byte[])">
            <summary>
            Create an instance with the given initial value.  The initial size
            will be grown from the size of the given bytes.  A copy is made of
            the given bytes.
            </summary>
            <param name="start">byte array copied into this ByteStack</param>
        </member>
        <member name="M:bedrock.collections.ByteStack.IncreaseSize">
            <summary>
            Increase the size of the stack by GROWTH_FACTOR times.
            </summary>
        </member>
        <member name="M:bedrock.collections.ByteStack.Push(System.Byte)">
            <summary>
            Push a byte onto the stack.
            </summary>
            <param name="b"> </param>
        </member>
        <member name="M:bedrock.collections.ByteStack.Pop">
            <summary>
            Pop a byte off of the stack.
            </summary>
        </member>
        <member name="M:bedrock.collections.ByteStack.Peek">
            <summary>
            Non-destructively read the byte on the top of the stack.
            </summary>
        </member>
        <member name="M:bedrock.collections.ByteStack.op_Implicit(bedrock.collections.ByteStack)~System.Byte[]">
            <summary>
            Converts to byte[] by making a trimmed copy.
            </summary>
            <param name="bs">The ByteStack to convert to a byte array.</param>
            <returns>The byte array containing a copy of the passed in ByteStack.</returns>
        </member>
        <member name="M:bedrock.collections.ByteStack.ToString">
            <summary>
            Convert to a string, using the default encoding.  This is probably not
            right, but it's really nice for debugging and testing.
            </summary>
        </member>
        <member name="P:bedrock.collections.ByteStack.Count">
            <summary>
            Gets the number of bytes that are currently in the stack.
            </summary>
        </member>
        <member name="P:bedrock.collections.ByteStack.Capacity">
            <summary>
            Gets the number of bytes that the stack can hold.
            </summary>
        </member>
        <member name="T:xpnet.UTF8Encoding">
            <summary>
            UTF-8 specific tokenizer.
            </summary>
        </member>
        <member name="M:xpnet.UTF8Encoding.#ctor">
            <summary>
            New tokenizer
            </summary>
        </member>
        <member name="M:xpnet.UTF8Encoding.byteType(System.Byte[],System.Int32)">
            <summary>
            What is the type of the current byte?
            </summary>
            <param name="buf"></param>
            <param name="off"></param>
            <returns></returns>
        </member>
        <member name="M:xpnet.UTF8Encoding.byteToAscii(System.Byte[],System.Int32)">
            <summary>
            Current byte to ASCII char
            </summary>
            <param name="buf"></param>
            <param name="off"></param>
            <returns></returns>
        </member>
        <member name="M:xpnet.UTF8Encoding.charMatches(System.Byte[],System.Int32,System.Char)">
            <summary>
            c is a significant ASCII character
            </summary>
            <param name="buf"></param>
            <param name="off"></param>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:xpnet.UTF8Encoding.byteType2(System.Byte[],System.Int32)">
            <summary>
            A 2 byte UTF-8 representation splits the characters 11 bits
            between the bottom 5 and 6 bits of the bytes.
            </summary>
            <param name="buf"></param>
            <param name="off"></param>
            <returns></returns>
        </member>
        <member name="M:xpnet.UTF8Encoding.convert(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
             <summary>
            
             </summary>
             <param name="sourceBuf"></param>
             <param name="sourceStart"></param>
             <param name="sourceEnd"></param>
             <param name="targetBuf"></param>
             <param name="targetStart"></param>
             <returns></returns>
        </member>
        <member name="M:xpnet.UTF8Encoding.movePosition(System.Byte[],System.Int32,System.Int32,xpnet.Position)">
             <summary>
            
             </summary>
             <param name="buf"></param>
             <param name="off"></param>
             <param name="end"></param>
             <param name="pos"></param>
        </member>
        <member name="T:stringprep.unicode.ComposeData">
            <summary>
            Data for composition of characters.  The algorithms here are still black box to me.
            </summary>
        </member>
        <member name="F:stringprep.unicode.ComposeData.FIRST_START">
            <summary>
            Where the first range of offsets from Data starts.
            These are used for checking the first character
            in a pair with a second character in Array.
            </summary>
        </member>
        <member name="F:stringprep.unicode.ComposeData.FIRST_SINGLE_START">
            <summary>
            Where the offsets of the range of characters where there is
            only one match for the second character, with a given first character.
            </summary>
        </member>
        <member name="F:stringprep.unicode.ComposeData.SECOND_START">
            <summary>
            Where the offsets of the range of second characters that match a given first
            character starts.
            </summary>
        </member>
        <member name="F:stringprep.unicode.ComposeData.SECOND_SINGLE_START">
            <summary>
            When there is only a single match to the left for these characters on the
            right, the offsets for that chunk of characters starts here.
            </summary>
        </member>
        <member name="F:stringprep.unicode.ComposeData.Data">
            <summary>
            The offset into Array for each character.  This array is compressed using
            the Table table, which provides page offsets for the pages that are non-zero.
            </summary>
        </member>
        <member name="F:stringprep.unicode.ComposeData.Table">
            <summary>
            Page offsets into Data for each page of characters.
            </summary>
        </member>
        <member name="F:stringprep.unicode.ComposeData.FirstSingle">
            <summary>
            When the offset for the  first character is in the range
            [FIRST_SINGLE_START, SECOND_START), look up the corresponding
            character here with the offset from Data to see if it is
            the second character.  If not, there is no combination.
            </summary>
        </member>
        <member name="F:stringprep.unicode.ComposeData.SecondSingle">
            <summary>
            When the offset for the second character is in the range
            [SECOND_SINGLE_START...), look up the corresponding
            character here with the offset from Data to see if it is
            the first character.  If not, there is no combination.
            </summary>
        </member>
        <member name="F:stringprep.unicode.ComposeData.Array">
            <summary>
            Array of composition pairs, indexed by offset (from Data) of first
            character, and offset of second character.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.OwnerPubSubCommandIQ`1">
            <summary>
            A type-safe PubSub IQ for owner actions.
            </summary>
            <typeparam name="T">The type of command to create</typeparam>
        </member>
        <member name="M:jabber.protocol.iq.OwnerPubSubCommandIQ`1.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.OwnerPubSubCommandIQ`1.#ctor(System.Xml.XmlDocument,System.String)">
            <summary>
            Create, with node
            </summary>
            <param name="doc"></param>
            <param name="node"></param>
        </member>
        <member name="P:jabber.protocol.iq.OwnerPubSubCommandIQ`1.Command">
            <summary>
            The command inside the pubsub element.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.OwnerPubSub`1">
            <summary>
            A type-safe pubsub element.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:jabber.protocol.iq.OwnerPubSub`1.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create
            </summary>
            <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.OwnerPubSub`1.Command">
            <summary>
            The pubsub command
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.OwnerPubSub`1.CommandType">
            <summary>
            The type of pubsub command
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.PubSubOwner">
            <summary>
            The pubsub container for owner operations.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.PubSubOwner.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.PubSubOwner.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.PubSubOwner.Command">
            <summary>
            The command inside.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.PubSubOwner.CommandType">
            <summary>
            The type of the included command
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.OwnerAffliliations">
            <summary>
            Affiliations of all folks associated with a node
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.OwnerAffliliations.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.OwnerAffliliations.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.OwnerAffliliations.GetAffiliations">
            <summary>
            Retrieve all of the affiliations
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.OwnerAffliliations.AddAffiliation(jabber.protocol.iq.AffiliationType,System.String)">
            <summary>
            Add a new affiliation to the list.
            </summary>
            <param name="type"></param>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="P:jabber.protocol.iq.OwnerAffliliations.CommandType">
            <summary>
            Affiliations command
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.OwnerAffiliation">
            <summary>
            An affiliation for another user, retrieved by the owner.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.OwnerAffiliation.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.OwnerAffiliation.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.OwnerAffiliation.JID">
            <summary>
            The JID of the affiliate.
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.OwnerConfigure">
            <summary>
            Owner-level configuration
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.OwnerConfigure.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.OwnerConfigure.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.OwnerConfigure.CommandType">
            <summary>
            Configure
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.OwnerConfigure.MetaData">
            <summary>
            An x:data form that describes the node
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.OwnerDefault">
            <summary>
            The default configuration parameters
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.OwnerDefault.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.OwnerDefault.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.OwnerDefault.CommandType">
            <summary>
            Configure
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.OwnerDefault.MetaData">
            <summary>
            An x:data form that describes the node
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.OwnerDelete">
            <summary>
            Delete a node
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.OwnerDelete.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.OwnerDelete.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.OwnerDelete.CommandType">
            <summary>
            Delete
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.OwnerPurge">
            <summary>
            Purge all items from a node
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.OwnerPurge.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.OwnerPurge.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.OwnerPurge.CommandType">
            <summary>
            Purge
            </summary>
        </member>
        <member name="T:jabber.protocol.iq.OwnerSubscriptions">
            <summary>
            The subscription list
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.OwnerSubscriptions.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create for outbound.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.OwnerSubscriptions.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
            <summary>
            Create for inbound
            </summary>
            <param name="prefix"></param>
            <param name="qname"></param>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.AgentsIQ">
            <summary>
            IQ packet with an agents query element inside.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.AgentsIQ.#ctor(System.Xml.XmlDocument)">
            <summary>
            Create an agents IQ packet.
            </summary>
            <param name="doc"></param>
        </member>
        <member name="T:jabber.protocol.iq.AgentsQuery">
            <summary>
            An agents query element.
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.AgentsQuery.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.AgentsQuery.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.AgentsQuery.AddAgent">
            <summary>
            Add an agent to the list
            </summary>
            <returns></returns>
        </member>
        <member name="M:jabber.protocol.iq.AgentsQuery.GetAgents">
            <summary>
            Get the list of agents
            </summary>
            <returns></returns>
        </member>
        <member name="T:jabber.protocol.iq.Agent">
            <summary>
            Agent items
            </summary>
        </member>
        <member name="M:jabber.protocol.iq.Agent.#ctor(System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="doc"></param>
        </member>
        <member name="M:jabber.protocol.iq.Agent.#ctor(System.String,System.Xml.XmlQualifiedName,System.Xml.XmlDocument)">
             <summary>
            
             </summary>
             <param name="prefix"></param>
             <param name="qname"></param>
             <param name="doc"></param>
        </member>
        <member name="P:jabber.protocol.iq.Agent.JID">
            <summary>
            The agent's JID
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Agent.AgentName">
            <summary>
            The agent's name
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Agent.Description">
            <summary>
            The agent's description
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Agent.Transport">
            <summary>
            Is the agent a transport?
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Agent.Groupchat">
            <summary>
            Is the agent for groupchat?
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Agent.Service">
            <summary>
            The agent service name.
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Agent.Register">
            <summary>
            Is the agent a registrar?
            </summary>
        </member>
        <member name="P:jabber.protocol.iq.Agent.Search">
            <summary>
            Is the agent for JUD?
            </summary>
        </member>
        <member name="T:jabber.connection.sasl.PlainProcessor">
            <summary>
            SASL Mechanism PLAIN as specified in RFC 2595.
            </summary>
        </member>
        <member name="M:jabber.connection.sasl.PlainProcessor.step(jabber.protocol.stream.Step,System.Xml.XmlDocument)">
            <summary>
            Perform the next step
            </summary>
            <param name="s">Null if it's the initial response</param>
            <param name="doc">Document to create Steps in</param>
            <returns></returns>
        </member>
        <member name="T:jabber.connection.RoomPresenceHandler">
            <summary>
            An error occurred with a presence sent to a room.
            </summary>
            <param name="room"></param>
            <param name="pres"></param>
        </member>
        <member name="T:jabber.connection.ConfigureRoom">
            <summary>
            Notifies the client that a room configuration form has been received.
            </summary>
            <param name="room">Room associated with the configuration.</param>
            <param name="parent">Contains an x:data child with the form.</param>
            <returns>null to take the defaults, otherwise the IQ response</returns>
        </member>
        <member name="T:jabber.connection.RoomEvent">
            <summary>
            An event, like join or leave, has happened to a room.
            </summary>
            <param name="room">The room the event is for</param>
        </member>
        <member name="T:jabber.connection.RoomStateEvent">
            <summary>
            An event, like join or leave, has happened to a room.
            </summary>
            <param name="room">The room the event is for</param>
            <param name="state">State passed in by the caller, or null if none.</param>
        </member>
        <member name="T:jabber.connection.RoomParticipantEvent">
            <summary>
            A participant-related callback.
            </summary>
            <param name="room">The room the event is for</param>
            <param name="participant">The participant in the room</param>
        </member>
        <member name="T:jabber.connection.RoomParticipantsEvent">
            <summary>
            A participantCollection-related callback.
            </summary>
            <param name="room">The room the event is for</param>
            <param name="participants">The participants in the response</param>
            <param name="state">State passed in by the caller, or null if none.</param>
        </member>
        <member name="T:jabber.connection.ConferenceManager">
            <summary>
            Manages a set of conference rooms
            </summary>
        </member>
        <member name="F:jabber.connection.ConferenceManager.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:jabber.connection.ConferenceManager.#ctor">
            <summary>
            Creates a new conference manager.
            </summary>
        </member>
        <member name="M:jabber.connection.ConferenceManager.#ctor(System.ComponentModel.IContainer)">
            <summary>
            Creates a new conference manager in a container
            </summary>
            <param name="container">Parent container.</param>
        </member>
        <member name="M:jabber.connection.ConferenceManager.Dispose(System.Boolean)">
            <summary>
            Performs tasks associated with freeing, releasing, or resetting resources.
            </summary>
            <param name="disposing">True if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:jabber.connection.ConferenceManager.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="M:jabber.connection.ConferenceManager.GetRoom(jabber.JID)">
            <summary>
            Joins a conference room.
            </summary>
            <param name="roomAndNick">room@conference/nick, where "nick" is the desred nickname in the room.</param>
            <returns>
            If already joined, the existing room will be returned.
            If not, a Room object will be returned in the joining state.
            </returns>
        </member>
        <member name="M:jabber.connection.ConferenceManager.HasRoom(jabber.JID)">
            <summary>
            Determines whether or not the conference room is being managed
            by this ConferenceManager.
            </summary>
            <param name="roomAndNick">Room to look for.</param>
            <returns>True if the room is being managed.</returns>
        </member>
        <member name="M:jabber.connection.ConferenceManager.RemoveRoom(jabber.JID)">
            <summary>
            Removes the room from the list.
            Should most often be called by the Room.Leave() method.
            If the room does not exist, no exception is thrown.
            </summary>
            <param name="roomAndNick">Room to remove.</param>
        </member>
        <member name="M:jabber.connection.ConferenceManager.GetUniqueRoom(System.String,System.String,jabber.connection.RoomStateEvent,System.Object)">
             <summary>
             Get a unique room name from the given server, and create a Room
             object for that room with the given nick.  You'll be called back on
             "callback" when complete; the Room will be null if there was an error
             or timeout.
            
             Note: the server should implement the feature http://jabber.org/protocol/muc#unique,
             or this will return an error.  To work around, just create a room with a Guid for
             a name.
             </summary>
             <param name="server">The server to send the request to</param>
             <param name="nick">The nickname desired in the new room</param>
             <param name="callback">A callback to be called when the room is created</param>
             <param name="state">State object to be passed back when the callback fires</param>
        </member>
        <member name="E:jabber.connection.ConferenceManager.OnJoin">
            <summary>
            Finished joining the room, including all potential configuration.
            If set, will be added to each room created through the manager.
            </summary>
        </member>
        <member name="E:jabber.connection.ConferenceManager.OnLeave">
            <summary>
            Finished leaving the room, or was kicked/banned, or the room server went down cleanly.
            If set, will be added to each room created through the manager.
            </summary>
        </member>
        <member name="E:jabber.connection.ConferenceManager.OnPresenceError">
            <summary>
            Error in response to a room join, nick change, or presence update.
            If set, will be added to each room created through the manager.
            </summary>
        </member>
        <member name="E:jabber.connection.ConferenceManager.OnRoomConfig">
            <summary>
            Room configuration form received.  It is up to the listener call FinishConfig().
            The IQ in the callback is the parent of the x:data element.
            If set, will be added to each room created through the manager.
            </summary>
        </member>
        <member name="E:jabber.connection.ConferenceManager.OnRoomMessage">
            <summary>
            A message broadcast to all in the room
            If set, will be added to each room created through the manager.
            </summary>
        </member>
        <member name="E:jabber.connection.ConferenceManager.OnPrivateMessage">
            <summary>
            A side-chat message.
            If set, will be added to each room created through the manager.
            </summary>
        </member>
        <member name="E:jabber.connection.ConferenceManager.OnAdminMessage">
            <summary>
            An admin message from the room itself.  Typically status change sorts of things
            like kick/ban.
            If set, will be added to each room created through the manager.
            </summary>
        </member>
        <member name="E:jabber.connection.ConferenceManager.OnSelfMessage">
            <summary>
            A message that was sent by this user to the room, echo'd back.
            If set, will be added to each room created through the manager.
            </summary>
        </member>
        <member name="E:jabber.connection.ConferenceManager.OnSubjectChange">
            <summary>
            The subject of the room has been changed
            If set, will be added to each room created through the manager.
            </summary>
        </member>
        <member name="E:jabber.connection.ConferenceManager.OnParticipantJoin">
            <summary>
            A participant has joined the room.  This will not fire for yourself.
            If set, will be added to each room created through the manager.
            </summary>
        </member>
        <member name="E:jabber.connection.ConferenceManager.OnParticipantLeave">
            <summary>
            A participant has left the room.  This will not fire for yourself.
            If set, will be added to each room created through the manager.
            </summary>
        </member>
        <member name="E:jabber.connection.ConferenceManager.OnParticipantPresenceChange">
            <summary>
            A participant has changed presence, without joining or leaving the room.  This will not fire for yourself.
            If set, will be added to each room created through the manager.
            </summary>
        </member>
        <member name="E:jabber.connection.ConferenceManager.OnInvite">
            <summary>
            An invite was received.  A room object will be passed in as the sender.
            </summary>
        </member>
        <member name="P:jabber.connection.ConferenceManager.DefaultNick">
            <summary>
            The default room nickname, if one is not specified.  If none
            specified, the user name from the stream JID is used.
            </summary>
        </member>
        <member name="T:jabber.connection.Room">
            <summary>
            Manages a multi-user conference room.  See XEP-0045 (http://www.xmpp.org/extensions/xep-0045.html).
            </summary>
        </member>
        <member name="F:jabber.connection.Room.m_jid">
            <summary>
            Nick JID.  room@conference/nick.
            </summary>
        </member>
        <member name="F:jabber.connection.Room.m_room">
            <summary>
            Bare room JID.  room@conference
            </summary>
        </member>
        <member name="M:jabber.connection.Room.#ctor(jabber.connection.ConferenceManager,jabber.JID)">
            <summary>
            Create.
            </summary>
            <param name="manager">The manager for this room.</param>
            <param name="roomAndNick">room@conference/nick, where "nick" is the desred nickname in the room.</param>
        </member>
        <member name="M:jabber.connection.Room.m_stream_OnAfterPresenceOut(System.Object,jabber.protocol.client.Presence)">
            <summary>
            Whenver we change presence, send the new presence to the room, including
            caps etc.
            </summary>
            <param name="sender"></param>
            <param name="pres"></param>
        </member>
        <member name="M:jabber.connection.Room.Configure">
            <summary>
            Configures the room. OnRoomConfig MUST be set first.
            OnRoomConfig will be called back in the GUI thread if there is an
            InvokeControl on your XmppStream.  Make sure that OnRoomConfig does not
            return until it has the answer, typically by popping up a modal dialog
            with the x:data form.
            </summary>
        </member>
        <member name="M:jabber.connection.Room.FinishConfigDefault">
            <summary>
            Finish up configuration, taking the default room config.  Also known as
            an "Instant Room".  Suitable for use if the user cancels the configuration
            request, perhaps.
            </summary>
        </member>
        <member name="M:jabber.connection.Room.Join">
            <summary>
            Joins the room.  If the room is created, Configure() will
            be called automatically.
            </summary>
        </member>
        <member name="M:jabber.connection.Room.Join(System.String)">
            <summary>
            Join a room, using a password.
            </summary>
            <param name="password"></param>
        </member>
        <member name="M:jabber.connection.Room.Leave(System.String)">
            <summary>
            Exits the room.  This cleans up the entry in the ConferenceManager, as well.
            </summary>
            <param name="reason">Reason for leaving the room.  May be null for no reason.</param>
        </member>
        <member name="M:jabber.connection.Room.PublicMessage(System.String)">
            <summary>
            Sends a message to everyone currently in the room.
            </summary>
            <param name="body">The message text to send.</param>
        </member>
        <member name="M:jabber.connection.Room.PrivateMessage(System.String,System.String)">
            <summary>
            Sends a private message to a single user in the room.
            </summary>
            <param name="nick">The nickname of the user to send a private message to.</param>
            <param name="body">The message body to send.</param>
        </member>
        <member name="M:jabber.connection.Room.Invite(jabber.JID,System.String)">
            <summary>
            Invite a user to join the room.
            </summary>
            <param name="invitee">The JID of the person to invite</param>
            <param name="reason">The reason for the invite, or null for none.</param>
        </member>
        <member name="M:jabber.connection.Room.ChangeRole(System.String,jabber.protocol.iq.RoomRole,System.String)">
            <summary>
            Change the role of a user in the room, by nickname.  Must be a moderator.
            </summary>
            <param name="nick">The nickname of the user to modify.</param>
            <param name="role">The new role</param>
            <param name="reason">The reason for the change</param>
        </member>
        <member name="M:jabber.connection.Room.Kick(System.String,System.String)">
            <summary>
            Kick the given user from the room, based on their nickname.
            </summary>
            <param name="nick">The nickname of the person to kick</param>
            <param name="reason">The reason for kicking, or null for none.</param>
        </member>
        <member name="M:jabber.connection.Room.RevokeVoice(System.String,System.String)">
            <summary>
            Disallow a user from speaking; remove their "voice".
            </summary>
            <param name="nick">The nickname of the person to mute</param>
            <param name="reason">The reason for the muting</param>
        </member>
        <member name="M:jabber.connection.Room.GrantVoice(System.String,System.String)">
            <summary>
            Un-mute a muted user.  Give them "voice".
            </summary>
            <param name="nick">The nicname of the person to unmute</param>
            <param name="reason">The reason for the change</param>
        </member>
        <member name="M:jabber.connection.Room.RetrieveListByRole(jabber.protocol.iq.RoomRole,jabber.connection.RoomParticipantsEvent,System.Object)">
            <summary>
            Retrieve all of the parties with a given role.
            Modify the affiliations of persons in this list, then call ModifyRoles
            </summary>
            <param name="role">The role to search for</param>
            <param name="callback">A callback to receive the participant list</param>
            <param name="state">Caller state information</param>
        </member>
        <member name="M:jabber.connection.Room.ModifyRoles(jabber.connection.ParticipantCollection,System.String,jabber.connection.IqCB,System.Object)">
            <summary>
            Modify the roles of the parties in this list.
            To use, retrive a ParticipantCollection, change the roles
            of the parties in that collection, then pass that modified
            collection in here.
            </summary>
            <param name="parties">The modified participant collection</param>
            <param name="reason">The reason for the change</param>
            <param name="callback">A callback to call when complete.  Will have a null IQ if there were no changes to make.</param>
            <param name="state">Caller's state information</param>
        </member>
        <member name="M:jabber.connection.Room.ChangeAffiliation(jabber.JID,jabber.protocol.iq.RoomAffiliation,System.String)">
            <summary>
            Change the affiliation (long-term) with the room of a user, based on their real JID.
            </summary>
            <param name="jid">The bare JID of the user of which to change the affiliation</param>
            <param name="affiliation">The new affiliation</param>
            <param name="reason">The reason for the change</param>
        </member>
        <member name="M:jabber.connection.Room.Ban(jabber.JID,System.String)">
            <summary>
            Ban a user from re-joining the room.  Must be an admin.
            </summary>
            <param name="jid">The bare JID of the user to ban</param>
            <param name="reason">The reason for the shunning</param>
        </member>
        <member name="M:jabber.connection.Room.GrantMembership(jabber.JID,System.String)">
            <summary>
            Make this user a member of the room.
            </summary>
            <param name="jid">The bare jid of the user to grant membership to.</param>
            <param name="reason"></param>
        </member>
        <member name="M:jabber.connection.Room.RevokeMembership(jabber.JID,System.String)">
            <summary>
            Remove the membership privileges of the given user
            </summary>
            <param name="jid">The bare jid of the user to revoke the membership of.</param>
            <param name="reason"></param>
        </member>
        <member name="M:jabber.connection.Room.MakeModerator(System.String)">
            <summary>
            Make this user a moderator of the room.
            </summary>
            <param name="nick">The nickname of the user to change</param>
        </member>
        <member name="M:jabber.connection.Room.RetrieveListByAffiliation(jabber.protocol.iq.RoomAffiliation,jabber.connection.RoomParticipantsEvent,System.Object)">
            <summary>
            Retrieve all of the parties with a given affiliiation.
            Modify the affiliations of persons in this list, then call ModifyAffiliations
            </summary>
            <param name="affiliation">The affiliation to search for</param>
            <param name="callback">A callback to receive the participant list</param>
            <param name="state">Caller state information</param>
        </member>
        <member name="M:jabber.connection.Room.ModifyAffiliations(jabber.connection.ParticipantCollection,System.String,jabber.connection.IqCB,System.Object)">
            <summary>
            Modify the roles of the parties in this list.
            To use, retrive a ParticipantCollection, change the roles
            of the parties in that collection, then pass that modified
            collection in here.
            </summary>
            <param name="parties">The modified participant collection</param>
            <param name="reason">The reason for the change</param>
            <param name="callback">A callback to call when complete.  Will have a null IQ if there were no changes to make.</param>
            <param name="state">Caller's state information</param>
        </member>
        <member name="E:jabber.connection.Room.OnJoin">
            <summary>
            Finished joining the room, including all potential configuration.
            </summary>
        </member>
        <member name="E:jabber.connection.Room.OnLeave">
            <summary>
            Finished leaving the room, or was kicked/banned, or the room server went down cleanly.
            </summary>
        </member>
        <member name="E:jabber.connection.Room.OnPresenceError">
            <summary>
            Informs the client that an error in response to a room join,
            nick change, or presence update has occurred.
            </summary>
        </member>
        <member name="E:jabber.connection.Room.OnRoomConfig">
            <summary>
            Informs the client that the room configuration form was received.
            It is up to the listener to call the FinishConfig() method.
            The IQ in the callback is the parent of the x:data element.
            </summary>
        </member>
        <member name="E:jabber.connection.Room.OnRoomMessage">
            <summary>
            A message broadcast to all in the room
            </summary>
        </member>
        <member name="E:jabber.connection.Room.OnSelfMessage">
            <summary>
            A message that was sent by this user to the room, echo'd back.
            </summary>
        </member>
        <member name="E:jabber.connection.Room.OnPrivateMessage">
            <summary>
            A side-chat message.
            </summary>
        </member>
        <member name="E:jabber.connection.Room.OnAdminMessage">
            <summary>
            An admin message from the room itself.  Typically status change sorts of things
            like kick/ban.
            </summary>
        </member>
        <member name="E:jabber.connection.Room.OnSubjectChange">
            <summary>
            The subject of the room has been changed
            </summary>
        </member>
        <member name="E:jabber.connection.Room.OnParticipantJoin">
            <summary>
            A participant has joined the room.  This will not fire for yourself.
            </summary>
        </member>
        <member name="E:jabber.connection.Room.OnParticipantLeave">
            <summary>
            A participant has left the room.  This will not fire for yourself.
            </summary>
        </member>
        <member name="E:jabber.connection.Room.OnParticipantPresenceChange">
            <summary>
            A participant has changed presence, without joining or leaving the room.  This will not fire for yourself.
            </summary>
        </member>
        <member name="P:jabber.connection.Room.DefaultConfig">
            <summary>
            Determines whether to use the default conference room configuration
            or to retrieve the configuration form from the XMPP server.
            </summary>
        </member>
        <member name="P:jabber.connection.Room.Subject">
            <summary>
            The subject of the room.  Set has the side-effect of sending to the server.
            </summary>
        </member>
        <member name="P:jabber.connection.Room.RoomAndNick">
            <summary>
            The full JID of the user in the room.  room@service/nick
            </summary>
        </member>
        <member name="P:jabber.connection.Room.JID">
            <summary>
            The bare JID of the room.  room@service
            </summary>
        </member>
        <member name="P:jabber.connection.Room.IsParticipating">
            <summary>
            Have we joined the room successfully?
            </summary>
        </member>
        <member name="P:jabber.connection.Room.Nickname">
            <summary>
            The nickname that others in the room will see for you.
            Set has the side-effect of changing the nickname on the server.
            </summary>
        </member>
        <member name="P:jabber.connection.Room.Participants">
            <summary>
            Current room participants.
            </summary>
            <returns></returns>
        </member>
        <member name="P:jabber.connection.Room.Tag">
            <summary>
            Extra data associated with the room.
            </summary>
        </member>
        <member name="T:jabber.connection.ParticipantCollection">
            <summary>
            A list of all of the current participants.
            </summary>
        </member>
        <member name="M:jabber.connection.ParticipantCollection.Modify(jabber.protocol.client.Presence,jabber.connection.ParticipantCollection.Modification@)">
            <summary>
            Add a participant to the list, indexed by full nick JID.
            </summary>
            <param name="pres">The latest presence</param>
            <param name="mod">Was this a JOIN, a LEAVE, or no change?</param>
            <returns>The associated participant.</returns>
        </member>
        <member name="M:jabber.connection.ParticipantCollection.GetParticipantsByRole(jabber.protocol.iq.RoomRole)">
            <summary>
            Get all of the participants that are in a given room role.
            </summary>
            <param name="role">The role to search for</param>
            <returns></returns>
        </member>
        <member name="M:jabber.connection.ParticipantCollection.GetParticipantsByAffiliation(jabber.protocol.iq.RoomAffiliation)">
            <summary>
            Get all of the participants that are in a given room affiliation.
            </summary>
            <param name="affiliation">The role to search for</param>
            <returns></returns>
        </member>
        <member name="M:jabber.connection.ParticipantCollection.GetEnumerator">
            <summary>
            Enumerate over all of the participants
            </summary>
            <returns></returns>
        </member>
        <member name="P:jabber.connection.ParticipantCollection.Item(jabber.JID)">
            <summary>
            Get a participant by their room@service/nick JID.
            </summary>
            <param name="nickJid">room@service/nick</param>
            <returns>Participant object</returns>
        </member>
        <member name="T:jabber.connection.RoomParticipant">
            <summary>
            Someone who is currently in or associated with a room.
            </summary>
        </member>
        <member name="M:jabber.connection.RoomParticipant.#ctor(jabber.protocol.client.Presence)">
            <summary>
            Create a participant from the last presence received for that user.
            </summary>
            <param name="pres"></param>
        </member>
        <member name="M:jabber.connection.RoomParticipant.ToString">
            <summary>
            The nick JID or nick (real).
            </summary>
            <returns></returns>
        </member>
        <member name="P:jabber.connection.RoomParticipant.Presence">
            <summary>
            Last presence received for this user.
            </summary>
        </member>
        <member name="P:jabber.connection.RoomParticipant.Changed">
            <summary>
            Has this participant's role or affiliation been changed?
            </summary>
        </member>
        <member name="P:jabber.connection.RoomParticipant.Item">
            <summary>
            The muc#user item in the presence.
            </summary>
        </member>
        <member name="P:jabber.connection.RoomParticipant.Nick">
            <summary>
            Nickname of the user
            </summary>
        </member>
        <member name="P:jabber.connection.RoomParticipant.Affiliation">
            <summary>
            Affiliation of the user.
            </summary>
        </member>
        <member name="P:jabber.connection.RoomParticipant.Role">
            <summary>
            Role of the user.
            </summary>
        </member>
        <member name="P:jabber.connection.RoomParticipant.NickJID">
            <summary>
            room@server/nick of the user.
            </summary>
        </member>
        <member name="P:jabber.connection.RoomParticipant.RealJID">
            <summary>
            The real JID of the user, if this is a non-anonymous room.
            </summary>
        </member>
        <member name="T:bedrock.util.SpanEventHandler">
            <summary>
            TimeSpan event.
            </summary>
            <param name="sender"></param>
            <param name="span"></param>
        </member>
        <member name="T:bedrock.util.IdleTime">
            <summary>
            Idle time calculations and notifications.
            </summary>
        </member>
        <member name="M:bedrock.util.IdleTime.GetIdleTime">
            <summary>
            Get the lapse time between user input (mouse or keyboard) system-wide.
            </summary>
            <returns>Lapse time in seconds.</returns>
        </member>
        <member name="M:bedrock.util.IdleTime.#ctor">
            <summary>
            Create an idle timer with the default timouts.
            </summary>
        </member>
        <member name="M:bedrock.util.IdleTime.#ctor(System.Int32,System.Int32)">
            <summary>
            Create an idle timer.  Make sure to set Enabled = true to start.
            </summary>
            <param name="pollSecs">Every pollSecs seconds, poll to see how long we've been away.</param>
            <param name="notifySecs">If we've been away notifySecs seconds, fire notification.</param>
        </member>
        <member name="E:bedrock.util.IdleTime.OnIdle">
            <summary>
            Fired when user has been idle (mouse, keyboard) for the configured number of seconds.
            </summary>
        </member>
        <member name="E:bedrock.util.IdleTime.OnUnIdle">
            <summary>
            Fired when the user comes back.
            </summary>
        </member>
        <member name="P:bedrock.util.IdleTime.Enabled">
            <summary>
            Is the timer running?
            </summary>
        </member>
        <member name="P:bedrock.util.IdleTime.PollInterval">
            <summary>
            Time, in seconds, between checking for
            </summary>
        </member>
        <member name="P:bedrock.util.IdleTime.IdleLength">
            <summary>
            The amount of time (in seconds) the computer can be idle before OnIdle is fired.
            </summary>
        </member>
        <member name="P:bedrock.util.IdleTime.IsIdle">
            <summary>
            Are we currently idle?
            </summary>
        </member>
        <member name="P:bedrock.util.IdleTime.InvokeControl">
            <summary>
            Invoke() all callbacks on this control.
            </summary>
        </member>
        <member name="T:bedrock.util.GetOpt">
            <summary>
            GetOpt should be subclassed to create a class that handles
            command-line parameters.  The subclass should use fields or properties
            that have the CommandLine attribute set on them.  Fields and properties
            of type bool will be toggle flags, other types will take a value as
            either the next command-line parameter or following a colon.
            Also, now, you can create an instance of GetOpt, and pass in
            TODO: Give examples of sublcass and calling example.
            </summary>
        </member>
        <member name="M:bedrock.util.GetOpt.#ctor">
            <summary>
            Really only useful for subclasses, I think.
            </summary>
        </member>
        <member name="M:bedrock.util.GetOpt.#ctor(System.Object)">
            <summary>
            Get ready to process command line parameters for the given target object.
            </summary>
            <param name="target">Object to set parameters on</param>
        </member>
        <member name="M:bedrock.util.GetOpt.#ctor(System.Object,System.String[])">
            <summary>
            Process command line parameters for the given target object, with the
            given arguments.
            </summary>
            <param name="target">Object to set parameters on</param>
            <param name="args">An array of arguments.  If null, use the environment's command line.</param>
        </member>
        <member name="M:bedrock.util.GetOpt.#ctor(System.String[])">
            <summary>
            Subclass interface, processing immediately.
            </summary>
            <param name="args">An array of arguments.  If null, use the environment's command line.</param>
        </member>
        <member name="M:bedrock.util.GetOpt.Process(System.String[])">
            <summary>
            Process the given command line parameters.
            </summary>
            <param name="args">An array of arguments.  If null, use the environment's command line.</param>
        </member>
        <member name="M:bedrock.util.GetOpt.SetFlags">
            <summary>
            Look at myself, to see if there are any command line
            parameter fields or properties.
            </summary>
        </member>
        <member name="M:bedrock.util.GetOpt.CheckRequired">
            <summary>
            Make sure all required fields got hit.
            </summary>
        </member>
        <member name="M:bedrock.util.GetOpt.SetValue(System.Reflection.MemberInfo,System.Object)">
            <summary>
            Set the value of a field or property, depending on the kind of member.
            Coerce the type of the value passed in, as possible
            </summary>
            <param name="mi">The member to set</param>
            <param name="val">The value to set</param>
        </member>
        <member name="M:bedrock.util.GetOpt.ConvertValue(System.Object,System.Type)">
            <summary>
            Convert a field value representation to a value of the correct type.
            Enums need special handling, at least for now.
            </summary>
            <param name="val">The value to convert</param>
            <param name="TargetType">The type to convert it to</param>
        </member>
        <member name="M:bedrock.util.GetOpt.GetValue(System.Reflection.MemberInfo)">
            <summary>
            Get the value from a field or property, depending on the type of member.
            </summary>
            <param name="mi"> </param>
        </member>
        <member name="M:bedrock.util.GetOpt.GetMemberType(System.Reflection.MemberInfo)">
            <summary>
            Get the type contained in the given member.
            </summary>
            <param name="mi">The member to check</param>
        </member>
        <member name="M:bedrock.util.GetOpt.GetCommandLineMembers">
            <summary>
            Get all of the members that are tagged with the CommandLineAttribute.
            NOTE: this currently returns private members as well, but setting the
            BindingFlags to public doesn't return anything.  Could be a bug in the BCL?
            </summary>
        </member>
        <member name="M:bedrock.util.GetOpt.AttrMemberFilter(System.Reflection.MemberInfo,System.Object)">
            <summary>
            Filter proc for GetCommandLineMembers.  Returns true if the member
            implements a given attribute.
            </summary>
            <param name="m">The member to evaluate</param>
            <param name="filterCriteria">The attribute type to check for</param>
        </member>
        <member name="M:bedrock.util.GetOpt.GetOption(System.Reflection.MemberInfo)">
             <summary>
             Get the CommandLineAttribute off of a member.  Assumes that the member implements
            <i>exactly</i> one instance of the attribute.
             </summary>
             <param name="mi">The member to retrieve from</param>
        </member>
        <member name="M:bedrock.util.GetOpt.UsageExit">
            <summary>
            Print out the usage information on StdErr, and exit with code 64.
            </summary>
        </member>
        <member name="M:bedrock.util.GetOpt.UsageGUIExit">
            <summary>
            Echo Command-Line requirements for a GUI app via a MessageBox
            (since we do not have user-visible stdout)
            </summary>
        </member>
        <member name="P:bedrock.util.GetOpt.Args">
            <summary>
            The list of command-line arguments that were not associated with flags.
            </summary>
        </member>
        <member name="P:bedrock.util.GetOpt.Item(System.String)">
            <summary>
            Get/Set a parameter on the managed object, using the flag.
            Warning: this will do an implicit conversion to the type of the
            field associated with the flag.
            If you're using this, you've probably got a design problem.
            </summary>
        </member>
        <member name="P:bedrock.util.GetOpt.Usage">
            <summary>
            Get a usage description string from the object.
            Use the CommandLineAttribute descriptions wherever possible.
            </summary>
        </member>
        <member name="T:bedrock.util.CommandLineAttribute">
            <summary>
            Attribute to annotate subclasses of GetOpt.  Any field or property
            that gets this attribute is a possible command-line argument for the
            program containing the GetOpt subclass.
            </summary>
        </member>
        <member name="M:bedrock.util.CommandLineAttribute.#ctor">
            <summary>
            Use the member name for the command-line parameter.
            </summary>
        </member>
        <member name="M:bedrock.util.CommandLineAttribute.#ctor(System.String)">
            <summary>
            Use the given string as the command-line parameter.
            </summary>
            <param name="commandFlag"> </param>
        </member>
        <member name="M:bedrock.util.CommandLineAttribute.#ctor(System.String,System.String)">
            <summary>
            Use the given string as the command-line parameter.
            </summary>
            <param name="commandFlag"> </param>
            <param name="description"> </param>
        </member>
        <member name="M:bedrock.util.CommandLineAttribute.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Use the given string as the command-line parameter.
            </summary>
            <param name="commandFlag"> </param>
            <param name="description"> </param>
            <param name="required"> </param>
        </member>
        <member name="P:bedrock.util.CommandLineAttribute.CommandFlag">
            <summary>
            Get the command-line flag.  If none was specified, returns null.
            </summary>
        </member>
        <member name="P:bedrock.util.CommandLineAttribute.Description">
            <summary>
            Get the command-line description.  If none was specified, returns null.
            </summary>
        </member>
        <member name="P:bedrock.util.CommandLineAttribute.Required">
            <summary>
            Is the option required?  Defaults to false.
            </summary>
        </member>
        <member name="T:bedrock.net.AsyncSocketHandler">
            <summary>
            Delegate for members that receive a socket.
            </summary>
        </member>
        <member name="T:bedrock.net.AsyncSocket">
            <summary>
            An asynchronous socket, which calls a listener class when
            interesting things happen.
            </summary>
        </member>
        <member name="F:bedrock.net.AsyncSocket.DefaultUntrustedPolicy">
            <summary> The set of allowable errors in SSL certificates
            if UntrustedRootOK is set to true.  </summary>
        </member>
        <member name="F:bedrock.net.AsyncSocket.AllowedSSLErrors">
            <summary> The allowable SSL certificate errors.  If you
            modify UntrustedRootOK to true, the side effect will be to
            set this to DefaultUntrustedPolicy.  False, the default,
            sets this to None.  </summary>
        </member>
        <member name="F:bedrock.net.AsyncSocket.SSLProtocols">
            <summary>
            The types of SSL to support.  SSL3 and TLS1 by default.
            That should be good enough for most apps, and was
            hard-coded to start with.  Note: when doing start-tls,
            this is overridden to just be TLS.
            </summary>
        </member>
        <member name="M:bedrock.net.AsyncSocket.#ctor(bedrock.net.SocketWatcher,bedrock.net.ISocketEventListener)">
            <summary>
            Called from SocketWatcher.
            </summary>
            <param name="w"></param>
            <param name="listener">The listener for this socket</param>
        </member>
        <member name="M:bedrock.net.AsyncSocket.#ctor(bedrock.net.SocketWatcher,bedrock.net.ISocketEventListener,System.Boolean,System.Boolean)">
            <summary>
            Called from SocketWatcher.
            </summary>
            <param name="w"></param>
            <param name="listener">The listener for this socket</param>
            <param name="SSL">Do SSL3 and TLS1 on startup (call
            StartTLS later if this is false, and TLS only is needed
            later)</param>
            <param name="synch">Synchronous operation</param>
        </member>
        <member name="M:bedrock.net.AsyncSocket.ChooseClientCertificate">
            <summary>
            Choose a certificate from the local store.  If there are
            none available, returns right away.
            If there is exactly one, uses it.
            Otherwise, prompts.
            </summary>
        </member>
        <member name="M:bedrock.net.AsyncSocket.ChooseClientCertificate(System.String[])">
            <summary>
            Choose a certificate from the local store.  If there are
            none available, returns right away.
            If there is exactly one, uses it.
            Otherwise, prompts.
            TODO: figure out something for server certs, too.
            </summary>
            <param name="acceptableIssuers">A list of DNs of CAs that are trusted by the other party</param>
        </member>
        <member name="M:bedrock.net.AsyncSocket.ChooseClientCertificate(System.Object,System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Cryptography.X509Certificates.X509Certificate,System.String[])">
            <summary>
            Callback to choose client cert.
            TODO: this should surface an event of some kind.
            </summary>
        </member>
        <member name="M:bedrock.net.AsyncSocket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
            <summary>
            Sets the specified option to the specified value.
            </summary>
            <param name="optionLevel"></param>
            <param name="optionName"></param>
            <param name="optionValue"></param>
        </member>
        <member name="M:bedrock.net.AsyncSocket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
            <summary>
            Sets the specified option to the specified value.
            </summary>
            <param name="optionLevel"></param>
            <param name="optionName"></param>
            <param name="optionValue"></param>
        </member>
        <member name="M:bedrock.net.AsyncSocket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
            <summary>
            Sets the specified option to the specified value.
            </summary>
            <param name="optionLevel"></param>
            <param name="optionName"></param>
            <param name="optionValue"></param>
        </member>
        <member name="M:bedrock.net.AsyncSocket.Accept(bedrock.net.Address,System.Int32)">
            <summary>
            Prepare to start accepting inbound requests.  Call
            RequestAccept() to start the async process.
            </summary>
            <param name="addr">Address to listen on</param>
            <param name="backlog">The Maximum length of the queue of
            pending connections</param>
        </member>
        <member name="M:bedrock.net.AsyncSocket.RequestAccept">
            <summary>
            Start the flow of async accepts.  Flow will continue while
            Listener.OnAccept() returns true.  Otherwise, call
            RequestAccept() again to continue.
            </summary>
        </member>
        <member name="M:bedrock.net.AsyncSocket.ExecuteAccept(System.IAsyncResult)">
            <summary>
            We got a connection from outside.  Add it to the SocketWatcher.
            </summary>
            <param name="ar"></param>
        </member>
        <member name="M:bedrock.net.AsyncSocket.Connect(bedrock.net.Address)">
            <summary>
            Outbound connection.  Eventually calls Listener.OnConnect() when
            the connection comes up.  Don't forget to call RequestRead() in
            OnConnect()!
            </summary>
            <param name="addr"></param>
        </member>
        <member name="M:bedrock.net.AsyncSocket.OnConnectResolved(bedrock.net.Address)">
            <summary>
            Address resolution finished.  Try connecting.
            </summary>
            <param name="addr"></param>
        </member>
        <member name="M:bedrock.net.AsyncSocket.ValidateServerCertificate(System.Object,System.Security.Cryptography.X509Certificates.X509Certificate,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors)">
             <summary>
             Validate the server cert.  SSLPolicyErrors will be
             pre-filled with the errors you got.
            
             If there is an error in the cert, OnIvalidCertificate will be called.
             </summary>
             <param name="sender"></param>
             <param name="certificate"></param>
             <param name="chain"></param>
             <param name="sslPolicyErrors"></param>
             <returns></returns>
        </member>
        <member name="M:bedrock.net.AsyncSocket.StartTLS">
            <summary>
            Start TLS processing on an open socket.
            </summary>
        </member>
        <member name="M:bedrock.net.AsyncSocket.StartCompression">
            <summary>
            Start XEP-138 compression on this socket.
            </summary>
        </member>
        <member name="M:bedrock.net.AsyncSocket.ExecuteConnect(System.IAsyncResult)">
            <summary>
            Connection complete.
            </summary>
            <remarks>This is called solely by an async socket thread</remarks>
            <param name="ar"></param>
        </member>
        <member name="M:bedrock.net.AsyncSocket.RequestRead">
            <summary>
            Start an async read from the socket.  Listener.OnRead() is
            eventually called when data arrives.
            </summary>
        </member>
        <member name="M:bedrock.net.AsyncSocket.GotData(System.IAsyncResult)">
            <summary>
            Some data arrived.
            </summary>
            <param name="ar"></param>
        </member>
        <member name="M:bedrock.net.AsyncSocket.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Async write to the socket.  Listener.OnWrite will be
            called eventually when the data has been written.  A
            trimmed copy is made of the data, internally.
            </summary>
            <param name="buf">Buffer to output</param>
            <param name="offset">Offset into buffer</param>
            <param name="len">Number of bytes to output</param>
        </member>
        <member name="M:bedrock.net.AsyncSocket.WroteData(System.IAsyncResult)">
            <summary>
            Data was written.
            </summary>
            <param name="ar"></param>
        </member>
        <member name="M:bedrock.net.AsyncSocket.Close">
            <summary>
            Close the socket.  This is NOT async.  .Net doesn't have
            async closes.  But, it can be *called* async, particularly
            from GotData.  Attempts to do a shutdown() first.
            </summary>
        </member>
        <member name="M:bedrock.net.AsyncSocket.AsyncClose">
            <summary>
            Close, called from async places, so that Errors get fired,
            appropriately.
            </summary>
        </member>
        <member name="M:bedrock.net.AsyncSocket.FireError(System.Exception)">
            <summary>
            Error occurred in the class.  Send to Listener.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:bedrock.net.AsyncSocket.ToString">
            <summary>
            Return a string representation of this socket
            </summary>
            <returns></returns>
        </member>
        <member name="M:bedrock.net.AsyncSocket.GetHashCode">
            <summary>
            In case SocketWatcher wants to use a HashTable.
            </summary>
            <returns></returns>
        </member>
        <member name="M:bedrock.net.AsyncSocket.Equals(System.Object)">
            <summary>
            IComparable's need to implement Equals().  This checks the
            guid's for each socket to see if they are the same.
            </summary>
            <param name="val">The AsyncSocket to check against.</param>
            <returns></returns>
        </member>
        <member name="M:bedrock.net.AsyncSocket.op_Equality(bedrock.net.AsyncSocket,bedrock.net.AsyncSocket)">
            <summary>
            IComparable's need to implement ==.  Checks for guid equality.
            </summary>
            <param name="one">First socket to compare</param>
            <param name="two">Second socket to compare</param>
            <returns></returns>
        </member>
        <member name="M:bedrock.net.AsyncSocket.op_Inequality(bedrock.net.AsyncSocket,bedrock.net.AsyncSocket)">
            <summary>
            IComparable's need to implement comparison operators.
            Checks compares guids.
            </summary>
            <param name="one">First socket to compare</param>
            <param name="two">Second socket to compare</param>
            <returns></returns>
        </member>
        <member name="M:bedrock.net.AsyncSocket.op_LessThan(bedrock.net.AsyncSocket,bedrock.net.AsyncSocket)">
            <summary>
            IComparable's need to implement comparison operators.  Checks compares guids.
            </summary>
            <param name="one">First socket to compare</param>
            <param name="two">Second socket to compare</param>
            <returns></returns>
        </member>
        <member name="M:bedrock.net.AsyncSocket.op_LessThanOrEqual(bedrock.net.AsyncSocket,bedrock.net.AsyncSocket)">
            <summary>
            IComparable's need to implement comparison operators.
            Checks compares guids.
            </summary>
            <param name="one">First socket to compare</param>
            <param name="two">Second socket to compare</param>
            <returns></returns>
        </member>
        <member name="M:bedrock.net.AsyncSocket.op_GreaterThan(bedrock.net.AsyncSocket,bedrock.net.AsyncSocket)">
            <summary>
            IComparable's need to implement comparison operators.
            Checks compares guids.
            </summary>
            <param name="one">First socket to compare</param>
            <param name="two">Second socket to compare</param>
            <returns></returns>
        </member>
        <member name="M:bedrock.net.AsyncSocket.op_GreaterThanOrEqual(bedrock.net.AsyncSocket,bedrock.net.AsyncSocket)">
            <summary>
            IComparable's need to implement comparison operators.  Checks compares guids.
            </summary>
            <param name="one">First socket to compare</param>
            <param name="two">Second socket to compare</param>
            <returns></returns>
        </member>
        <member name="P:bedrock.net.AsyncSocket.UntrustedRootOK">
             <summary>
             Are untrusted root certificates OK when connecting using
             SSL?  Setting this to true is insecure, but it's unlikely
             that you trust jabbber.org or jabber.com's relatively
             bogus certificate roots.
            
             Setting this modifies AllowedSSLErrors by side-effect.
             </summary>
        </member>
        <member name="P:bedrock.net.AsyncSocket.Address">
            <summary>
            For connect sockets, the remote address.  For Accept sockets, the local address.
            </summary>
        </member>
        <member name="P:bedrock.net.AsyncSocket.RemoteCertificate">
            <summary>
            Get the certificate of the remote endpoint of the socket.
            </summary>
        </member>
        <member name="P:bedrock.net.AsyncSocket.CertificateGui">
            <summary>
            If true the certificate selection dialog is called.
            </summary>
        </member>
        <member name="P:bedrock.net.AsyncSocket.LocalCertificate">
            <summary>
            The local certificate of the socket.
            </summary>
        </member>
        <member name="P:bedrock.net.AsyncSocket.SSL">
            <summary>
            Are we using SSL/TLS?
            </summary>
        </member>
        <member name="P:bedrock.net.AsyncSocket.Connected">
            <summary>
            Is the socket connected?
            </summary>
        </member>
        <member name="P:bedrock.net.AsyncSocket.IsMutuallyAuthenticated">
            <summary>
            Is the connection mutually authenticated?  (was there a good client cert, etc.)
            </summary>
        </member>
        <member name="P:bedrock.net.AsyncSocket.RequireClientCert">
            <summary>
            Does the server require a client cert?  If not, the client cert won't be sent.
            </summary>
        </member>
        <member name="P:bedrock.net.AsyncSocket.SocketWatcher">
            <summary>
            Retrieve the socketwatcher used by this instance of AsyncSocket
            </summary>
        </member>
        <member name="T:bedrock.net.AsyncSocket.SocketState">
            <summary>
            Socket states.
            </summary>
        </member>
        <member name="F:bedrock.net.AsyncSocket.SocketState.Created">
            <summary>
            Socket has been created.
            </summary>
        </member>
        <member name="F:bedrock.net.AsyncSocket.SocketState.Listening">
            <summary>
            Socket is listening for new connections
            </summary>
        </member>
        <member name="F:bedrock.net.AsyncSocket.SocketState.Resolving">
            <summary>
            Doing DNS lookup
            </summary>
        </member>
        <member name="F:bedrock.net.AsyncSocket.SocketState.Connecting">
            <summary>
            Attempting to connect
            </summary>
        </member>
        <member name="F:bedrock.net.AsyncSocket.SocketState.Connected">
            <summary>
            Connected to a peer.  The running state.
            </summary>
        </member>
        <member name="F:bedrock.net.AsyncSocket.SocketState.Closing">
            <summary>
            Shutting down the socket.
            </summary>
        </member>
        <member name="F:bedrock.net.AsyncSocket.SocketState.Closed">
            <summary>
            Closed down.
            </summary>
        </member>
        <member name="F:bedrock.net.AsyncSocket.SocketState.Error">
            <summary>
            An error ocurred.
            </summary>
        </member>
        <member name="T:bedrock.collections.Tree">
            <summary>
            A basic balanced tree implementation.
            </summary>
        </member>
        <member name="M:bedrock.collections.Tree.#ctor">
            <summary>
            Construct an empty tree
            </summary>
        </member>
        <member name="M:bedrock.collections.Tree.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Iterate over the tree
            </summary>
            <returns></returns>
        </member>
        <member name="M:bedrock.collections.Tree.CopyTo(System.Array,System.Int32)">
            <summary>
             Copies the values from the tree to the specified array in the order of the keys.
            </summary>
            <param name="array">The array to copy into</param>
            <param name="index">The index to start at</param>
        </member>
        <member name="M:bedrock.collections.Tree.Add(System.Object,System.Object)">
            <summary>
            Add an item to the tree
            </summary>
            <param name="key">The key for the item</param>
            <param name="value">The data to store with this key</param>
            <exception cref="T:System.ArgumentException">Thrown if the same key is added twice</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if key is null</exception>
        </member>
        <member name="M:bedrock.collections.Tree.Clear">
            <summary>
            Remove all values from the tree.
            </summary>
        </member>
        <member name="M:bedrock.collections.Tree.Contains(System.Object)">
            <summary>
            Determines if the specified key exists in the tree.
            </summary>
            <param name="key">The key to search for</param>
            <returns>True if the key exists in the tree; otherwise false.</returns>
        </member>
        <member name="M:bedrock.collections.Tree.GetEnumerator">
            <summary>
            Returns a dictionary enumerator.
            </summary>
            <returns>A dictionary enumerator</returns>
        </member>
        <member name="M:bedrock.collections.Tree.Remove(System.Object)">
            <summary>
            Remove the element from the tree associated
            with this key, possibly rebalancing.
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:bedrock.collections.Tree.ToString">
            <summary>
            Retrieves a string representation of the tree.
            </summary>
            <returns>string in the format '{key1}={value1}, {key2}={value2}, ...'</returns>
        </member>
        <member name="M:bedrock.collections.Tree.Structure">
            <summary>
            Retrieve a string representation of the tree.
            Nice for debugging, but otherwise useless.
            </summary>
            <returns></returns>
        </member>
        <member name="P:bedrock.collections.Tree.Count">
            <summary>
            The number of items in the tree.
            </summary>
        </member>
        <member name="P:bedrock.collections.Tree.IsSynchronized">
            <summary>
            Gets a value indicating whether access to the tree is synchronized in thread-safe mode.
            Currently, it only returns false.
            </summary>
        </member>
        <member name="P:bedrock.collections.Tree.SyncRoot">
            <summary>
            Gets an object that can be used to sychronize access to the tree. For now, it returns null.
            </summary>
        </member>
        <member name="P:bedrock.collections.Tree.Item(System.Object)">
            <summary>
            Retrieves the value associated with the given key.
            </summary>
        </member>
        <member name="P:bedrock.collections.Tree.Keys">
            <summary>
            Retrieve a list of keys.
            </summary>
        </member>
        <member name="P:bedrock.collections.Tree.Values">
            <summary>
            Retrieves a list of values.
            </summary>
        </member>
        <member name="P:bedrock.collections.Tree.IsFixedSize">
            <summary>
            Always returns false for now.
            </summary>
        </member>
        <member name="P:bedrock.collections.Tree.IsReadOnly">
            <summary>
            Always returns false for now.
            </summary>
        </member>
        <member name="T:bedrock.collections.SetImplementation">
            <summary>
            The different ways a set can be implemented.
            </summary>
        </member>
        <member name="F:bedrock.collections.SetImplementation.Hashtable">
            <summary>
            Hash table.
            </summary>
        </member>
        <member name="F:bedrock.collections.SetImplementation.Tree">
            <summary>
            Red/Black tree.
            </summary>
        </member>
        <member name="F:bedrock.collections.SetImplementation.SkipList">
            <summary>
            Skip List.
            </summary>
        </member>
        <member name="T:bedrock.collections.Set">
            <summary>
            Set backed into a Tree.
            </summary>
        </member>
        <member name="M:bedrock.collections.Set.#ctor">
            <summary>
            Creates a new, empty Set backed into a hash table.
            </summary>
        </member>
        <member name="M:bedrock.collections.Set.#ctor(bedrock.collections.SetImplementation)">
            <summary>
            Creates a set with the given back-end implementation.
            </summary>
            <param name="impl">How to implement the set.</param>
        </member>
        <member name="M:bedrock.collections.Set.Add(System.Object)">
            <summary>
            Adds an object to the set.
            </summary>
            <param name="o">The object to add</param>
            <exception cref="T:System.ArgumentException">object was already in the set.</exception>
        </member>
        <member name="M:bedrock.collections.Set.Remove(System.Object)">
            <summary>
            Removes the given object from the set.
            There is no exception thrown if the object is not in the set.
            </summary>
            <param name="o">The object to remove.</param>
        </member>
        <member name="M:bedrock.collections.Set.Clear">
            <summary>
            Removes all items from the set.
            </summary>
        </member>
        <member name="M:bedrock.collections.Set.Contains(System.Object)">
            <summary>
            Determines if the given object is in the set.
            </summary>
            <param name="o">The object to search for.</param>
            <returns>True if the object is in the set.</returns>
        </member>
        <member name="M:bedrock.collections.Set.Union(bedrock.collections.ISet)">
            <summary>
            Returns a new collection that contains all of the items that
            are in this set or the other set.
            </summary>
            <param name="other">Second set to combine.</param>
            <returns>Combined set.</returns>
        </member>
        <member name="M:bedrock.collections.Set.Intersection(bedrock.collections.ISet)">
            <summary>
            Returns a new collection that contains all of the items that
            are in this list *and* the other set.
            </summary>
            <param name="other">
            Other set to intersect with.
            </param>
            <returns>Combined set.</returns>
        </member>
        <member name="M:bedrock.collections.Set.CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the ICollection to an Array, starting at a particular Array index.
            </summary>
            <param name="array">The array to copy.</param>
            <param name="index">The index to start at.</param>
        </member>
        <member name="M:bedrock.collections.Set.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through all items in the set.
            </summary>
            <returns>An IEnumerator for the entire set.</returns>
        </member>
        <member name="P:bedrock.collections.Set.IsSynchronized">
            <summary>
            Gets a value indicating whether access to the ICollection is synchronized (thread-safe).
            </summary>
        </member>
        <member name="P:bedrock.collections.Set.Count">
            <summary>
            Gets the number of items in the set.
            </summary>
        </member>
        <member name="P:bedrock.collections.Set.SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the ICollection.
            </summary>
        </member>
    </members>
</doc>
